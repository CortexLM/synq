# [allow (dead_code , unused_imports , non_camel_case_types , unreachable_patterns)] # [allow (clippy :: all)] # [allow (rustdoc :: broken_intra_doc_links)] pub mod api { # [allow (unused_imports)] mod root_mod { pub use super :: * ; } pub static PALLETS : [& str ; 21usize] = ["System" , "RandomnessCollectiveFlip" , "Timestamp" , "Aura" , "Grandpa" , "Balances" , "TransactionPayment" , "SubtensorModule" , "Triumvirate" , "TriumvirateMembers" , "SenateMembers" , "Utility" , "Sudo" , "Multisig" , "Preimage" , "Scheduler" , "Proxy" , "Registry" , "Commitments" , "AdminUtils" , "SafeMode" ,] ; pub static RUNTIME_APIS : [& str ; 17usize] = ["Core" , "Metadata" , "BlockBuilder" , "GenesisBuilder" , "TaggedTransactionQueue" , "OffchainWorkerApi" , "AuraApi" , "SessionKeys" , "GrandpaApi" , "AccountNonceApi" , "TransactionPaymentApi" , "TransactionPaymentCallApi" , "DelegateInfoRuntimeApi" , "NeuronInfoRuntimeApi" , "SubnetInfoRuntimeApi" , "StakeInfoRuntimeApi" , "SubnetRegistrationRuntimeApi" ,] ; # [doc = r" The error type that is returned when there is a runtime issue."] pub type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [doc = r" The outer event enum."] pub type Event = runtime_types :: node_subtensor_runtime :: RuntimeEvent ; # [doc = r" The outer extrinsic enum."] pub type Call = runtime_types :: node_subtensor_runtime :: RuntimeCall ; # [doc = r" The outer error enum represents the DispatchError's Module variant."] pub type Error = runtime_types :: node_subtensor_runtime :: RuntimeError ; pub fn constants () -> ConstantsApi { ConstantsApi } pub fn storage () -> StorageApi { StorageApi } pub fn tx () -> TransactionApi { TransactionApi } pub fn apis () -> runtime_apis :: RuntimeApi { runtime_apis :: RuntimeApi } pub mod runtime_apis { use super :: root_mod ; use super :: runtime_types ; use :: subxt :: ext :: subxt_core :: ext :: codec :: Encode ; pub struct RuntimeApi ; impl RuntimeApi { pub fn core (& self) -> core :: Core { core :: Core } pub fn metadata (& self) -> metadata :: Metadata { metadata :: Metadata } pub fn block_builder (& self) -> block_builder :: BlockBuilder { block_builder :: BlockBuilder } pub fn genesis_builder (& self) -> genesis_builder :: GenesisBuilder { genesis_builder :: GenesisBuilder } pub fn tagged_transaction_queue (& self) -> tagged_transaction_queue :: TaggedTransactionQueue { tagged_transaction_queue :: TaggedTransactionQueue } pub fn offchain_worker_api (& self) -> offchain_worker_api :: OffchainWorkerApi { offchain_worker_api :: OffchainWorkerApi } pub fn aura_api (& self) -> aura_api :: AuraApi { aura_api :: AuraApi } pub fn session_keys (& self) -> session_keys :: SessionKeys { session_keys :: SessionKeys } pub fn grandpa_api (& self) -> grandpa_api :: GrandpaApi { grandpa_api :: GrandpaApi } pub fn account_nonce_api (& self) -> account_nonce_api :: AccountNonceApi { account_nonce_api :: AccountNonceApi } pub fn transaction_payment_api (& self) -> transaction_payment_api :: TransactionPaymentApi { transaction_payment_api :: TransactionPaymentApi } pub fn transaction_payment_call_api (& self) -> transaction_payment_call_api :: TransactionPaymentCallApi { transaction_payment_call_api :: TransactionPaymentCallApi } pub fn delegate_info_runtime_api (& self) -> delegate_info_runtime_api :: DelegateInfoRuntimeApi { delegate_info_runtime_api :: DelegateInfoRuntimeApi } pub fn neuron_info_runtime_api (& self) -> neuron_info_runtime_api :: NeuronInfoRuntimeApi { neuron_info_runtime_api :: NeuronInfoRuntimeApi } pub fn subnet_info_runtime_api (& self) -> subnet_info_runtime_api :: SubnetInfoRuntimeApi { subnet_info_runtime_api :: SubnetInfoRuntimeApi } pub fn stake_info_runtime_api (& self) -> stake_info_runtime_api :: StakeInfoRuntimeApi { stake_info_runtime_api :: StakeInfoRuntimeApi } pub fn subnet_registration_runtime_api (& self) -> subnet_registration_runtime_api :: SubnetRegistrationRuntimeApi { subnet_registration_runtime_api :: SubnetRegistrationRuntimeApi } } pub mod core { use super :: root_mod ; use super :: runtime_types ; # [doc = " The `Core` runtime api that every Substrate runtime needs to implement."] pub struct Core ; impl Core { # [doc = " Returns the version of the runtime."] pub fn version (& self ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: Version , types :: version :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("Core" , "version" , types :: Version { } , [76u8 , 202u8 , 17u8 , 117u8 , 189u8 , 237u8 , 239u8 , 237u8 , 151u8 , 17u8 , 125u8 , 159u8 , 218u8 , 92u8 , 57u8 , 238u8 , 64u8 , 147u8 , 40u8 , 72u8 , 157u8 , 116u8 , 37u8 , 195u8 , 156u8 , 27u8 , 123u8 , 173u8 , 178u8 , 102u8 , 136u8 , 6u8 ,] ,) } # [doc = " Execute the given block."] pub fn execute_block (& self , block : types :: execute_block :: Block ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: ExecuteBlock , types :: execute_block :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("Core" , "execute_block" , types :: ExecuteBlock { block , } , [133u8 , 135u8 , 228u8 , 65u8 , 106u8 , 27u8 , 85u8 , 158u8 , 112u8 , 254u8 , 93u8 , 26u8 , 102u8 , 201u8 , 118u8 , 216u8 , 249u8 , 247u8 , 91u8 , 74u8 , 56u8 , 208u8 , 231u8 , 115u8 , 131u8 , 29u8 , 209u8 , 6u8 , 65u8 , 57u8 , 214u8 , 125u8 ,] ,) } # [doc = " Initialize a block with the given header and return the runtime executive mode."] pub fn initialize_block (& self , header : types :: initialize_block :: Header ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: InitializeBlock , types :: initialize_block :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("Core" , "initialize_block" , types :: InitializeBlock { header , } , [132u8 , 169u8 , 113u8 , 112u8 , 80u8 , 139u8 , 113u8 , 35u8 , 41u8 , 81u8 , 36u8 , 35u8 , 37u8 , 202u8 , 29u8 , 207u8 , 205u8 , 229u8 , 145u8 , 7u8 , 133u8 , 94u8 , 25u8 , 108u8 , 233u8 , 86u8 , 234u8 , 29u8 , 236u8 , 57u8 , 56u8 , 186u8 ,] ,) } } pub mod types { use super :: runtime_types ; pub mod version { use super :: runtime_types ; pub mod output { use super :: runtime_types ; pub type Output = runtime_types :: sp_version :: RuntimeVersion ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct Version { } pub mod execute_block { use super :: runtime_types ; pub type Block = runtime_types :: sp_runtime :: generic :: block :: Block < runtime_types :: sp_runtime :: generic :: header :: Header < :: core :: primitive :: u32 > , :: subxt :: ext :: subxt_core :: utils :: UncheckedExtrinsic < :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > , runtime_types :: node_subtensor_runtime :: RuntimeCall , runtime_types :: sp_runtime :: MultiSignature , (runtime_types :: frame_system :: extensions :: check_non_zero_sender :: CheckNonZeroSender , runtime_types :: frame_system :: extensions :: check_spec_version :: CheckSpecVersion , runtime_types :: frame_system :: extensions :: check_tx_version :: CheckTxVersion , runtime_types :: frame_system :: extensions :: check_genesis :: CheckGenesis , runtime_types :: frame_system :: extensions :: check_mortality :: CheckMortality , runtime_types :: node_subtensor_runtime :: check_nonce :: CheckNonce , runtime_types :: frame_system :: extensions :: check_weight :: CheckWeight , runtime_types :: pallet_transaction_payment :: ChargeTransactionPayment , runtime_types :: pallet_subtensor :: SubtensorSignedExtension < runtime_types :: node_subtensor_runtime :: Runtime > , runtime_types :: pallet_commitments :: CommitmentsSignedExtension < runtime_types :: node_subtensor_runtime :: Runtime > , runtime_types :: frame_metadata_hash_extension :: CheckMetadataHash ,) > > ; pub mod output { use super :: runtime_types ; pub type Output = () ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct ExecuteBlock { pub block : execute_block :: Block , } pub mod initialize_block { use super :: runtime_types ; pub type Header = runtime_types :: sp_runtime :: generic :: header :: Header < :: core :: primitive :: u32 > ; pub mod output { use super :: runtime_types ; pub type Output = runtime_types :: sp_runtime :: ExtrinsicInclusionMode ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct InitializeBlock { pub header : initialize_block :: Header , } } } pub mod metadata { use super :: root_mod ; use super :: runtime_types ; # [doc = " The `Metadata` api trait that returns metadata for the runtime."] pub struct Metadata ; impl Metadata { # [doc = " Returns the metadata of a runtime."] pub fn metadata (& self ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: Metadata , types :: metadata :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("Metadata" , "metadata" , types :: Metadata { } , [231u8 , 24u8 , 67u8 , 152u8 , 23u8 , 26u8 , 188u8 , 82u8 , 229u8 , 6u8 , 185u8 , 27u8 , 175u8 , 68u8 , 83u8 , 122u8 , 69u8 , 89u8 , 185u8 , 74u8 , 248u8 , 87u8 , 217u8 , 124u8 , 193u8 , 252u8 , 199u8 , 186u8 , 196u8 , 179u8 , 179u8 , 96u8 ,] ,) } # [doc = " Returns the metadata at a given version."] # [doc = ""] # [doc = " If the given `version` isn't supported, this will return `None`."] # [doc = " Use [`Self::metadata_versions`] to find out about supported metadata version of the runtime."] pub fn metadata_at_version (& self , version : types :: metadata_at_version :: Version ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: MetadataAtVersion , types :: metadata_at_version :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("Metadata" , "metadata_at_version" , types :: MetadataAtVersion { version , } , [131u8 , 53u8 , 212u8 , 234u8 , 16u8 , 25u8 , 120u8 , 252u8 , 153u8 , 153u8 , 216u8 , 28u8 , 54u8 , 113u8 , 52u8 , 236u8 , 146u8 , 68u8 , 142u8 , 8u8 , 10u8 , 169u8 , 131u8 , 142u8 , 204u8 , 38u8 , 48u8 , 108u8 , 134u8 , 86u8 , 226u8 , 61u8 ,] ,) } # [doc = " Returns the supported metadata versions."] # [doc = ""] # [doc = " This can be used to call `metadata_at_version`."] pub fn metadata_versions (& self ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: MetadataVersions , types :: metadata_versions :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("Metadata" , "metadata_versions" , types :: MetadataVersions { } , [23u8 , 144u8 , 137u8 , 91u8 , 188u8 , 39u8 , 231u8 , 208u8 , 252u8 , 218u8 , 224u8 , 176u8 , 77u8 , 32u8 , 130u8 , 212u8 , 223u8 , 76u8 , 100u8 , 190u8 , 82u8 , 94u8 , 190u8 , 8u8 , 82u8 , 244u8 , 225u8 , 179u8 , 85u8 , 176u8 , 56u8 , 16u8 ,] ,) } } pub mod types { use super :: runtime_types ; pub mod metadata { use super :: runtime_types ; pub mod output { use super :: runtime_types ; pub type Output = runtime_types :: sp_core :: OpaqueMetadata ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct Metadata { } pub mod metadata_at_version { use super :: runtime_types ; pub type Version = :: core :: primitive :: u32 ; pub mod output { use super :: runtime_types ; pub type Output = :: core :: option :: Option < runtime_types :: sp_core :: OpaqueMetadata > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct MetadataAtVersion { pub version : metadata_at_version :: Version , } pub mod metadata_versions { use super :: runtime_types ; pub mod output { use super :: runtime_types ; pub type Output = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u32 > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct MetadataVersions { } } } pub mod block_builder { use super :: root_mod ; use super :: runtime_types ; # [doc = " The `BlockBuilder` api trait that provides the required functionality for building a block."] pub struct BlockBuilder ; impl BlockBuilder { # [doc = " Apply the given extrinsic."] # [doc = ""] # [doc = " Returns an inclusion outcome which specifies if this extrinsic is included in"] # [doc = " this block or not."] pub fn apply_extrinsic (& self , extrinsic : types :: apply_extrinsic :: Extrinsic ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: ApplyExtrinsic , types :: apply_extrinsic :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("BlockBuilder" , "apply_extrinsic" , types :: ApplyExtrinsic { extrinsic , } , [72u8 , 54u8 , 139u8 , 3u8 , 118u8 , 136u8 , 65u8 , 47u8 , 6u8 , 105u8 , 125u8 , 223u8 , 160u8 , 29u8 , 103u8 , 74u8 , 79u8 , 149u8 , 48u8 , 90u8 , 237u8 , 2u8 , 97u8 , 201u8 , 123u8 , 34u8 , 167u8 , 37u8 , 187u8 , 35u8 , 176u8 , 97u8 ,] ,) } # [doc = " Finish the current block."] pub fn finalize_block (& self ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: FinalizeBlock , types :: finalize_block :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("BlockBuilder" , "finalize_block" , types :: FinalizeBlock { } , [244u8 , 207u8 , 24u8 , 33u8 , 13u8 , 69u8 , 9u8 , 249u8 , 145u8 , 143u8 , 122u8 , 96u8 , 197u8 , 55u8 , 64u8 , 111u8 , 238u8 , 224u8 , 34u8 , 201u8 , 27u8 , 146u8 , 232u8 , 99u8 , 191u8 , 30u8 , 114u8 , 16u8 , 32u8 , 220u8 , 58u8 , 62u8 ,] ,) } # [doc = " Generate inherent extrinsics. The inherent data will vary from chain to chain."] pub fn inherent_extrinsics (& self , inherent : types :: inherent_extrinsics :: Inherent ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: InherentExtrinsics , types :: inherent_extrinsics :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("BlockBuilder" , "inherent_extrinsics" , types :: InherentExtrinsics { inherent , } , [254u8 , 110u8 , 245u8 , 201u8 , 250u8 , 192u8 , 27u8 , 228u8 , 151u8 , 213u8 , 166u8 , 89u8 , 94u8 , 81u8 , 189u8 , 234u8 , 64u8 , 18u8 , 245u8 , 80u8 , 29u8 , 18u8 , 140u8 , 129u8 , 113u8 , 236u8 , 135u8 , 55u8 , 79u8 , 159u8 , 175u8 , 183u8 ,] ,) } # [doc = " Check that the inherents are valid. The inherent data will vary from chain to chain."] pub fn check_inherents (& self , block : types :: check_inherents :: Block , data : types :: check_inherents :: Data ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: CheckInherents , types :: check_inherents :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("BlockBuilder" , "check_inherents" , types :: CheckInherents { block , data , } , [153u8 , 134u8 , 1u8 , 215u8 , 139u8 , 11u8 , 53u8 , 51u8 , 210u8 , 175u8 , 197u8 , 28u8 , 38u8 , 209u8 , 175u8 , 247u8 , 142u8 , 157u8 , 50u8 , 151u8 , 164u8 , 191u8 , 181u8 , 118u8 , 80u8 , 97u8 , 160u8 , 248u8 , 110u8 , 217u8 , 181u8 , 234u8 ,] ,) } } pub mod types { use super :: runtime_types ; pub mod apply_extrinsic { use super :: runtime_types ; pub type Extrinsic = :: subxt :: ext :: subxt_core :: utils :: UncheckedExtrinsic < :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > , runtime_types :: node_subtensor_runtime :: RuntimeCall , runtime_types :: sp_runtime :: MultiSignature , (runtime_types :: frame_system :: extensions :: check_non_zero_sender :: CheckNonZeroSender , runtime_types :: frame_system :: extensions :: check_spec_version :: CheckSpecVersion , runtime_types :: frame_system :: extensions :: check_tx_version :: CheckTxVersion , runtime_types :: frame_system :: extensions :: check_genesis :: CheckGenesis , runtime_types :: frame_system :: extensions :: check_mortality :: CheckMortality , runtime_types :: node_subtensor_runtime :: check_nonce :: CheckNonce , runtime_types :: frame_system :: extensions :: check_weight :: CheckWeight , runtime_types :: pallet_transaction_payment :: ChargeTransactionPayment , runtime_types :: pallet_subtensor :: SubtensorSignedExtension < runtime_types :: node_subtensor_runtime :: Runtime > , runtime_types :: pallet_commitments :: CommitmentsSignedExtension < runtime_types :: node_subtensor_runtime :: Runtime > , runtime_types :: frame_metadata_hash_extension :: CheckMetadataHash ,) > ; pub mod output { use super :: runtime_types ; pub type Output = :: core :: result :: Result < :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > , runtime_types :: sp_runtime :: transaction_validity :: TransactionValidityError > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct ApplyExtrinsic { pub extrinsic : apply_extrinsic :: Extrinsic , } pub mod finalize_block { use super :: runtime_types ; pub mod output { use super :: runtime_types ; pub type Output = runtime_types :: sp_runtime :: generic :: header :: Header < :: core :: primitive :: u32 > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct FinalizeBlock { } pub mod inherent_extrinsics { use super :: runtime_types ; pub type Inherent = runtime_types :: sp_inherents :: InherentData ; pub mod output { use super :: runtime_types ; pub type Output = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: subxt :: ext :: subxt_core :: utils :: UncheckedExtrinsic < :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > , runtime_types :: node_subtensor_runtime :: RuntimeCall , runtime_types :: sp_runtime :: MultiSignature , (runtime_types :: frame_system :: extensions :: check_non_zero_sender :: CheckNonZeroSender , runtime_types :: frame_system :: extensions :: check_spec_version :: CheckSpecVersion , runtime_types :: frame_system :: extensions :: check_tx_version :: CheckTxVersion , runtime_types :: frame_system :: extensions :: check_genesis :: CheckGenesis , runtime_types :: frame_system :: extensions :: check_mortality :: CheckMortality , runtime_types :: node_subtensor_runtime :: check_nonce :: CheckNonce , runtime_types :: frame_system :: extensions :: check_weight :: CheckWeight , runtime_types :: pallet_transaction_payment :: ChargeTransactionPayment , runtime_types :: pallet_subtensor :: SubtensorSignedExtension < runtime_types :: node_subtensor_runtime :: Runtime > , runtime_types :: pallet_commitments :: CommitmentsSignedExtension < runtime_types :: node_subtensor_runtime :: Runtime > , runtime_types :: frame_metadata_hash_extension :: CheckMetadataHash ,) > > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct InherentExtrinsics { pub inherent : inherent_extrinsics :: Inherent , } pub mod check_inherents { use super :: runtime_types ; pub type Block = runtime_types :: sp_runtime :: generic :: block :: Block < runtime_types :: sp_runtime :: generic :: header :: Header < :: core :: primitive :: u32 > , :: subxt :: ext :: subxt_core :: utils :: UncheckedExtrinsic < :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > , runtime_types :: node_subtensor_runtime :: RuntimeCall , runtime_types :: sp_runtime :: MultiSignature , (runtime_types :: frame_system :: extensions :: check_non_zero_sender :: CheckNonZeroSender , runtime_types :: frame_system :: extensions :: check_spec_version :: CheckSpecVersion , runtime_types :: frame_system :: extensions :: check_tx_version :: CheckTxVersion , runtime_types :: frame_system :: extensions :: check_genesis :: CheckGenesis , runtime_types :: frame_system :: extensions :: check_mortality :: CheckMortality , runtime_types :: node_subtensor_runtime :: check_nonce :: CheckNonce , runtime_types :: frame_system :: extensions :: check_weight :: CheckWeight , runtime_types :: pallet_transaction_payment :: ChargeTransactionPayment , runtime_types :: pallet_subtensor :: SubtensorSignedExtension < runtime_types :: node_subtensor_runtime :: Runtime > , runtime_types :: pallet_commitments :: CommitmentsSignedExtension < runtime_types :: node_subtensor_runtime :: Runtime > , runtime_types :: frame_metadata_hash_extension :: CheckMetadataHash ,) > > ; pub type Data = runtime_types :: sp_inherents :: InherentData ; pub mod output { use super :: runtime_types ; pub type Output = runtime_types :: sp_inherents :: CheckInherentsResult ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct CheckInherents { pub block : check_inherents :: Block , pub data : check_inherents :: Data , } } } pub mod genesis_builder { use super :: root_mod ; use super :: runtime_types ; # [doc = " API to interact with RuntimeGenesisConfig for the runtime"] pub struct GenesisBuilder ; impl GenesisBuilder { # [doc = " Creates the default `RuntimeGenesisConfig` and returns it as a JSON blob."] # [doc = ""] # [doc = " This function instantiates the default `RuntimeGenesisConfig` struct for the runtime and serializes it into a JSON"] # [doc = " blob. It returns a `Vec<u8>` containing the JSON representation of the default `RuntimeGenesisConfig`."] pub fn create_default_config (& self ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: CreateDefaultConfig , types :: create_default_config :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("GenesisBuilder" , "create_default_config" , types :: CreateDefaultConfig { } , [238u8 , 5u8 , 139u8 , 81u8 , 184u8 , 155u8 , 221u8 , 118u8 , 190u8 , 76u8 , 229u8 , 67u8 , 132u8 , 89u8 , 83u8 , 80u8 , 56u8 , 171u8 , 169u8 , 64u8 , 123u8 , 20u8 , 129u8 , 159u8 , 28u8 , 135u8 , 84u8 , 52u8 , 192u8 , 98u8 , 104u8 , 214u8 ,] ,) } # [doc = " Build `RuntimeGenesisConfig` from a JSON blob not using any defaults and store it in the storage."] # [doc = ""] # [doc = " This function deserializes the full `RuntimeGenesisConfig` from the given JSON blob and puts it into the storage."] # [doc = " If the provided JSON blob is incorrect or incomplete or the deserialization fails, an error is returned."] # [doc = " It is recommended to log any errors encountered during the process."] # [doc = ""] # [doc = " Please note that provided json blob must contain all `RuntimeGenesisConfig` fields, no defaults will be used."] pub fn build_config (& self , json : types :: build_config :: Json ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: BuildConfig , types :: build_config :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("GenesisBuilder" , "build_config" , types :: BuildConfig { json , } , [6u8 , 98u8 , 68u8 , 125u8 , 157u8 , 26u8 , 107u8 , 86u8 , 213u8 , 227u8 , 26u8 , 229u8 , 122u8 , 161u8 , 229u8 , 114u8 , 123u8 , 192u8 , 66u8 , 231u8 , 148u8 , 175u8 , 5u8 , 185u8 , 248u8 , 88u8 , 40u8 , 122u8 , 230u8 , 209u8 , 170u8 , 254u8 ,] ,) } } pub mod types { use super :: runtime_types ; pub mod create_default_config { use super :: runtime_types ; pub mod output { use super :: runtime_types ; pub type Output = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct CreateDefaultConfig { } pub mod build_config { use super :: runtime_types ; pub type Json = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ; pub mod output { use super :: runtime_types ; pub type Output = :: core :: result :: Result < () , :: subxt :: ext :: subxt_core :: alloc :: string :: String > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct BuildConfig { pub json : build_config :: Json , } } } pub mod tagged_transaction_queue { use super :: root_mod ; use super :: runtime_types ; # [doc = " The `TaggedTransactionQueue` api trait for interfering with the transaction queue."] pub struct TaggedTransactionQueue ; impl TaggedTransactionQueue { # [doc = " Validate the transaction."] # [doc = ""] # [doc = " This method is invoked by the transaction pool to learn details about given transaction."] # [doc = " The implementation should make sure to verify the correctness of the transaction"] # [doc = " against current state. The given `block_hash` corresponds to the hash of the block"] # [doc = " that is used as current state."] # [doc = ""] # [doc = " Note that this call may be performed by the pool multiple times and transactions"] # [doc = " might be verified in any possible order."] pub fn validate_transaction (& self , source : types :: validate_transaction :: Source , tx : types :: validate_transaction :: Tx , block_hash : types :: validate_transaction :: BlockHash ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: ValidateTransaction , types :: validate_transaction :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("TaggedTransactionQueue" , "validate_transaction" , types :: ValidateTransaction { source , tx , block_hash , } , [196u8 , 50u8 , 90u8 , 49u8 , 109u8 , 251u8 , 200u8 , 35u8 , 23u8 , 150u8 , 140u8 , 143u8 , 232u8 , 164u8 , 133u8 , 89u8 , 32u8 , 240u8 , 115u8 , 39u8 , 95u8 , 70u8 , 162u8 , 76u8 , 122u8 , 73u8 , 151u8 , 144u8 , 234u8 , 120u8 , 100u8 , 29u8 ,] ,) } } pub mod types { use super :: runtime_types ; pub mod validate_transaction { use super :: runtime_types ; pub type Source = runtime_types :: sp_runtime :: transaction_validity :: TransactionSource ; pub type Tx = :: subxt :: ext :: subxt_core :: utils :: UncheckedExtrinsic < :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > , runtime_types :: node_subtensor_runtime :: RuntimeCall , runtime_types :: sp_runtime :: MultiSignature , (runtime_types :: frame_system :: extensions :: check_non_zero_sender :: CheckNonZeroSender , runtime_types :: frame_system :: extensions :: check_spec_version :: CheckSpecVersion , runtime_types :: frame_system :: extensions :: check_tx_version :: CheckTxVersion , runtime_types :: frame_system :: extensions :: check_genesis :: CheckGenesis , runtime_types :: frame_system :: extensions :: check_mortality :: CheckMortality , runtime_types :: node_subtensor_runtime :: check_nonce :: CheckNonce , runtime_types :: frame_system :: extensions :: check_weight :: CheckWeight , runtime_types :: pallet_transaction_payment :: ChargeTransactionPayment , runtime_types :: pallet_subtensor :: SubtensorSignedExtension < runtime_types :: node_subtensor_runtime :: Runtime > , runtime_types :: pallet_commitments :: CommitmentsSignedExtension < runtime_types :: node_subtensor_runtime :: Runtime > , runtime_types :: frame_metadata_hash_extension :: CheckMetadataHash ,) > ; pub type BlockHash = :: subxt :: ext :: subxt_core :: utils :: H256 ; pub mod output { use super :: runtime_types ; pub type Output = :: core :: result :: Result < runtime_types :: sp_runtime :: transaction_validity :: ValidTransaction , runtime_types :: sp_runtime :: transaction_validity :: TransactionValidityError > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct ValidateTransaction { pub source : validate_transaction :: Source , pub tx : validate_transaction :: Tx , pub block_hash : validate_transaction :: BlockHash , } } } pub mod offchain_worker_api { use super :: root_mod ; use super :: runtime_types ; # [doc = " The offchain worker api."] pub struct OffchainWorkerApi ; impl OffchainWorkerApi { # [doc = " Starts the off-chain task for given block header."] pub fn offchain_worker (& self , header : types :: offchain_worker :: Header ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: OffchainWorker , types :: offchain_worker :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("OffchainWorkerApi" , "offchain_worker" , types :: OffchainWorker { header , } , [10u8 , 135u8 , 19u8 , 153u8 , 33u8 , 216u8 , 18u8 , 242u8 , 33u8 , 140u8 , 4u8 , 223u8 , 200u8 , 130u8 , 103u8 , 118u8 , 137u8 , 24u8 , 19u8 , 127u8 , 161u8 , 29u8 , 184u8 , 111u8 , 222u8 , 111u8 , 253u8 , 73u8 , 45u8 , 31u8 , 79u8 , 60u8 ,] ,) } } pub mod types { use super :: runtime_types ; pub mod offchain_worker { use super :: runtime_types ; pub type Header = runtime_types :: sp_runtime :: generic :: header :: Header < :: core :: primitive :: u32 > ; pub mod output { use super :: runtime_types ; pub type Output = () ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct OffchainWorker { pub header : offchain_worker :: Header , } } } pub mod aura_api { use super :: root_mod ; use super :: runtime_types ; # [doc = " API necessary for block authorship with aura."] pub struct AuraApi ; impl AuraApi { # [doc = " Returns the slot duration for Aura."] # [doc = ""] # [doc = " Currently, only the value provided by this type at genesis will be used."] pub fn slot_duration (& self ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: SlotDuration , types :: slot_duration :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("AuraApi" , "slot_duration" , types :: SlotDuration { } , [233u8 , 210u8 , 132u8 , 172u8 , 100u8 , 125u8 , 239u8 , 92u8 , 114u8 , 82u8 , 7u8 , 110u8 , 179u8 , 196u8 , 10u8 , 19u8 , 211u8 , 15u8 , 174u8 , 2u8 , 91u8 , 73u8 , 133u8 , 100u8 , 205u8 , 201u8 , 191u8 , 60u8 , 163u8 , 122u8 , 215u8 , 10u8 ,] ,) } # [doc = " Return the current set of authorities."] pub fn authorities (& self ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: Authorities , types :: authorities :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("AuraApi" , "authorities" , types :: Authorities { } , [35u8 , 244u8 , 24u8 , 155u8 , 95u8 , 1u8 , 221u8 , 159u8 , 33u8 , 144u8 , 213u8 , 26u8 , 13u8 , 21u8 , 136u8 , 72u8 , 45u8 , 47u8 , 15u8 , 51u8 , 235u8 , 10u8 , 6u8 , 219u8 , 9u8 , 246u8 , 50u8 , 252u8 , 49u8 , 77u8 , 64u8 , 182u8 ,] ,) } } pub mod types { use super :: runtime_types ; pub mod slot_duration { use super :: runtime_types ; pub mod output { use super :: runtime_types ; pub type Output = runtime_types :: sp_consensus_slots :: SlotDuration ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct SlotDuration { } pub mod authorities { use super :: runtime_types ; pub mod output { use super :: runtime_types ; pub type Output = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < runtime_types :: sp_consensus_aura :: sr25519 :: app_sr25519 :: Public > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct Authorities { } } } pub mod session_keys { use super :: root_mod ; use super :: runtime_types ; # [doc = " Session keys runtime api."] pub struct SessionKeys ; impl SessionKeys { # [doc = " Generate a set of session keys with optionally using the given seed."] # [doc = " The keys should be stored within the keystore exposed via runtime"] # [doc = " externalities."] # [doc = ""] # [doc = " The seed needs to be a valid `utf8` string."] # [doc = ""] # [doc = " Returns the concatenated SCALE encoded public keys."] pub fn generate_session_keys (& self , seed : types :: generate_session_keys :: Seed ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: GenerateSessionKeys , types :: generate_session_keys :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("SessionKeys" , "generate_session_keys" , types :: GenerateSessionKeys { seed , } , [96u8 , 171u8 , 164u8 , 166u8 , 175u8 , 102u8 , 101u8 , 47u8 , 133u8 , 95u8 , 102u8 , 202u8 , 83u8 , 26u8 , 238u8 , 47u8 , 126u8 , 132u8 , 22u8 , 11u8 , 33u8 , 190u8 , 175u8 , 94u8 , 58u8 , 245u8 , 46u8 , 80u8 , 195u8 , 184u8 , 107u8 , 65u8 ,] ,) } # [doc = " Decode the given public session keys."] # [doc = ""] # [doc = " Returns the list of public raw public keys + key type."] pub fn decode_session_keys (& self , encoded : types :: decode_session_keys :: Encoded ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: DecodeSessionKeys , types :: decode_session_keys :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("SessionKeys" , "decode_session_keys" , types :: DecodeSessionKeys { encoded , } , [57u8 , 242u8 , 18u8 , 51u8 , 132u8 , 110u8 , 238u8 , 255u8 , 39u8 , 194u8 , 8u8 , 54u8 , 198u8 , 178u8 , 75u8 , 151u8 , 148u8 , 176u8 , 144u8 , 197u8 , 87u8 , 29u8 , 179u8 , 235u8 , 176u8 , 78u8 , 252u8 , 103u8 , 72u8 , 203u8 , 151u8 , 248u8 ,] ,) } } pub mod types { use super :: runtime_types ; pub mod generate_session_keys { use super :: runtime_types ; pub type Seed = :: core :: option :: Option < :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > > ; pub mod output { use super :: runtime_types ; pub type Output = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct GenerateSessionKeys { pub seed : generate_session_keys :: Seed , } pub mod decode_session_keys { use super :: runtime_types ; pub type Encoded = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ; pub mod output { use super :: runtime_types ; pub type Output = :: core :: option :: Option < :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < (:: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > , runtime_types :: sp_core :: crypto :: KeyTypeId ,) > > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct DecodeSessionKeys { pub encoded : decode_session_keys :: Encoded , } } } pub mod grandpa_api { use super :: root_mod ; use super :: runtime_types ; # [doc = " APIs for integrating the GRANDPA finality gadget into runtimes."] # [doc = " This should be implemented on the runtime side."] # [doc = ""] # [doc = " This is primarily used for negotiating authority-set changes for the"] # [doc = " gadget. GRANDPA uses a signaling model of changing authority sets:"] # [doc = " changes should be signaled with a delay of N blocks, and then automatically"] # [doc = " applied in the runtime after those N blocks have passed."] # [doc = ""] # [doc = " The consensus protocol will coordinate the handoff externally."] pub struct GrandpaApi ; impl GrandpaApi { # [doc = " Get the current GRANDPA authorities and weights. This should not change except"] # [doc = " for when changes are scheduled and the corresponding delay has passed."] # [doc = ""] # [doc = " When called at block B, it will return the set of authorities that should be"] # [doc = " used to finalize descendants of this block (B+1, B+2, ...). The block B itself"] # [doc = " is finalized by the authorities from block B-1."] pub fn grandpa_authorities (& self ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: GrandpaAuthorities , types :: grandpa_authorities :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("GrandpaApi" , "grandpa_authorities" , types :: GrandpaAuthorities { } , [8u8 , 1u8 , 99u8 , 227u8 , 52u8 , 95u8 , 230u8 , 139u8 , 198u8 , 90u8 , 159u8 , 146u8 , 193u8 , 81u8 , 37u8 , 27u8 , 216u8 , 227u8 , 108u8 , 126u8 , 12u8 , 94u8 , 125u8 , 183u8 , 143u8 , 231u8 , 87u8 , 101u8 , 114u8 , 190u8 , 193u8 , 180u8 ,] ,) } # [doc = " Submits an unsigned extrinsic to report an equivocation. The caller"] # [doc = " must provide the equivocation proof and a key ownership proof"] # [doc = " (should be obtained using `generate_key_ownership_proof`). The"] # [doc = " extrinsic will be unsigned and should only be accepted for local"] # [doc = " authorship (not to be broadcast to the network). This method returns"] # [doc = " `None` when creation of the extrinsic fails, e.g. if equivocation"] # [doc = " reporting is disabled for the given runtime (i.e. this method is"] # [doc = " hardcoded to return `None`). Only useful in an offchain context."] pub fn submit_report_equivocation_unsigned_extrinsic (& self , equivocation_proof : types :: submit_report_equivocation_unsigned_extrinsic :: EquivocationProof , key_owner_proof : types :: submit_report_equivocation_unsigned_extrinsic :: KeyOwnerProof ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: SubmitReportEquivocationUnsignedExtrinsic , types :: submit_report_equivocation_unsigned_extrinsic :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("GrandpaApi" , "submit_report_equivocation_unsigned_extrinsic" , types :: SubmitReportEquivocationUnsignedExtrinsic { equivocation_proof , key_owner_proof , } , [27u8 , 32u8 , 16u8 , 79u8 , 172u8 , 124u8 , 44u8 , 13u8 , 176u8 , 89u8 , 69u8 , 60u8 , 45u8 , 176u8 , 72u8 , 151u8 , 252u8 , 5u8 , 243u8 , 82u8 , 170u8 , 51u8 , 179u8 , 197u8 , 117u8 , 177u8 , 110u8 , 111u8 , 97u8 , 15u8 , 109u8 , 169u8 ,] ,) } # [doc = " Generates a proof of key ownership for the given authority in the"] # [doc = " given set. An example usage of this module is coupled with the"] # [doc = " session historical module to prove that a given authority key is"] # [doc = " tied to a given staking identity during a specific session. Proofs"] # [doc = " of key ownership are necessary for submitting equivocation reports."] # [doc = " NOTE: even though the API takes a `set_id` as parameter the current"] # [doc = " implementations ignore this parameter and instead rely on this"] # [doc = " method being called at the correct block height, i.e. any point at"] # [doc = " which the given set id is live on-chain. Future implementations will"] # [doc = " instead use indexed data through an offchain worker, not requiring"] # [doc = " older states to be available."] pub fn generate_key_ownership_proof (& self , set_id : types :: generate_key_ownership_proof :: SetId , authority_id : types :: generate_key_ownership_proof :: AuthorityId ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: GenerateKeyOwnershipProof , types :: generate_key_ownership_proof :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("GrandpaApi" , "generate_key_ownership_proof" , types :: GenerateKeyOwnershipProof { set_id , authority_id , } , [13u8 , 144u8 , 66u8 , 235u8 , 24u8 , 190u8 , 39u8 , 75u8 , 29u8 , 157u8 , 215u8 , 181u8 , 173u8 , 145u8 , 224u8 , 244u8 , 189u8 , 79u8 , 6u8 , 116u8 , 139u8 , 196u8 , 54u8 , 16u8 , 89u8 , 190u8 , 121u8 , 43u8 , 137u8 , 150u8 , 117u8 , 68u8 ,] ,) } # [doc = " Get current GRANDPA authority set id."] pub fn current_set_id (& self ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: CurrentSetId , types :: current_set_id :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("GrandpaApi" , "current_set_id" , types :: CurrentSetId { } , [42u8 , 230u8 , 120u8 , 211u8 , 156u8 , 245u8 , 109u8 , 86u8 , 100u8 , 146u8 , 234u8 , 205u8 , 41u8 , 183u8 , 109u8 , 42u8 , 17u8 , 33u8 , 156u8 , 25u8 , 139u8 , 84u8 , 101u8 , 75u8 , 232u8 , 198u8 , 87u8 , 136u8 , 218u8 , 233u8 , 103u8 , 156u8 ,] ,) } } pub mod types { use super :: runtime_types ; pub mod grandpa_authorities { use super :: runtime_types ; pub mod output { use super :: runtime_types ; pub type Output = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < (runtime_types :: sp_consensus_grandpa :: app :: Public , :: core :: primitive :: u64 ,) > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct GrandpaAuthorities { } pub mod submit_report_equivocation_unsigned_extrinsic { use super :: runtime_types ; pub type EquivocationProof = runtime_types :: sp_consensus_grandpa :: EquivocationProof < :: subxt :: ext :: subxt_core :: utils :: H256 , :: core :: primitive :: u32 > ; pub type KeyOwnerProof = runtime_types :: sp_consensus_grandpa :: OpaqueKeyOwnershipProof ; pub mod output { use super :: runtime_types ; pub type Output = :: core :: option :: Option < () > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct SubmitReportEquivocationUnsignedExtrinsic { pub equivocation_proof : submit_report_equivocation_unsigned_extrinsic :: EquivocationProof , pub key_owner_proof : submit_report_equivocation_unsigned_extrinsic :: KeyOwnerProof , } pub mod generate_key_ownership_proof { use super :: runtime_types ; pub type SetId = :: core :: primitive :: u64 ; pub type AuthorityId = runtime_types :: sp_consensus_grandpa :: app :: Public ; pub mod output { use super :: runtime_types ; pub type Output = :: core :: option :: Option < runtime_types :: sp_consensus_grandpa :: OpaqueKeyOwnershipProof > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct GenerateKeyOwnershipProof { pub set_id : generate_key_ownership_proof :: SetId , pub authority_id : generate_key_ownership_proof :: AuthorityId , } pub mod current_set_id { use super :: runtime_types ; pub mod output { use super :: runtime_types ; pub type Output = :: core :: primitive :: u64 ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct CurrentSetId { } } } pub mod account_nonce_api { use super :: root_mod ; use super :: runtime_types ; # [doc = " The API to query account nonce."] pub struct AccountNonceApi ; impl AccountNonceApi { # [doc = " Get current account nonce of given `AccountId`."] pub fn account_nonce (& self , account : types :: account_nonce :: Account ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: AccountNonce , types :: account_nonce :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("AccountNonceApi" , "account_nonce" , types :: AccountNonce { account , } , [231u8 , 82u8 , 7u8 , 227u8 , 131u8 , 2u8 , 215u8 , 252u8 , 173u8 , 82u8 , 11u8 , 103u8 , 200u8 , 25u8 , 114u8 , 116u8 , 79u8 , 229u8 , 152u8 , 150u8 , 236u8 , 37u8 , 101u8 , 26u8 , 220u8 , 146u8 , 182u8 , 101u8 , 73u8 , 55u8 , 191u8 , 171u8 ,] ,) } } pub mod types { use super :: runtime_types ; pub mod account_nonce { use super :: runtime_types ; pub type Account = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub mod output { use super :: runtime_types ; pub type Output = :: core :: primitive :: u32 ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct AccountNonce { pub account : account_nonce :: Account , } } } pub mod transaction_payment_api { use super :: root_mod ; use super :: runtime_types ; pub struct TransactionPaymentApi ; impl TransactionPaymentApi { pub fn query_info (& self , uxt : types :: query_info :: Uxt , len : types :: query_info :: Len ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: QueryInfo , types :: query_info :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("TransactionPaymentApi" , "query_info" , types :: QueryInfo { uxt , len , } , [24u8 , 42u8 , 137u8 , 188u8 , 70u8 , 224u8 , 145u8 , 166u8 , 22u8 , 122u8 , 72u8 , 73u8 , 139u8 , 92u8 , 235u8 , 144u8 , 95u8 , 193u8 , 39u8 , 238u8 , 220u8 , 222u8 , 144u8 , 83u8 , 226u8 , 13u8 , 83u8 , 120u8 , 142u8 , 111u8 , 231u8 , 69u8 ,] ,) } pub fn query_fee_details (& self , uxt : types :: query_fee_details :: Uxt , len : types :: query_fee_details :: Len ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: QueryFeeDetails , types :: query_fee_details :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("TransactionPaymentApi" , "query_fee_details" , types :: QueryFeeDetails { uxt , len , } , [182u8 , 198u8 , 165u8 , 34u8 , 109u8 , 68u8 , 119u8 , 118u8 , 116u8 , 240u8 , 160u8 , 4u8 , 1u8 , 14u8 , 169u8 , 207u8 , 142u8 , 193u8 , 16u8 , 89u8 , 179u8 , 215u8 , 246u8 , 166u8 , 194u8 , 49u8 , 110u8 , 19u8 , 144u8 , 241u8 , 161u8 , 190u8 ,] ,) } pub fn query_weight_to_fee (& self , weight : types :: query_weight_to_fee :: Weight ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: QueryWeightToFee , types :: query_weight_to_fee :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("TransactionPaymentApi" , "query_weight_to_fee" , types :: QueryWeightToFee { weight , } , [43u8 , 38u8 , 7u8 , 127u8 , 93u8 , 202u8 , 221u8 , 100u8 , 79u8 , 26u8 , 61u8 , 51u8 , 106u8 , 250u8 , 233u8 , 161u8 , 32u8 , 72u8 , 198u8 , 28u8 , 94u8 , 150u8 , 8u8 , 143u8 , 58u8 , 148u8 , 69u8 , 198u8 , 215u8 , 27u8 , 186u8 , 242u8 ,] ,) } pub fn query_length_to_fee (& self , length : types :: query_length_to_fee :: Length ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: QueryLengthToFee , types :: query_length_to_fee :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("TransactionPaymentApi" , "query_length_to_fee" , types :: QueryLengthToFee { length , } , [129u8 , 136u8 , 216u8 , 144u8 , 66u8 , 102u8 , 146u8 , 169u8 , 202u8 , 11u8 , 0u8 , 146u8 , 200u8 , 172u8 , 84u8 , 238u8 , 129u8 , 32u8 , 214u8 , 169u8 , 130u8 , 111u8 , 112u8 , 68u8 , 51u8 , 8u8 , 174u8 , 90u8 , 81u8 , 46u8 , 0u8 , 249u8 ,] ,) } } pub mod types { use super :: runtime_types ; pub mod query_info { use super :: runtime_types ; pub type Uxt = :: subxt :: ext :: subxt_core :: utils :: UncheckedExtrinsic < :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > , runtime_types :: node_subtensor_runtime :: RuntimeCall , runtime_types :: sp_runtime :: MultiSignature , (runtime_types :: frame_system :: extensions :: check_non_zero_sender :: CheckNonZeroSender , runtime_types :: frame_system :: extensions :: check_spec_version :: CheckSpecVersion , runtime_types :: frame_system :: extensions :: check_tx_version :: CheckTxVersion , runtime_types :: frame_system :: extensions :: check_genesis :: CheckGenesis , runtime_types :: frame_system :: extensions :: check_mortality :: CheckMortality , runtime_types :: node_subtensor_runtime :: check_nonce :: CheckNonce , runtime_types :: frame_system :: extensions :: check_weight :: CheckWeight , runtime_types :: pallet_transaction_payment :: ChargeTransactionPayment , runtime_types :: pallet_subtensor :: SubtensorSignedExtension < runtime_types :: node_subtensor_runtime :: Runtime > , runtime_types :: pallet_commitments :: CommitmentsSignedExtension < runtime_types :: node_subtensor_runtime :: Runtime > , runtime_types :: frame_metadata_hash_extension :: CheckMetadataHash ,) > ; pub type Len = :: core :: primitive :: u32 ; pub mod output { use super :: runtime_types ; pub type Output = runtime_types :: pallet_transaction_payment :: types :: RuntimeDispatchInfo < :: core :: primitive :: u64 , runtime_types :: sp_weights :: weight_v2 :: Weight > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct QueryInfo { pub uxt : query_info :: Uxt , pub len : query_info :: Len , } pub mod query_fee_details { use super :: runtime_types ; pub type Uxt = :: subxt :: ext :: subxt_core :: utils :: UncheckedExtrinsic < :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > , runtime_types :: node_subtensor_runtime :: RuntimeCall , runtime_types :: sp_runtime :: MultiSignature , (runtime_types :: frame_system :: extensions :: check_non_zero_sender :: CheckNonZeroSender , runtime_types :: frame_system :: extensions :: check_spec_version :: CheckSpecVersion , runtime_types :: frame_system :: extensions :: check_tx_version :: CheckTxVersion , runtime_types :: frame_system :: extensions :: check_genesis :: CheckGenesis , runtime_types :: frame_system :: extensions :: check_mortality :: CheckMortality , runtime_types :: node_subtensor_runtime :: check_nonce :: CheckNonce , runtime_types :: frame_system :: extensions :: check_weight :: CheckWeight , runtime_types :: pallet_transaction_payment :: ChargeTransactionPayment , runtime_types :: pallet_subtensor :: SubtensorSignedExtension < runtime_types :: node_subtensor_runtime :: Runtime > , runtime_types :: pallet_commitments :: CommitmentsSignedExtension < runtime_types :: node_subtensor_runtime :: Runtime > , runtime_types :: frame_metadata_hash_extension :: CheckMetadataHash ,) > ; pub type Len = :: core :: primitive :: u32 ; pub mod output { use super :: runtime_types ; pub type Output = runtime_types :: pallet_transaction_payment :: types :: FeeDetails < :: core :: primitive :: u64 > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct QueryFeeDetails { pub uxt : query_fee_details :: Uxt , pub len : query_fee_details :: Len , } pub mod query_weight_to_fee { use super :: runtime_types ; pub type Weight = runtime_types :: sp_weights :: weight_v2 :: Weight ; pub mod output { use super :: runtime_types ; pub type Output = :: core :: primitive :: u64 ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct QueryWeightToFee { pub weight : query_weight_to_fee :: Weight , } pub mod query_length_to_fee { use super :: runtime_types ; pub type Length = :: core :: primitive :: u32 ; pub mod output { use super :: runtime_types ; pub type Output = :: core :: primitive :: u64 ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct QueryLengthToFee { pub length : query_length_to_fee :: Length , } } } pub mod transaction_payment_call_api { use super :: root_mod ; use super :: runtime_types ; pub struct TransactionPaymentCallApi ; impl TransactionPaymentCallApi { # [doc = " Query information of a dispatch class, weight, and fee of a given encoded `Call`."] pub fn query_call_info (& self , call : types :: query_call_info :: Call , len : types :: query_call_info :: Len ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: QueryCallInfo , types :: query_call_info :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("TransactionPaymentCallApi" , "query_call_info" , types :: QueryCallInfo { call , len , } , [154u8 , 168u8 , 89u8 , 204u8 , 221u8 , 246u8 , 152u8 , 122u8 , 129u8 , 86u8 , 196u8 , 172u8 , 183u8 , 157u8 , 80u8 , 17u8 , 55u8 , 11u8 , 194u8 , 210u8 , 185u8 , 68u8 , 191u8 , 201u8 , 120u8 , 22u8 , 202u8 , 98u8 , 41u8 , 174u8 , 45u8 , 1u8 ,] ,) } # [doc = " Query fee details of a given encoded `Call`."] pub fn query_call_fee_details (& self , call : types :: query_call_fee_details :: Call , len : types :: query_call_fee_details :: Len ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: QueryCallFeeDetails , types :: query_call_fee_details :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("TransactionPaymentCallApi" , "query_call_fee_details" , types :: QueryCallFeeDetails { call , len , } , [109u8 , 132u8 , 78u8 , 236u8 , 174u8 , 214u8 , 142u8 , 199u8 , 60u8 , 218u8 , 254u8 , 54u8 , 67u8 , 184u8 , 29u8 , 92u8 , 120u8 , 130u8 , 8u8 , 184u8 , 185u8 , 238u8 , 227u8 , 139u8 , 60u8 , 99u8 , 1u8 , 190u8 , 74u8 , 106u8 , 25u8 , 65u8 ,] ,) } # [doc = " Query the output of the current `WeightToFee` given some input."] pub fn query_weight_to_fee (& self , weight : types :: query_weight_to_fee :: Weight ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: QueryWeightToFee , types :: query_weight_to_fee :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("TransactionPaymentCallApi" , "query_weight_to_fee" , types :: QueryWeightToFee { weight , } , [154u8 , 155u8 , 82u8 , 35u8 , 212u8 , 163u8 , 97u8 , 198u8 , 2u8 , 206u8 , 243u8 , 23u8 , 100u8 , 233u8 , 202u8 , 247u8 , 176u8 , 177u8 , 138u8 , 135u8 , 164u8 , 220u8 , 9u8 , 182u8 , 226u8 , 22u8 , 29u8 , 173u8 , 234u8 , 18u8 , 230u8 , 184u8 ,] ,) } # [doc = " Query the output of the current `LengthToFee` given some input."] pub fn query_length_to_fee (& self , length : types :: query_length_to_fee :: Length ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: QueryLengthToFee , types :: query_length_to_fee :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("TransactionPaymentCallApi" , "query_length_to_fee" , types :: QueryLengthToFee { length , } , [81u8 , 163u8 , 41u8 , 53u8 , 39u8 , 220u8 , 142u8 , 196u8 , 240u8 , 62u8 , 204u8 , 3u8 , 172u8 , 25u8 , 99u8 , 48u8 , 143u8 , 115u8 , 9u8 , 151u8 , 167u8 , 209u8 , 207u8 , 224u8 , 50u8 , 232u8 , 73u8 , 176u8 , 130u8 , 80u8 , 185u8 , 105u8 ,] ,) } } pub mod types { use super :: runtime_types ; pub mod query_call_info { use super :: runtime_types ; pub type Call = runtime_types :: node_subtensor_runtime :: RuntimeCall ; pub type Len = :: core :: primitive :: u32 ; pub mod output { use super :: runtime_types ; pub type Output = runtime_types :: pallet_transaction_payment :: types :: RuntimeDispatchInfo < :: core :: primitive :: u64 , runtime_types :: sp_weights :: weight_v2 :: Weight > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct QueryCallInfo { pub call : query_call_info :: Call , pub len : query_call_info :: Len , } pub mod query_call_fee_details { use super :: runtime_types ; pub type Call = runtime_types :: node_subtensor_runtime :: RuntimeCall ; pub type Len = :: core :: primitive :: u32 ; pub mod output { use super :: runtime_types ; pub type Output = runtime_types :: pallet_transaction_payment :: types :: FeeDetails < :: core :: primitive :: u64 > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct QueryCallFeeDetails { pub call : query_call_fee_details :: Call , pub len : query_call_fee_details :: Len , } pub mod query_weight_to_fee { use super :: runtime_types ; pub type Weight = runtime_types :: sp_weights :: weight_v2 :: Weight ; pub mod output { use super :: runtime_types ; pub type Output = :: core :: primitive :: u64 ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct QueryWeightToFee { pub weight : query_weight_to_fee :: Weight , } pub mod query_length_to_fee { use super :: runtime_types ; pub type Length = :: core :: primitive :: u32 ; pub mod output { use super :: runtime_types ; pub type Output = :: core :: primitive :: u64 ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct QueryLengthToFee { pub length : query_length_to_fee :: Length , } } } pub mod delegate_info_runtime_api { use super :: root_mod ; use super :: runtime_types ; pub struct DelegateInfoRuntimeApi ; impl DelegateInfoRuntimeApi { pub fn get_delegates (& self ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: GetDelegates , types :: get_delegates :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("DelegateInfoRuntimeApi" , "get_delegates" , types :: GetDelegates { } , [128u8 , 243u8 , 168u8 , 36u8 , 82u8 , 103u8 , 93u8 , 100u8 , 7u8 , 176u8 , 11u8 , 250u8 , 172u8 , 116u8 , 144u8 , 104u8 , 109u8 , 189u8 , 171u8 , 166u8 , 230u8 , 240u8 , 238u8 , 181u8 , 54u8 , 28u8 , 61u8 , 210u8 , 239u8 , 182u8 , 96u8 , 76u8 ,] ,) } pub fn get_delegate (& self , delegate_account_vec : types :: get_delegate :: DelegateAccountVec ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: GetDelegate , types :: get_delegate :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("DelegateInfoRuntimeApi" , "get_delegate" , types :: GetDelegate { delegate_account_vec , } , [153u8 , 63u8 , 216u8 , 87u8 , 60u8 , 90u8 , 115u8 , 28u8 , 110u8 , 43u8 , 78u8 , 126u8 , 243u8 , 145u8 , 95u8 , 65u8 , 250u8 , 211u8 , 24u8 , 17u8 , 168u8 , 68u8 , 74u8 , 179u8 , 5u8 , 68u8 , 65u8 , 247u8 , 9u8 , 232u8 , 48u8 , 186u8 ,] ,) } pub fn get_delegated (& self , delegatee_account_vec : types :: get_delegated :: DelegateeAccountVec ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: GetDelegated , types :: get_delegated :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("DelegateInfoRuntimeApi" , "get_delegated" , types :: GetDelegated { delegatee_account_vec , } , [10u8 , 124u8 , 123u8 , 81u8 , 2u8 , 18u8 , 84u8 , 69u8 , 253u8 , 194u8 , 69u8 , 1u8 , 210u8 , 92u8 , 30u8 , 108u8 , 233u8 , 46u8 , 78u8 , 126u8 , 67u8 , 38u8 , 8u8 , 55u8 , 227u8 , 76u8 , 234u8 , 212u8 , 7u8 , 11u8 , 210u8 , 82u8 ,] ,) } } pub mod types { use super :: runtime_types ; pub mod get_delegates { use super :: runtime_types ; pub mod output { use super :: runtime_types ; pub type Output = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct GetDelegates { } pub mod get_delegate { use super :: runtime_types ; pub type DelegateAccountVec = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ; pub mod output { use super :: runtime_types ; pub type Output = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct GetDelegate { pub delegate_account_vec : get_delegate :: DelegateAccountVec , } pub mod get_delegated { use super :: runtime_types ; pub type DelegateeAccountVec = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ; pub mod output { use super :: runtime_types ; pub type Output = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct GetDelegated { pub delegatee_account_vec : get_delegated :: DelegateeAccountVec , } } } pub mod neuron_info_runtime_api { use super :: root_mod ; use super :: runtime_types ; pub struct NeuronInfoRuntimeApi ; impl NeuronInfoRuntimeApi { pub fn get_neurons (& self , netuid : types :: get_neurons :: Netuid ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: GetNeurons , types :: get_neurons :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("NeuronInfoRuntimeApi" , "get_neurons" , types :: GetNeurons { netuid , } , [51u8 , 205u8 , 104u8 , 216u8 , 216u8 , 18u8 , 39u8 , 250u8 , 145u8 , 117u8 , 139u8 , 116u8 , 112u8 , 79u8 , 20u8 , 236u8 , 6u8 , 99u8 , 78u8 , 193u8 , 204u8 , 172u8 , 116u8 , 57u8 , 116u8 , 142u8 , 226u8 , 229u8 , 127u8 , 76u8 , 1u8 , 227u8 ,] ,) } pub fn get_neuron (& self , netuid : types :: get_neuron :: Netuid , uid : types :: get_neuron :: Uid ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: GetNeuron , types :: get_neuron :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("NeuronInfoRuntimeApi" , "get_neuron" , types :: GetNeuron { netuid , uid , } , [43u8 , 245u8 , 54u8 , 155u8 , 92u8 , 159u8 , 2u8 , 231u8 , 215u8 , 147u8 , 220u8 , 25u8 , 7u8 , 110u8 , 95u8 , 243u8 , 137u8 , 196u8 , 237u8 , 9u8 , 177u8 , 132u8 , 194u8 , 99u8 , 113u8 , 43u8 , 143u8 , 3u8 , 48u8 , 33u8 , 32u8 , 174u8 ,] ,) } pub fn get_neurons_lite (& self , netuid : types :: get_neurons_lite :: Netuid ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: GetNeuronsLite , types :: get_neurons_lite :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("NeuronInfoRuntimeApi" , "get_neurons_lite" , types :: GetNeuronsLite { netuid , } , [28u8 , 18u8 , 207u8 , 98u8 , 200u8 , 233u8 , 168u8 , 231u8 , 203u8 , 192u8 , 30u8 , 167u8 , 108u8 , 91u8 , 13u8 , 144u8 , 217u8 , 29u8 , 161u8 , 182u8 , 92u8 , 36u8 , 101u8 , 34u8 , 206u8 , 135u8 , 103u8 , 149u8 , 90u8 , 230u8 , 233u8 , 137u8 ,] ,) } pub fn get_neuron_lite (& self , netuid : types :: get_neuron_lite :: Netuid , uid : types :: get_neuron_lite :: Uid ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: GetNeuronLite , types :: get_neuron_lite :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("NeuronInfoRuntimeApi" , "get_neuron_lite" , types :: GetNeuronLite { netuid , uid , } , [116u8 , 60u8 , 251u8 , 31u8 , 69u8 , 112u8 , 27u8 , 168u8 , 218u8 , 161u8 , 151u8 , 35u8 , 177u8 , 210u8 , 71u8 , 116u8 , 202u8 , 215u8 , 239u8 , 80u8 , 111u8 , 55u8 , 24u8 , 204u8 , 50u8 , 94u8 , 237u8 , 88u8 , 239u8 , 84u8 , 5u8 , 152u8 ,] ,) } } pub mod types { use super :: runtime_types ; pub mod get_neurons { use super :: runtime_types ; pub type Netuid = :: core :: primitive :: u16 ; pub mod output { use super :: runtime_types ; pub type Output = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct GetNeurons { pub netuid : get_neurons :: Netuid , } pub mod get_neuron { use super :: runtime_types ; pub type Netuid = :: core :: primitive :: u16 ; pub type Uid = :: core :: primitive :: u16 ; pub mod output { use super :: runtime_types ; pub type Output = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct GetNeuron { pub netuid : get_neuron :: Netuid , pub uid : get_neuron :: Uid , } pub mod get_neurons_lite { use super :: runtime_types ; pub type Netuid = :: core :: primitive :: u16 ; pub mod output { use super :: runtime_types ; pub type Output = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct GetNeuronsLite { pub netuid : get_neurons_lite :: Netuid , } pub mod get_neuron_lite { use super :: runtime_types ; pub type Netuid = :: core :: primitive :: u16 ; pub type Uid = :: core :: primitive :: u16 ; pub mod output { use super :: runtime_types ; pub type Output = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct GetNeuronLite { pub netuid : get_neuron_lite :: Netuid , pub uid : get_neuron_lite :: Uid , } } } pub mod subnet_info_runtime_api { use super :: root_mod ; use super :: runtime_types ; pub struct SubnetInfoRuntimeApi ; impl SubnetInfoRuntimeApi { pub fn get_subnet_info (& self , netuid : types :: get_subnet_info :: Netuid ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: GetSubnetInfo , types :: get_subnet_info :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("SubnetInfoRuntimeApi" , "get_subnet_info" , types :: GetSubnetInfo { netuid , } , [0u8 , 109u8 , 163u8 , 64u8 , 3u8 , 117u8 , 246u8 , 104u8 , 17u8 , 172u8 , 224u8 , 167u8 , 81u8 , 24u8 , 43u8 , 19u8 , 205u8 , 159u8 , 1u8 , 64u8 , 242u8 , 176u8 , 75u8 , 101u8 , 167u8 , 78u8 , 160u8 , 173u8 , 74u8 , 229u8 , 222u8 , 91u8 ,] ,) } pub fn get_subnets_info (& self ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: GetSubnetsInfo , types :: get_subnets_info :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("SubnetInfoRuntimeApi" , "get_subnets_info" , types :: GetSubnetsInfo { } , [29u8 , 243u8 , 17u8 , 28u8 , 34u8 , 93u8 , 33u8 , 230u8 , 172u8 , 107u8 , 194u8 , 168u8 , 51u8 , 149u8 , 102u8 , 58u8 , 52u8 , 22u8 , 60u8 , 99u8 , 9u8 , 250u8 , 177u8 , 228u8 , 172u8 , 44u8 , 128u8 , 205u8 , 129u8 , 172u8 , 108u8 , 206u8 ,] ,) } pub fn get_subnet_info_v2 (& self , netuid : types :: get_subnet_info_v2 :: Netuid ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: GetSubnetInfoV2 , types :: get_subnet_info_v2 :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("SubnetInfoRuntimeApi" , "get_subnet_info_v2" , types :: GetSubnetInfoV2 { netuid , } , [182u8 , 14u8 , 11u8 , 73u8 , 238u8 , 229u8 , 140u8 , 106u8 , 178u8 , 55u8 , 230u8 , 188u8 , 52u8 , 129u8 , 28u8 , 101u8 , 86u8 , 28u8 , 210u8 , 98u8 , 197u8 , 187u8 , 67u8 , 206u8 , 34u8 , 201u8 , 140u8 , 39u8 , 86u8 , 175u8 , 62u8 , 187u8 ,] ,) } pub fn get_subnets_info_v2 (& self ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: GetSubnetsInfoV2 , types :: get_subnets_info_v2 :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("SubnetInfoRuntimeApi" , "get_subnets_info_v2" , types :: GetSubnetsInfoV2 { } , [63u8 , 237u8 , 174u8 , 176u8 , 200u8 , 227u8 , 208u8 , 73u8 , 107u8 , 91u8 , 193u8 , 183u8 , 94u8 , 46u8 , 11u8 , 121u8 , 27u8 , 206u8 , 215u8 , 241u8 , 191u8 , 70u8 , 189u8 , 14u8 , 52u8 , 57u8 , 218u8 , 44u8 , 31u8 , 242u8 , 23u8 , 103u8 ,] ,) } pub fn get_subnet_hyperparams (& self , netuid : types :: get_subnet_hyperparams :: Netuid ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: GetSubnetHyperparams , types :: get_subnet_hyperparams :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("SubnetInfoRuntimeApi" , "get_subnet_hyperparams" , types :: GetSubnetHyperparams { netuid , } , [181u8 , 237u8 , 165u8 , 76u8 , 22u8 , 51u8 , 219u8 , 225u8 , 254u8 , 23u8 , 255u8 , 152u8 , 237u8 , 108u8 , 140u8 , 88u8 , 75u8 , 28u8 , 100u8 , 98u8 , 110u8 , 79u8 , 155u8 , 208u8 , 136u8 , 37u8 , 152u8 , 211u8 , 184u8 , 20u8 , 182u8 , 75u8 ,] ,) } } pub mod types { use super :: runtime_types ; pub mod get_subnet_info { use super :: runtime_types ; pub type Netuid = :: core :: primitive :: u16 ; pub mod output { use super :: runtime_types ; pub type Output = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct GetSubnetInfo { pub netuid : get_subnet_info :: Netuid , } pub mod get_subnets_info { use super :: runtime_types ; pub mod output { use super :: runtime_types ; pub type Output = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct GetSubnetsInfo { } pub mod get_subnet_info_v2 { use super :: runtime_types ; pub type Netuid = :: core :: primitive :: u16 ; pub mod output { use super :: runtime_types ; pub type Output = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct GetSubnetInfoV2 { pub netuid : get_subnet_info_v2 :: Netuid , } pub mod get_subnets_info_v2 { use super :: runtime_types ; pub mod output { use super :: runtime_types ; pub type Output = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct GetSubnetsInfoV2 { } pub mod get_subnet_hyperparams { use super :: runtime_types ; pub type Netuid = :: core :: primitive :: u16 ; pub mod output { use super :: runtime_types ; pub type Output = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct GetSubnetHyperparams { pub netuid : get_subnet_hyperparams :: Netuid , } } } pub mod stake_info_runtime_api { use super :: root_mod ; use super :: runtime_types ; pub struct StakeInfoRuntimeApi ; impl StakeInfoRuntimeApi { pub fn get_stake_info_for_coldkey (& self , coldkey_account_vec : types :: get_stake_info_for_coldkey :: ColdkeyAccountVec ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: GetStakeInfoForColdkey , types :: get_stake_info_for_coldkey :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("StakeInfoRuntimeApi" , "get_stake_info_for_coldkey" , types :: GetStakeInfoForColdkey { coldkey_account_vec , } , [105u8 , 112u8 , 151u8 , 181u8 , 230u8 , 115u8 , 34u8 , 127u8 , 105u8 , 59u8 , 126u8 , 42u8 , 147u8 , 52u8 , 240u8 , 97u8 , 10u8 , 97u8 , 43u8 , 29u8 , 250u8 , 75u8 , 116u8 , 89u8 , 232u8 , 65u8 , 121u8 , 241u8 , 70u8 , 127u8 , 112u8 , 48u8 ,] ,) } pub fn get_stake_info_for_coldkeys (& self , coldkey_account_vecs : types :: get_stake_info_for_coldkeys :: ColdkeyAccountVecs ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: GetStakeInfoForColdkeys , types :: get_stake_info_for_coldkeys :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("StakeInfoRuntimeApi" , "get_stake_info_for_coldkeys" , types :: GetStakeInfoForColdkeys { coldkey_account_vecs , } , [204u8 , 254u8 , 225u8 , 56u8 , 192u8 , 254u8 , 87u8 , 222u8 , 234u8 , 106u8 , 214u8 , 92u8 , 237u8 , 93u8 , 124u8 , 118u8 , 50u8 , 127u8 , 211u8 , 106u8 , 32u8 , 198u8 , 25u8 , 157u8 , 216u8 , 3u8 , 209u8 , 34u8 , 229u8 , 236u8 , 98u8 , 123u8 ,] ,) } } pub mod types { use super :: runtime_types ; pub mod get_stake_info_for_coldkey { use super :: runtime_types ; pub type ColdkeyAccountVec = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ; pub mod output { use super :: runtime_types ; pub type Output = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct GetStakeInfoForColdkey { pub coldkey_account_vec : get_stake_info_for_coldkey :: ColdkeyAccountVec , } pub mod get_stake_info_for_coldkeys { use super :: runtime_types ; pub type ColdkeyAccountVecs = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > > ; pub mod output { use super :: runtime_types ; pub type Output = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct GetStakeInfoForColdkeys { pub coldkey_account_vecs : get_stake_info_for_coldkeys :: ColdkeyAccountVecs , } } } pub mod subnet_registration_runtime_api { use super :: root_mod ; use super :: runtime_types ; pub struct SubnetRegistrationRuntimeApi ; impl SubnetRegistrationRuntimeApi { pub fn get_network_registration_cost (& self ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: GetNetworkRegistrationCost , types :: get_network_registration_cost :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("SubnetRegistrationRuntimeApi" , "get_network_registration_cost" , types :: GetNetworkRegistrationCost { } , [152u8 , 137u8 , 58u8 , 141u8 , 204u8 , 239u8 , 63u8 , 8u8 , 76u8 , 223u8 , 54u8 , 219u8 , 150u8 , 155u8 , 129u8 , 130u8 , 64u8 , 40u8 , 177u8 , 153u8 , 29u8 , 1u8 , 234u8 , 30u8 , 20u8 , 218u8 , 17u8 , 254u8 , 18u8 , 135u8 , 133u8 , 25u8 ,] ,) } } pub mod types { use super :: runtime_types ; pub mod get_network_registration_cost { use super :: runtime_types ; pub mod output { use super :: runtime_types ; pub type Output = :: core :: primitive :: u64 ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct GetNetworkRegistrationCost { } } } } pub fn custom () -> CustomValuesApi { CustomValuesApi } pub struct CustomValuesApi ; impl CustomValuesApi { } pub struct ConstantsApi ; impl ConstantsApi { pub fn system (& self) -> system :: constants :: ConstantsApi { system :: constants :: ConstantsApi } pub fn timestamp (& self) -> timestamp :: constants :: ConstantsApi { timestamp :: constants :: ConstantsApi } pub fn aura (& self) -> aura :: constants :: ConstantsApi { aura :: constants :: ConstantsApi } pub fn grandpa (& self) -> grandpa :: constants :: ConstantsApi { grandpa :: constants :: ConstantsApi } pub fn balances (& self) -> balances :: constants :: ConstantsApi { balances :: constants :: ConstantsApi } pub fn transaction_payment (& self) -> transaction_payment :: constants :: ConstantsApi { transaction_payment :: constants :: ConstantsApi } pub fn subtensor_module (& self) -> subtensor_module :: constants :: ConstantsApi { subtensor_module :: constants :: ConstantsApi } pub fn utility (& self) -> utility :: constants :: ConstantsApi { utility :: constants :: ConstantsApi } pub fn multisig (& self) -> multisig :: constants :: ConstantsApi { multisig :: constants :: ConstantsApi } pub fn scheduler (& self) -> scheduler :: constants :: ConstantsApi { scheduler :: constants :: ConstantsApi } pub fn proxy (& self) -> proxy :: constants :: ConstantsApi { proxy :: constants :: ConstantsApi } pub fn registry (& self) -> registry :: constants :: ConstantsApi { registry :: constants :: ConstantsApi } pub fn commitments (& self) -> commitments :: constants :: ConstantsApi { commitments :: constants :: ConstantsApi } pub fn safe_mode (& self) -> safe_mode :: constants :: ConstantsApi { safe_mode :: constants :: ConstantsApi } } pub struct StorageApi ; impl StorageApi { pub fn system (& self) -> system :: storage :: StorageApi { system :: storage :: StorageApi } pub fn randomness_collective_flip (& self) -> randomness_collective_flip :: storage :: StorageApi { randomness_collective_flip :: storage :: StorageApi } pub fn timestamp (& self) -> timestamp :: storage :: StorageApi { timestamp :: storage :: StorageApi } pub fn aura (& self) -> aura :: storage :: StorageApi { aura :: storage :: StorageApi } pub fn grandpa (& self) -> grandpa :: storage :: StorageApi { grandpa :: storage :: StorageApi } pub fn balances (& self) -> balances :: storage :: StorageApi { balances :: storage :: StorageApi } pub fn transaction_payment (& self) -> transaction_payment :: storage :: StorageApi { transaction_payment :: storage :: StorageApi } pub fn subtensor_module (& self) -> subtensor_module :: storage :: StorageApi { subtensor_module :: storage :: StorageApi } pub fn triumvirate (& self) -> triumvirate :: storage :: StorageApi { triumvirate :: storage :: StorageApi } pub fn triumvirate_members (& self) -> triumvirate_members :: storage :: StorageApi { triumvirate_members :: storage :: StorageApi } pub fn senate_members (& self) -> senate_members :: storage :: StorageApi { senate_members :: storage :: StorageApi } pub fn sudo (& self) -> sudo :: storage :: StorageApi { sudo :: storage :: StorageApi } pub fn multisig (& self) -> multisig :: storage :: StorageApi { multisig :: storage :: StorageApi } pub fn preimage (& self) -> preimage :: storage :: StorageApi { preimage :: storage :: StorageApi } pub fn scheduler (& self) -> scheduler :: storage :: StorageApi { scheduler :: storage :: StorageApi } pub fn proxy (& self) -> proxy :: storage :: StorageApi { proxy :: storage :: StorageApi } pub fn registry (& self) -> registry :: storage :: StorageApi { registry :: storage :: StorageApi } pub fn commitments (& self) -> commitments :: storage :: StorageApi { commitments :: storage :: StorageApi } pub fn safe_mode (& self) -> safe_mode :: storage :: StorageApi { safe_mode :: storage :: StorageApi } } pub struct TransactionApi ; impl TransactionApi { pub fn system (& self) -> system :: calls :: TransactionApi { system :: calls :: TransactionApi } pub fn timestamp (& self) -> timestamp :: calls :: TransactionApi { timestamp :: calls :: TransactionApi } pub fn grandpa (& self) -> grandpa :: calls :: TransactionApi { grandpa :: calls :: TransactionApi } pub fn balances (& self) -> balances :: calls :: TransactionApi { balances :: calls :: TransactionApi } pub fn subtensor_module (& self) -> subtensor_module :: calls :: TransactionApi { subtensor_module :: calls :: TransactionApi } pub fn triumvirate (& self) -> triumvirate :: calls :: TransactionApi { triumvirate :: calls :: TransactionApi } pub fn triumvirate_members (& self) -> triumvirate_members :: calls :: TransactionApi { triumvirate_members :: calls :: TransactionApi } pub fn senate_members (& self) -> senate_members :: calls :: TransactionApi { senate_members :: calls :: TransactionApi } pub fn utility (& self) -> utility :: calls :: TransactionApi { utility :: calls :: TransactionApi } pub fn sudo (& self) -> sudo :: calls :: TransactionApi { sudo :: calls :: TransactionApi } pub fn multisig (& self) -> multisig :: calls :: TransactionApi { multisig :: calls :: TransactionApi } pub fn preimage (& self) -> preimage :: calls :: TransactionApi { preimage :: calls :: TransactionApi } pub fn scheduler (& self) -> scheduler :: calls :: TransactionApi { scheduler :: calls :: TransactionApi } pub fn proxy (& self) -> proxy :: calls :: TransactionApi { proxy :: calls :: TransactionApi } pub fn registry (& self) -> registry :: calls :: TransactionApi { registry :: calls :: TransactionApi } pub fn commitments (& self) -> commitments :: calls :: TransactionApi { commitments :: calls :: TransactionApi } pub fn admin_utils (& self) -> admin_utils :: calls :: TransactionApi { admin_utils :: calls :: TransactionApi } pub fn safe_mode (& self) -> safe_mode :: calls :: TransactionApi { safe_mode :: calls :: TransactionApi } } # [doc = r" check whether the metadata provided is aligned with this statically generated code."] pub fn is_codegen_valid_for (metadata : & :: subxt :: ext :: subxt_core :: Metadata) -> bool { let runtime_metadata_hash = metadata . hasher () . only_these_pallets (& PALLETS) . only_these_runtime_apis (& RUNTIME_APIS) . hash () ; runtime_metadata_hash == [220u8 , 61u8 , 140u8 , 57u8 , 165u8 , 154u8 , 179u8 , 25u8 , 184u8 , 191u8 , 20u8 , 2u8 , 240u8 , 239u8 , 146u8 , 21u8 , 205u8 , 141u8 , 115u8 , 201u8 , 127u8 , 244u8 , 176u8 , 190u8 , 243u8 , 43u8 , 112u8 , 74u8 , 133u8 , 27u8 , 235u8 , 103u8 ,] } pub mod system { use super :: root_mod ; use super :: runtime_types ; # [doc = "Error for the System pallet"] pub type Error = runtime_types :: frame_system :: pallet :: Error ; # [doc = "Contains a variant per dispatchable extrinsic that this pallet has."] pub type Call = runtime_types :: frame_system :: pallet :: Call ; pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; pub mod types { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Make some on-chain remark."] # [doc = ""] # [doc = "Can be executed by every `origin`."] pub struct Remark { pub remark : remark :: Remark , } pub mod remark { use super :: runtime_types ; pub type Remark = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for Remark { const PALLET : & 'static str = "System" ; const CALL : & 'static str = "remark" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Set the number of pages in the WebAssembly environment's heap."] pub struct SetHeapPages { pub pages : set_heap_pages :: Pages , } pub mod set_heap_pages { use super :: runtime_types ; pub type Pages = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SetHeapPages { const PALLET : & 'static str = "System" ; const CALL : & 'static str = "set_heap_pages" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Set the new runtime code."] pub struct SetCode { pub code : set_code :: Code , } pub mod set_code { use super :: runtime_types ; pub type Code = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SetCode { const PALLET : & 'static str = "System" ; const CALL : & 'static str = "set_code" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Set the new runtime code without doing any checks of the given `code`."] # [doc = ""] # [doc = "Note that runtime upgrades will not run if this is called with a not-increasing spec"] # [doc = "version!"] pub struct SetCodeWithoutChecks { pub code : set_code_without_checks :: Code , } pub mod set_code_without_checks { use super :: runtime_types ; pub type Code = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SetCodeWithoutChecks { const PALLET : & 'static str = "System" ; const CALL : & 'static str = "set_code_without_checks" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Set some items of storage."] pub struct SetStorage { pub items : set_storage :: Items , } pub mod set_storage { use super :: runtime_types ; pub type Items = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < (:: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > , :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ,) > ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SetStorage { const PALLET : & 'static str = "System" ; const CALL : & 'static str = "set_storage" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Kill some items from storage."] pub struct KillStorage { pub keys : kill_storage :: Keys , } pub mod kill_storage { use super :: runtime_types ; pub type Keys = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > > ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for KillStorage { const PALLET : & 'static str = "System" ; const CALL : & 'static str = "kill_storage" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Kill all storage items with a key that starts with the given prefix."] # [doc = ""] # [doc = "**NOTE:** We rely on the Root origin to provide us the number of subkeys under"] # [doc = "the prefix we are removing to accurately calculate the weight of this function."] pub struct KillPrefix { pub prefix : kill_prefix :: Prefix , pub subkeys : kill_prefix :: Subkeys , } pub mod kill_prefix { use super :: runtime_types ; pub type Prefix = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ; pub type Subkeys = :: core :: primitive :: u32 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for KillPrefix { const PALLET : & 'static str = "System" ; const CALL : & 'static str = "kill_prefix" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Make some on-chain remark and emit event."] pub struct RemarkWithEvent { pub remark : remark_with_event :: Remark , } pub mod remark_with_event { use super :: runtime_types ; pub type Remark = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for RemarkWithEvent { const PALLET : & 'static str = "System" ; const CALL : & 'static str = "remark_with_event" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied"] # [doc = "later."] # [doc = ""] # [doc = "This call requires Root origin."] pub struct AuthorizeUpgrade { pub code_hash : authorize_upgrade :: CodeHash , } pub mod authorize_upgrade { use super :: runtime_types ; pub type CodeHash = :: subxt :: ext :: subxt_core :: utils :: H256 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for AuthorizeUpgrade { const PALLET : & 'static str = "System" ; const CALL : & 'static str = "authorize_upgrade" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied"] # [doc = "later."] # [doc = ""] # [doc = "WARNING: This authorizes an upgrade that will take place without any safety checks, for"] # [doc = "example that the spec name remains the same and that the version number increases. Not"] # [doc = "recommended for normal use. Use `authorize_upgrade` instead."] # [doc = ""] # [doc = "This call requires Root origin."] pub struct AuthorizeUpgradeWithoutChecks { pub code_hash : authorize_upgrade_without_checks :: CodeHash , } pub mod authorize_upgrade_without_checks { use super :: runtime_types ; pub type CodeHash = :: subxt :: ext :: subxt_core :: utils :: H256 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for AuthorizeUpgradeWithoutChecks { const PALLET : & 'static str = "System" ; const CALL : & 'static str = "authorize_upgrade_without_checks" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Provide the preimage (runtime binary) `code` for an upgrade that has been authorized."] # [doc = ""] # [doc = "If the authorization required a version check, this call will ensure the spec name"] # [doc = "remains unchanged and that the spec version has increased."] # [doc = ""] # [doc = "Depending on the runtime's `OnSetCode` configuration, this function may directly apply"] # [doc = "the new `code` in the same block or attempt to schedule the upgrade."] # [doc = ""] # [doc = "All origins are allowed."] pub struct ApplyAuthorizedUpgrade { pub code : apply_authorized_upgrade :: Code , } pub mod apply_authorized_upgrade { use super :: runtime_types ; pub type Code = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for ApplyAuthorizedUpgrade { const PALLET : & 'static str = "System" ; const CALL : & 'static str = "apply_authorized_upgrade" ; } } pub struct TransactionApi ; impl TransactionApi { # [doc = "Make some on-chain remark."] # [doc = ""] # [doc = "Can be executed by every `origin`."] pub fn remark (& self , remark : types :: remark :: Remark ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: Remark > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("System" , "remark" , types :: Remark { remark , } , [43u8 , 126u8 , 180u8 , 174u8 , 141u8 , 48u8 , 52u8 , 125u8 , 166u8 , 212u8 , 216u8 , 98u8 , 100u8 , 24u8 , 132u8 , 71u8 , 101u8 , 64u8 , 246u8 , 169u8 , 33u8 , 250u8 , 147u8 , 208u8 , 2u8 , 40u8 , 129u8 , 209u8 , 232u8 , 207u8 , 207u8 , 13u8 ,]) } # [doc = "Set the number of pages in the WebAssembly environment's heap."] pub fn set_heap_pages (& self , pages : types :: set_heap_pages :: Pages ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SetHeapPages > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("System" , "set_heap_pages" , types :: SetHeapPages { pages , } , [188u8 , 191u8 , 99u8 , 216u8 , 219u8 , 109u8 , 141u8 , 50u8 , 78u8 , 235u8 , 215u8 , 242u8 , 195u8 , 24u8 , 111u8 , 76u8 , 229u8 , 64u8 , 99u8 , 225u8 , 134u8 , 121u8 , 81u8 , 209u8 , 127u8 , 223u8 , 98u8 , 215u8 , 150u8 , 70u8 , 57u8 , 147u8 ,]) } # [doc = "Set the new runtime code."] pub fn set_code (& self , code : types :: set_code :: Code ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SetCode > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("System" , "set_code" , types :: SetCode { code , } , [233u8 , 248u8 , 88u8 , 245u8 , 28u8 , 65u8 , 25u8 , 169u8 , 35u8 , 237u8 , 19u8 , 203u8 , 136u8 , 160u8 , 18u8 , 3u8 , 20u8 , 197u8 , 81u8 , 169u8 , 244u8 , 188u8 , 27u8 , 147u8 , 147u8 , 236u8 , 65u8 , 25u8 , 3u8 , 143u8 , 182u8 , 22u8 ,]) } # [doc = "Set the new runtime code without doing any checks of the given `code`."] # [doc = ""] # [doc = "Note that runtime upgrades will not run if this is called with a not-increasing spec"] # [doc = "version!"] pub fn set_code_without_checks (& self , code : types :: set_code_without_checks :: Code ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SetCodeWithoutChecks > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("System" , "set_code_without_checks" , types :: SetCodeWithoutChecks { code , } , [82u8 , 212u8 , 157u8 , 44u8 , 70u8 , 0u8 , 143u8 , 15u8 , 109u8 , 109u8 , 107u8 , 157u8 , 141u8 , 42u8 , 169u8 , 11u8 , 15u8 , 186u8 , 252u8 , 138u8 , 10u8 , 147u8 , 15u8 , 178u8 , 247u8 , 229u8 , 213u8 , 98u8 , 207u8 , 231u8 , 119u8 , 115u8 ,]) } # [doc = "Set some items of storage."] pub fn set_storage (& self , items : types :: set_storage :: Items ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SetStorage > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("System" , "set_storage" , types :: SetStorage { items , } , [141u8 , 216u8 , 52u8 , 222u8 , 223u8 , 136u8 , 123u8 , 181u8 , 19u8 , 75u8 , 163u8 , 102u8 , 229u8 , 189u8 , 158u8 , 142u8 , 95u8 , 235u8 , 240u8 , 49u8 , 150u8 , 76u8 , 78u8 , 137u8 , 126u8 , 88u8 , 183u8 , 88u8 , 231u8 , 146u8 , 234u8 , 43u8 ,]) } # [doc = "Kill some items from storage."] pub fn kill_storage (& self , keys : types :: kill_storage :: Keys ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: KillStorage > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("System" , "kill_storage" , types :: KillStorage { keys , } , [73u8 , 63u8 , 196u8 , 36u8 , 144u8 , 114u8 , 34u8 , 213u8 , 108u8 , 93u8 , 209u8 , 234u8 , 153u8 , 185u8 , 33u8 , 91u8 , 187u8 , 195u8 , 223u8 , 130u8 , 58u8 , 156u8 , 63u8 , 47u8 , 228u8 , 249u8 , 216u8 , 139u8 , 143u8 , 177u8 , 41u8 , 35u8 ,]) } # [doc = "Kill all storage items with a key that starts with the given prefix."] # [doc = ""] # [doc = "**NOTE:** We rely on the Root origin to provide us the number of subkeys under"] # [doc = "the prefix we are removing to accurately calculate the weight of this function."] pub fn kill_prefix (& self , prefix : types :: kill_prefix :: Prefix , subkeys : types :: kill_prefix :: Subkeys ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: KillPrefix > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("System" , "kill_prefix" , types :: KillPrefix { prefix , subkeys , } , [184u8 , 57u8 , 139u8 , 24u8 , 208u8 , 87u8 , 108u8 , 215u8 , 198u8 , 189u8 , 175u8 , 242u8 , 167u8 , 215u8 , 97u8 , 63u8 , 110u8 , 166u8 , 238u8 , 98u8 , 67u8 , 236u8 , 111u8 , 110u8 , 234u8 , 81u8 , 102u8 , 5u8 , 182u8 , 5u8 , 214u8 , 85u8 ,]) } # [doc = "Make some on-chain remark and emit event."] pub fn remark_with_event (& self , remark : types :: remark_with_event :: Remark ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: RemarkWithEvent > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("System" , "remark_with_event" , types :: RemarkWithEvent { remark , } , [120u8 , 120u8 , 153u8 , 92u8 , 184u8 , 85u8 , 34u8 , 2u8 , 174u8 , 206u8 , 105u8 , 228u8 , 233u8 , 130u8 , 80u8 , 246u8 , 228u8 , 59u8 , 234u8 , 240u8 , 4u8 , 49u8 , 147u8 , 170u8 , 115u8 , 91u8 , 149u8 , 200u8 , 228u8 , 181u8 , 8u8 , 154u8 ,]) } # [doc = "Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied"] # [doc = "later."] # [doc = ""] # [doc = "This call requires Root origin."] pub fn authorize_upgrade (& self , code_hash : types :: authorize_upgrade :: CodeHash ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: AuthorizeUpgrade > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("System" , "authorize_upgrade" , types :: AuthorizeUpgrade { code_hash , } , [4u8 , 14u8 , 76u8 , 107u8 , 209u8 , 129u8 , 9u8 , 39u8 , 193u8 , 17u8 , 84u8 , 254u8 , 170u8 , 214u8 , 24u8 , 155u8 , 29u8 , 184u8 , 249u8 , 241u8 , 109u8 , 58u8 , 145u8 , 131u8 , 109u8 , 63u8 , 38u8 , 165u8 , 107u8 , 215u8 , 217u8 , 172u8 ,]) } # [doc = "Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied"] # [doc = "later."] # [doc = ""] # [doc = "WARNING: This authorizes an upgrade that will take place without any safety checks, for"] # [doc = "example that the spec name remains the same and that the version number increases. Not"] # [doc = "recommended for normal use. Use `authorize_upgrade` instead."] # [doc = ""] # [doc = "This call requires Root origin."] pub fn authorize_upgrade_without_checks (& self , code_hash : types :: authorize_upgrade_without_checks :: CodeHash ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: AuthorizeUpgradeWithoutChecks > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("System" , "authorize_upgrade_without_checks" , types :: AuthorizeUpgradeWithoutChecks { code_hash , } , [126u8 , 126u8 , 55u8 , 26u8 , 47u8 , 55u8 , 66u8 , 8u8 , 167u8 , 18u8 , 29u8 , 136u8 , 146u8 , 14u8 , 189u8 , 117u8 , 16u8 , 227u8 , 162u8 , 61u8 , 149u8 , 197u8 , 104u8 , 184u8 , 185u8 , 161u8 , 99u8 , 154u8 , 80u8 , 125u8 , 181u8 , 233u8 ,]) } # [doc = "Provide the preimage (runtime binary) `code` for an upgrade that has been authorized."] # [doc = ""] # [doc = "If the authorization required a version check, this call will ensure the spec name"] # [doc = "remains unchanged and that the spec version has increased."] # [doc = ""] # [doc = "Depending on the runtime's `OnSetCode` configuration, this function may directly apply"] # [doc = "the new `code` in the same block or attempt to schedule the upgrade."] # [doc = ""] # [doc = "All origins are allowed."] pub fn apply_authorized_upgrade (& self , code : types :: apply_authorized_upgrade :: Code ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: ApplyAuthorizedUpgrade > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("System" , "apply_authorized_upgrade" , types :: ApplyAuthorizedUpgrade { code , } , [232u8 , 107u8 , 127u8 , 38u8 , 230u8 , 29u8 , 97u8 , 4u8 , 160u8 , 191u8 , 222u8 , 156u8 , 245u8 , 102u8 , 196u8 , 141u8 , 44u8 , 163u8 , 98u8 , 68u8 , 125u8 , 32u8 , 124u8 , 101u8 , 108u8 , 93u8 , 211u8 , 52u8 , 0u8 , 231u8 , 33u8 , 227u8 ,]) } } } # [doc = "Event for the System pallet."] pub type Event = runtime_types :: frame_system :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "An extrinsic completed successfully."] pub struct ExtrinsicSuccess { pub dispatch_info : extrinsic_success :: DispatchInfo , } pub mod extrinsic_success { use super :: runtime_types ; pub type DispatchInfo = runtime_types :: frame_support :: dispatch :: DispatchInfo ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for ExtrinsicSuccess { const PALLET : & 'static str = "System" ; const EVENT : & 'static str = "ExtrinsicSuccess" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "An extrinsic failed."] pub struct ExtrinsicFailed { pub dispatch_error : extrinsic_failed :: DispatchError , pub dispatch_info : extrinsic_failed :: DispatchInfo , } pub mod extrinsic_failed { use super :: runtime_types ; pub type DispatchError = runtime_types :: sp_runtime :: DispatchError ; pub type DispatchInfo = runtime_types :: frame_support :: dispatch :: DispatchInfo ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for ExtrinsicFailed { const PALLET : & 'static str = "System" ; const EVENT : & 'static str = "ExtrinsicFailed" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "`:code` was updated."] pub struct CodeUpdated ; impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for CodeUpdated { const PALLET : & 'static str = "System" ; const EVENT : & 'static str = "CodeUpdated" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "A new account was created."] pub struct NewAccount { pub account : new_account :: Account , } pub mod new_account { use super :: runtime_types ; pub type Account = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for NewAccount { const PALLET : & 'static str = "System" ; const EVENT : & 'static str = "NewAccount" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "An account was reaped."] pub struct KilledAccount { pub account : killed_account :: Account , } pub mod killed_account { use super :: runtime_types ; pub type Account = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for KilledAccount { const PALLET : & 'static str = "System" ; const EVENT : & 'static str = "KilledAccount" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "On on-chain remark happened."] pub struct Remarked { pub sender : remarked :: Sender , pub hash : remarked :: Hash , } pub mod remarked { use super :: runtime_types ; pub type Sender = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Hash = :: subxt :: ext :: subxt_core :: utils :: H256 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Remarked { const PALLET : & 'static str = "System" ; const EVENT : & 'static str = "Remarked" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "An upgrade was authorized."] pub struct UpgradeAuthorized { pub code_hash : upgrade_authorized :: CodeHash , pub check_version : upgrade_authorized :: CheckVersion , } pub mod upgrade_authorized { use super :: runtime_types ; pub type CodeHash = :: subxt :: ext :: subxt_core :: utils :: H256 ; pub type CheckVersion = :: core :: primitive :: bool ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for UpgradeAuthorized { const PALLET : & 'static str = "System" ; const EVENT : & 'static str = "UpgradeAuthorized" ; } } pub mod storage { use super :: runtime_types ; pub mod types { use super :: runtime_types ; pub mod account { use super :: runtime_types ; pub type Account = runtime_types :: frame_system :: AccountInfo < :: core :: primitive :: u32 , runtime_types :: pallet_balances :: types :: AccountData < :: core :: primitive :: u64 > > ; pub type Param0 = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } pub mod extrinsic_count { use super :: runtime_types ; pub type ExtrinsicCount = :: core :: primitive :: u32 ; } pub mod inherents_applied { use super :: runtime_types ; pub type InherentsApplied = :: core :: primitive :: bool ; } pub mod block_weight { use super :: runtime_types ; pub type BlockWeight = runtime_types :: frame_support :: dispatch :: PerDispatchClass < runtime_types :: sp_weights :: weight_v2 :: Weight > ; } pub mod all_extrinsics_len { use super :: runtime_types ; pub type AllExtrinsicsLen = :: core :: primitive :: u32 ; } pub mod block_hash { use super :: runtime_types ; pub type BlockHash = :: subxt :: ext :: subxt_core :: utils :: H256 ; pub type Param0 = :: core :: primitive :: u32 ; } pub mod extrinsic_data { use super :: runtime_types ; pub type ExtrinsicData = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ; pub type Param0 = :: core :: primitive :: u32 ; } pub mod number { use super :: runtime_types ; pub type Number = :: core :: primitive :: u32 ; } pub mod parent_hash { use super :: runtime_types ; pub type ParentHash = :: subxt :: ext :: subxt_core :: utils :: H256 ; } pub mod digest { use super :: runtime_types ; pub type Digest = runtime_types :: sp_runtime :: generic :: digest :: Digest ; } pub mod events { use super :: runtime_types ; pub type Events = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < runtime_types :: frame_system :: EventRecord < runtime_types :: node_subtensor_runtime :: RuntimeEvent , :: subxt :: ext :: subxt_core :: utils :: H256 > > ; } pub mod event_count { use super :: runtime_types ; pub type EventCount = :: core :: primitive :: u32 ; } pub mod event_topics { use super :: runtime_types ; pub type EventTopics = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) > ; pub type Param0 = :: subxt :: ext :: subxt_core :: utils :: H256 ; } pub mod last_runtime_upgrade { use super :: runtime_types ; pub type LastRuntimeUpgrade = runtime_types :: frame_system :: LastRuntimeUpgradeInfo ; } pub mod upgraded_to_u32_ref_count { use super :: runtime_types ; pub type UpgradedToU32RefCount = :: core :: primitive :: bool ; } pub mod upgraded_to_triple_ref_count { use super :: runtime_types ; pub type UpgradedToTripleRefCount = :: core :: primitive :: bool ; } pub mod execution_phase { use super :: runtime_types ; pub type ExecutionPhase = runtime_types :: frame_system :: Phase ; } pub mod authorized_upgrade { use super :: runtime_types ; pub type AuthorizedUpgrade = runtime_types :: frame_system :: CodeUpgradeAuthorization ; } } pub struct StorageApi ; impl StorageApi { # [doc = " The full account information for a particular account ID."] pub fn account_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: account :: Account , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("System" , "Account" , () , [134u8 , 36u8 , 200u8 , 97u8 , 250u8 , 93u8 , 194u8 , 130u8 , 234u8 , 169u8 , 160u8 , 176u8 , 58u8 , 142u8 , 63u8 , 133u8 , 29u8 , 94u8 , 102u8 , 192u8 , 82u8 , 6u8 , 105u8 , 248u8 , 238u8 , 246u8 , 26u8 , 107u8 , 39u8 , 219u8 , 103u8 , 212u8 ,]) } # [doc = " The full account information for a particular account ID."] pub fn account (& self , _0 : impl :: core :: borrow :: Borrow < types :: account :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: account :: Param0 > , types :: account :: Account , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("System" , "Account" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [134u8 , 36u8 , 200u8 , 97u8 , 250u8 , 93u8 , 194u8 , 130u8 , 234u8 , 169u8 , 160u8 , 176u8 , 58u8 , 142u8 , 63u8 , 133u8 , 29u8 , 94u8 , 102u8 , 192u8 , 82u8 , 6u8 , 105u8 , 248u8 , 238u8 , 246u8 , 26u8 , 107u8 , 39u8 , 219u8 , 103u8 , 212u8 ,]) } # [doc = " Total extrinsics count for the current block."] pub fn extrinsic_count (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: extrinsic_count :: ExtrinsicCount , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("System" , "ExtrinsicCount" , () , [102u8 , 76u8 , 236u8 , 42u8 , 40u8 , 231u8 , 33u8 , 222u8 , 123u8 , 147u8 , 153u8 , 148u8 , 234u8 , 203u8 , 181u8 , 119u8 , 6u8 , 187u8 , 177u8 , 199u8 , 120u8 , 47u8 , 137u8 , 254u8 , 96u8 , 100u8 , 165u8 , 182u8 , 249u8 , 230u8 , 159u8 , 79u8 ,]) } # [doc = " Whether all inherents have been applied."] pub fn inherents_applied (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: inherents_applied :: InherentsApplied , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("System" , "InherentsApplied" , () , [132u8 , 249u8 , 142u8 , 252u8 , 8u8 , 103u8 , 80u8 , 120u8 , 50u8 , 6u8 , 188u8 , 223u8 , 101u8 , 55u8 , 165u8 , 189u8 , 172u8 , 249u8 , 165u8 , 230u8 , 183u8 , 109u8 , 34u8 , 65u8 , 185u8 , 150u8 , 29u8 , 8u8 , 186u8 , 129u8 , 135u8 , 239u8 ,]) } # [doc = " The current weight for the block."] pub fn block_weight (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: block_weight :: BlockWeight , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("System" , "BlockWeight" , () , [158u8 , 46u8 , 228u8 , 89u8 , 210u8 , 214u8 , 84u8 , 154u8 , 50u8 , 68u8 , 63u8 , 62u8 , 43u8 , 42u8 , 99u8 , 27u8 , 54u8 , 42u8 , 146u8 , 44u8 , 241u8 , 216u8 , 229u8 , 30u8 , 216u8 , 255u8 , 165u8 , 238u8 , 181u8 , 130u8 , 36u8 , 102u8 ,]) } # [doc = " Total length (in bytes) for all extrinsics put together, for the current block."] pub fn all_extrinsics_len (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: all_extrinsics_len :: AllExtrinsicsLen , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("System" , "AllExtrinsicsLen" , () , [117u8 , 86u8 , 61u8 , 243u8 , 41u8 , 51u8 , 102u8 , 214u8 , 137u8 , 100u8 , 243u8 , 185u8 , 122u8 , 174u8 , 187u8 , 117u8 , 86u8 , 189u8 , 63u8 , 135u8 , 101u8 , 218u8 , 203u8 , 201u8 , 237u8 , 254u8 , 128u8 , 183u8 , 169u8 , 221u8 , 242u8 , 65u8 ,]) } # [doc = " Map of block numbers to block hashes."] pub fn block_hash_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: block_hash :: BlockHash , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("System" , "BlockHash" , () , [217u8 , 32u8 , 215u8 , 253u8 , 24u8 , 182u8 , 207u8 , 178u8 , 157u8 , 24u8 , 103u8 , 100u8 , 195u8 , 165u8 , 69u8 , 152u8 , 112u8 , 181u8 , 56u8 , 192u8 , 164u8 , 16u8 , 20u8 , 222u8 , 28u8 , 214u8 , 144u8 , 142u8 , 146u8 , 69u8 , 202u8 , 118u8 ,]) } # [doc = " Map of block numbers to block hashes."] pub fn block_hash (& self , _0 : impl :: core :: borrow :: Borrow < types :: block_hash :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: block_hash :: Param0 > , types :: block_hash :: BlockHash , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("System" , "BlockHash" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [217u8 , 32u8 , 215u8 , 253u8 , 24u8 , 182u8 , 207u8 , 178u8 , 157u8 , 24u8 , 103u8 , 100u8 , 195u8 , 165u8 , 69u8 , 152u8 , 112u8 , 181u8 , 56u8 , 192u8 , 164u8 , 16u8 , 20u8 , 222u8 , 28u8 , 214u8 , 144u8 , 142u8 , 146u8 , 69u8 , 202u8 , 118u8 ,]) } # [doc = " Extrinsics data for the current block (maps an extrinsic's index to its data)."] pub fn extrinsic_data_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: extrinsic_data :: ExtrinsicData , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("System" , "ExtrinsicData" , () , [160u8 , 180u8 , 122u8 , 18u8 , 196u8 , 26u8 , 2u8 , 37u8 , 115u8 , 232u8 , 133u8 , 220u8 , 106u8 , 245u8 , 4u8 , 129u8 , 42u8 , 84u8 , 241u8 , 45u8 , 199u8 , 179u8 , 128u8 , 61u8 , 170u8 , 137u8 , 231u8 , 156u8 , 247u8 , 57u8 , 47u8 , 38u8 ,]) } # [doc = " Extrinsics data for the current block (maps an extrinsic's index to its data)."] pub fn extrinsic_data (& self , _0 : impl :: core :: borrow :: Borrow < types :: extrinsic_data :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: extrinsic_data :: Param0 > , types :: extrinsic_data :: ExtrinsicData , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("System" , "ExtrinsicData" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [160u8 , 180u8 , 122u8 , 18u8 , 196u8 , 26u8 , 2u8 , 37u8 , 115u8 , 232u8 , 133u8 , 220u8 , 106u8 , 245u8 , 4u8 , 129u8 , 42u8 , 84u8 , 241u8 , 45u8 , 199u8 , 179u8 , 128u8 , 61u8 , 170u8 , 137u8 , 231u8 , 156u8 , 247u8 , 57u8 , 47u8 , 38u8 ,]) } # [doc = " The current block number being processed. Set by `execute_block`."] pub fn number (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: number :: Number , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("System" , "Number" , () , [30u8 , 194u8 , 177u8 , 90u8 , 194u8 , 232u8 , 46u8 , 180u8 , 85u8 , 129u8 , 14u8 , 9u8 , 8u8 , 8u8 , 23u8 , 95u8 , 230u8 , 5u8 , 13u8 , 105u8 , 125u8 , 2u8 , 22u8 , 200u8 , 78u8 , 93u8 , 115u8 , 28u8 , 150u8 , 113u8 , 48u8 , 53u8 ,]) } # [doc = " Hash of the previous block."] pub fn parent_hash (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: parent_hash :: ParentHash , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("System" , "ParentHash" , () , [26u8 , 130u8 , 11u8 , 216u8 , 155u8 , 71u8 , 128u8 , 170u8 , 30u8 , 153u8 , 21u8 , 192u8 , 62u8 , 93u8 , 137u8 , 80u8 , 120u8 , 81u8 , 202u8 , 94u8 , 248u8 , 125u8 , 71u8 , 82u8 , 141u8 , 229u8 , 32u8 , 56u8 , 73u8 , 50u8 , 101u8 , 78u8 ,]) } # [doc = " Digest of the current block, also part of the block header."] pub fn digest (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: digest :: Digest , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("System" , "Digest" , () , [61u8 , 64u8 , 237u8 , 91u8 , 145u8 , 232u8 , 17u8 , 254u8 , 181u8 , 16u8 , 234u8 , 91u8 , 51u8 , 140u8 , 254u8 , 131u8 , 98u8 , 135u8 , 21u8 , 37u8 , 251u8 , 20u8 , 58u8 , 92u8 , 123u8 , 141u8 , 14u8 , 227u8 , 146u8 , 46u8 , 222u8 , 117u8 ,]) } # [doc = " Events deposited for the current block."] # [doc = ""] # [doc = " NOTE: The item is unbound and should therefore never be read on chain."] # [doc = " It could otherwise inflate the PoV size of a block."] # [doc = ""] # [doc = " Events have a large in-memory size. Box the events to not go out-of-memory"] # [doc = " just in case someone still reads them from within the runtime."] pub fn events (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: events :: Events , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("System" , "Events" , () , [31u8 , 218u8 , 113u8 , 49u8 , 20u8 , 117u8 , 108u8 , 188u8 , 13u8 , 146u8 , 151u8 , 164u8 , 1u8 , 131u8 , 234u8 , 72u8 , 70u8 , 114u8 , 126u8 , 208u8 , 196u8 , 12u8 , 173u8 , 74u8 , 196u8 , 116u8 , 50u8 , 101u8 , 108u8 , 25u8 , 178u8 , 224u8 ,]) } # [doc = " The number of events in the `Events<T>` list."] pub fn event_count (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: event_count :: EventCount , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("System" , "EventCount" , () , [175u8 , 24u8 , 252u8 , 184u8 , 210u8 , 167u8 , 146u8 , 143u8 , 164u8 , 80u8 , 151u8 , 205u8 , 189u8 , 189u8 , 55u8 , 220u8 , 47u8 , 101u8 , 181u8 , 33u8 , 254u8 , 131u8 , 13u8 , 143u8 , 3u8 , 244u8 , 245u8 , 45u8 , 2u8 , 210u8 , 79u8 , 133u8 ,]) } # [doc = " Mapping between a topic (represented by T::Hash) and a vector of indexes"] # [doc = " of events in the `<Events<T>>` list."] # [doc = ""] # [doc = " All topic vectors have deterministic storage locations depending on the topic. This"] # [doc = " allows light-clients to leverage the changes trie storage tracking mechanism and"] # [doc = " in case of changes fetch the list of events of interest."] # [doc = ""] # [doc = " The value has the type `(BlockNumberFor<T>, EventIndex)` because if we used only just"] # [doc = " the `EventIndex` then in case if the topic has the same contents on the next block"] # [doc = " no notification will be triggered thus the event might be lost."] pub fn event_topics_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: event_topics :: EventTopics , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("System" , "EventTopics" , () , [40u8 , 225u8 , 14u8 , 75u8 , 44u8 , 176u8 , 76u8 , 34u8 , 143u8 , 107u8 , 69u8 , 133u8 , 114u8 , 13u8 , 172u8 , 250u8 , 141u8 , 73u8 , 12u8 , 65u8 , 217u8 , 63u8 , 120u8 , 241u8 , 48u8 , 106u8 , 143u8 , 161u8 , 128u8 , 100u8 , 166u8 , 59u8 ,]) } # [doc = " Mapping between a topic (represented by T::Hash) and a vector of indexes"] # [doc = " of events in the `<Events<T>>` list."] # [doc = ""] # [doc = " All topic vectors have deterministic storage locations depending on the topic. This"] # [doc = " allows light-clients to leverage the changes trie storage tracking mechanism and"] # [doc = " in case of changes fetch the list of events of interest."] # [doc = ""] # [doc = " The value has the type `(BlockNumberFor<T>, EventIndex)` because if we used only just"] # [doc = " the `EventIndex` then in case if the topic has the same contents on the next block"] # [doc = " no notification will be triggered thus the event might be lost."] pub fn event_topics (& self , _0 : impl :: core :: borrow :: Borrow < types :: event_topics :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: event_topics :: Param0 > , types :: event_topics :: EventTopics , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("System" , "EventTopics" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [40u8 , 225u8 , 14u8 , 75u8 , 44u8 , 176u8 , 76u8 , 34u8 , 143u8 , 107u8 , 69u8 , 133u8 , 114u8 , 13u8 , 172u8 , 250u8 , 141u8 , 73u8 , 12u8 , 65u8 , 217u8 , 63u8 , 120u8 , 241u8 , 48u8 , 106u8 , 143u8 , 161u8 , 128u8 , 100u8 , 166u8 , 59u8 ,]) } # [doc = " Stores the `spec_version` and `spec_name` of when the last runtime upgrade happened."] pub fn last_runtime_upgrade (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: last_runtime_upgrade :: LastRuntimeUpgrade , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("System" , "LastRuntimeUpgrade" , () , [137u8 , 29u8 , 175u8 , 75u8 , 197u8 , 208u8 , 91u8 , 207u8 , 156u8 , 87u8 , 148u8 , 68u8 , 91u8 , 140u8 , 22u8 , 233u8 , 1u8 , 229u8 , 56u8 , 34u8 , 40u8 , 194u8 , 253u8 , 30u8 , 163u8 , 39u8 , 54u8 , 209u8 , 13u8 , 27u8 , 139u8 , 184u8 ,]) } # [doc = " True if we have upgraded so that `type RefCount` is `u32`. False (default) if not."] pub fn upgraded_to_u32_ref_count (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: upgraded_to_u32_ref_count :: UpgradedToU32RefCount , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("System" , "UpgradedToU32RefCount" , () , [229u8 , 73u8 , 9u8 , 132u8 , 186u8 , 116u8 , 151u8 , 171u8 , 145u8 , 29u8 , 34u8 , 130u8 , 52u8 , 146u8 , 124u8 , 175u8 , 79u8 , 189u8 , 147u8 , 230u8 , 234u8 , 107u8 , 124u8 , 31u8 , 2u8 , 22u8 , 86u8 , 190u8 , 4u8 , 147u8 , 50u8 , 245u8 ,]) } # [doc = " True if we have upgraded so that AccountInfo contains three types of `RefCount`. False"] # [doc = " (default) if not."] pub fn upgraded_to_triple_ref_count (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: upgraded_to_triple_ref_count :: UpgradedToTripleRefCount , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("System" , "UpgradedToTripleRefCount" , () , [97u8 , 66u8 , 124u8 , 243u8 , 27u8 , 167u8 , 147u8 , 81u8 , 254u8 , 201u8 , 101u8 , 24u8 , 40u8 , 231u8 , 14u8 , 179u8 , 154u8 , 163u8 , 71u8 , 81u8 , 185u8 , 167u8 , 82u8 , 254u8 , 189u8 , 3u8 , 101u8 , 207u8 , 206u8 , 194u8 , 155u8 , 151u8 ,]) } # [doc = " The execution phase of the block."] pub fn execution_phase (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: execution_phase :: ExecutionPhase , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("System" , "ExecutionPhase" , () , [191u8 , 129u8 , 100u8 , 134u8 , 126u8 , 116u8 , 154u8 , 203u8 , 220u8 , 200u8 , 0u8 , 26u8 , 161u8 , 250u8 , 133u8 , 205u8 , 146u8 , 24u8 , 5u8 , 156u8 , 158u8 , 35u8 , 36u8 , 253u8 , 52u8 , 235u8 , 86u8 , 167u8 , 35u8 , 100u8 , 119u8 , 27u8 ,]) } # [doc = " `Some` if a code upgrade has been authorized."] pub fn authorized_upgrade (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: authorized_upgrade :: AuthorizedUpgrade , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("System" , "AuthorizedUpgrade" , () , [165u8 , 97u8 , 27u8 , 138u8 , 2u8 , 28u8 , 55u8 , 92u8 , 96u8 , 96u8 , 168u8 , 169u8 , 55u8 , 178u8 , 44u8 , 127u8 , 58u8 , 140u8 , 206u8 , 178u8 , 1u8 , 37u8 , 214u8 , 213u8 , 251u8 , 123u8 , 5u8 , 111u8 , 90u8 , 148u8 , 217u8 , 135u8 ,]) } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi ; impl ConstantsApi { # [doc = " Block & extrinsics weights: base values and limits."] pub fn block_weights (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < runtime_types :: frame_system :: limits :: BlockWeights > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("System" , "BlockWeights" , [176u8 , 124u8 , 225u8 , 136u8 , 25u8 , 73u8 , 247u8 , 33u8 , 82u8 , 206u8 , 85u8 , 190u8 , 127u8 , 102u8 , 71u8 , 11u8 , 185u8 , 8u8 , 58u8 , 0u8 , 94u8 , 55u8 , 163u8 , 177u8 , 104u8 , 59u8 , 60u8 , 136u8 , 246u8 , 116u8 , 0u8 , 239u8 ,]) } # [doc = " The maximum length of a block (in bytes)."] pub fn block_length (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < runtime_types :: frame_system :: limits :: BlockLength > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("System" , "BlockLength" , [23u8 , 242u8 , 225u8 , 39u8 , 225u8 , 67u8 , 152u8 , 41u8 , 155u8 , 104u8 , 68u8 , 229u8 , 185u8 , 133u8 , 10u8 , 143u8 , 184u8 , 152u8 , 234u8 , 44u8 , 140u8 , 96u8 , 166u8 , 235u8 , 162u8 , 160u8 , 72u8 , 7u8 , 35u8 , 194u8 , 3u8 , 37u8 ,]) } # [doc = " Maximum number of block number to block hash mappings to keep (oldest pruned first)."] pub fn block_hash_count (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u32 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("System" , "BlockHashCount" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " The weight of runtime database operations the runtime can invoke."] pub fn db_weight (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < runtime_types :: sp_weights :: RuntimeDbWeight > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("System" , "DbWeight" , [42u8 , 43u8 , 178u8 , 142u8 , 243u8 , 203u8 , 60u8 , 173u8 , 118u8 , 111u8 , 200u8 , 170u8 , 102u8 , 70u8 , 237u8 , 187u8 , 198u8 , 120u8 , 153u8 , 232u8 , 183u8 , 76u8 , 74u8 , 10u8 , 70u8 , 243u8 , 14u8 , 218u8 , 213u8 , 126u8 , 29u8 , 177u8 ,]) } # [doc = " Get the chain's in-code version."] pub fn version (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < runtime_types :: sp_version :: RuntimeVersion > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("System" , "Version" , [219u8 , 45u8 , 162u8 , 245u8 , 177u8 , 246u8 , 48u8 , 126u8 , 191u8 , 157u8 , 228u8 , 83u8 , 111u8 , 133u8 , 183u8 , 13u8 , 148u8 , 108u8 , 92u8 , 102u8 , 72u8 , 205u8 , 74u8 , 242u8 , 233u8 , 79u8 , 20u8 , 170u8 , 72u8 , 202u8 , 158u8 , 165u8 ,]) } # [doc = " The designated SS58 prefix of this chain."] # [doc = ""] # [doc = " This replaces the \"ss58Format\" property declared in the chain spec. Reason is"] # [doc = " that the runtime should know about the prefix in order to make use of it as"] # [doc = " an identifier of the chain."] pub fn ss58_prefix (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u16 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("System" , "SS58Prefix" , [116u8 , 33u8 , 2u8 , 170u8 , 181u8 , 147u8 , 171u8 , 169u8 , 167u8 , 227u8 , 41u8 , 144u8 , 11u8 , 236u8 , 82u8 , 100u8 , 74u8 , 60u8 , 184u8 , 72u8 , 169u8 , 90u8 , 208u8 , 135u8 , 15u8 , 117u8 , 10u8 , 123u8 , 128u8 , 193u8 , 29u8 , 70u8 ,]) } } } } pub mod randomness_collective_flip { use super :: root_mod ; use super :: runtime_types ; pub mod storage { use super :: runtime_types ; pub mod types { use super :: runtime_types ; pub mod random_material { use super :: runtime_types ; pub type RandomMaterial = runtime_types :: bounded_collections :: bounded_vec :: BoundedVec < :: subxt :: ext :: subxt_core :: utils :: H256 > ; } } pub struct StorageApi ; impl StorageApi { # [doc = " Series of block headers from the last 81 blocks that acts as random seed material. This"] # [doc = " is arranged as a ring buffer with `block_number % 81` being the index into the `Vec` of"] # [doc = " the oldest hash."] pub fn random_material (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: random_material :: RandomMaterial , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("RandomnessCollectiveFlip" , "RandomMaterial" , () , [195u8 , 232u8 , 244u8 , 162u8 , 110u8 , 137u8 , 66u8 , 57u8 , 51u8 , 221u8 , 143u8 , 38u8 , 51u8 , 183u8 , 105u8 , 245u8 , 175u8 , 13u8 , 33u8 , 192u8 , 53u8 , 16u8 , 161u8 , 76u8 , 219u8 , 177u8 , 144u8 , 192u8 , 96u8 , 166u8 , 117u8 , 247u8 ,]) } } } } pub mod timestamp { use super :: root_mod ; use super :: runtime_types ; # [doc = "Contains a variant per dispatchable extrinsic that this pallet has."] pub type Call = runtime_types :: pallet_timestamp :: pallet :: Call ; pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; pub mod types { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Set the current time."] # [doc = ""] # [doc = "This call should be invoked exactly once per block. It will panic at the finalization"] # [doc = "phase, if this call hasn't been invoked by that time."] # [doc = ""] # [doc = "The timestamp should be greater than the previous one by the amount specified by"] # [doc = "[`Config::MinimumPeriod`]."] # [doc = ""] # [doc = "The dispatch origin for this call must be _None_."] # [doc = ""] # [doc = "This dispatch class is _Mandatory_ to ensure it gets executed in the block. Be aware"] # [doc = "that changing the complexity of this call could result exhausting the resources in a"] # [doc = "block to execute any other calls."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(1)` (Note that implementations of `OnTimestampSet` must also be `O(1)`)"] # [doc = "- 1 storage read and 1 storage mutation (codec `O(1)` because of `DidUpdate::take` in"] # [doc = "  `on_finalize`)"] # [doc = "- 1 event handler `on_timestamp_set`. Must be `O(1)`."] pub struct Set { # [codec (compact)] pub now : set :: Now , } pub mod set { use super :: runtime_types ; pub type Now = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for Set { const PALLET : & 'static str = "Timestamp" ; const CALL : & 'static str = "set" ; } } pub struct TransactionApi ; impl TransactionApi { # [doc = "Set the current time."] # [doc = ""] # [doc = "This call should be invoked exactly once per block. It will panic at the finalization"] # [doc = "phase, if this call hasn't been invoked by that time."] # [doc = ""] # [doc = "The timestamp should be greater than the previous one by the amount specified by"] # [doc = "[`Config::MinimumPeriod`]."] # [doc = ""] # [doc = "The dispatch origin for this call must be _None_."] # [doc = ""] # [doc = "This dispatch class is _Mandatory_ to ensure it gets executed in the block. Be aware"] # [doc = "that changing the complexity of this call could result exhausting the resources in a"] # [doc = "block to execute any other calls."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(1)` (Note that implementations of `OnTimestampSet` must also be `O(1)`)"] # [doc = "- 1 storage read and 1 storage mutation (codec `O(1)` because of `DidUpdate::take` in"] # [doc = "  `on_finalize`)"] # [doc = "- 1 event handler `on_timestamp_set`. Must be `O(1)`."] pub fn set (& self , now : types :: set :: Now ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: Set > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Timestamp" , "set" , types :: Set { now , } , [37u8 , 95u8 , 49u8 , 218u8 , 24u8 , 22u8 , 0u8 , 95u8 , 72u8 , 35u8 , 155u8 , 199u8 , 213u8 , 54u8 , 207u8 , 22u8 , 185u8 , 193u8 , 221u8 , 70u8 , 18u8 , 200u8 , 4u8 , 231u8 , 195u8 , 173u8 , 6u8 , 122u8 , 11u8 , 203u8 , 231u8 , 227u8 ,]) } } } pub mod storage { use super :: runtime_types ; pub mod types { use super :: runtime_types ; pub mod now { use super :: runtime_types ; pub type Now = :: core :: primitive :: u64 ; } pub mod did_update { use super :: runtime_types ; pub type DidUpdate = :: core :: primitive :: bool ; } } pub struct StorageApi ; impl StorageApi { # [doc = " The current time for the current block."] pub fn now (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: now :: Now , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Timestamp" , "Now" , () , [44u8 , 50u8 , 80u8 , 30u8 , 195u8 , 146u8 , 123u8 , 238u8 , 8u8 , 163u8 , 187u8 , 92u8 , 61u8 , 39u8 , 51u8 , 29u8 , 173u8 , 169u8 , 217u8 , 158u8 , 85u8 , 187u8 , 141u8 , 26u8 , 12u8 , 115u8 , 51u8 , 11u8 , 200u8 , 244u8 , 138u8 , 152u8 ,]) } # [doc = " Whether the timestamp has been updated in this block."] # [doc = ""] # [doc = " This value is updated to `true` upon successful submission of a timestamp by a node."] # [doc = " It is then checked at the end of each block execution in the `on_finalize` hook."] pub fn did_update (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: did_update :: DidUpdate , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Timestamp" , "DidUpdate" , () , [229u8 , 175u8 , 246u8 , 102u8 , 237u8 , 158u8 , 212u8 , 229u8 , 238u8 , 214u8 , 205u8 , 160u8 , 164u8 , 252u8 , 195u8 , 75u8 , 139u8 , 110u8 , 22u8 , 34u8 , 248u8 , 204u8 , 107u8 , 46u8 , 20u8 , 200u8 , 238u8 , 167u8 , 71u8 , 41u8 , 214u8 , 140u8 ,]) } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi ; impl ConstantsApi { # [doc = " The minimum period between blocks."] # [doc = ""] # [doc = " Be aware that this is different to the *expected* period that the block production"] # [doc = " apparatus provides. Your chosen consensus system will generally work with this to"] # [doc = " determine a sensible block time. For example, in the Aura pallet it will be double this"] # [doc = " period on default settings."] pub fn minimum_period (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u64 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Timestamp" , "MinimumPeriod" , [128u8 , 214u8 , 205u8 , 242u8 , 181u8 , 142u8 , 124u8 , 231u8 , 190u8 , 146u8 , 59u8 , 226u8 , 157u8 , 101u8 , 103u8 , 117u8 , 249u8 , 65u8 , 18u8 , 191u8 , 103u8 , 119u8 , 53u8 , 85u8 , 81u8 , 96u8 , 220u8 , 42u8 , 184u8 , 239u8 , 42u8 , 246u8 ,]) } } } } pub mod aura { use super :: root_mod ; use super :: runtime_types ; pub mod storage { use super :: runtime_types ; pub mod types { use super :: runtime_types ; pub mod authorities { use super :: runtime_types ; pub type Authorities = runtime_types :: bounded_collections :: bounded_vec :: BoundedVec < runtime_types :: sp_consensus_aura :: sr25519 :: app_sr25519 :: Public > ; } pub mod current_slot { use super :: runtime_types ; pub type CurrentSlot = runtime_types :: sp_consensus_slots :: Slot ; } } pub struct StorageApi ; impl StorageApi { # [doc = " The current authority set."] pub fn authorities (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: authorities :: Authorities , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Aura" , "Authorities" , () , [95u8 , 52u8 , 203u8 , 53u8 , 254u8 , 107u8 , 134u8 , 122u8 , 95u8 , 253u8 , 51u8 , 137u8 , 142u8 , 106u8 , 237u8 , 248u8 , 159u8 , 80u8 , 41u8 , 233u8 , 137u8 , 133u8 , 13u8 , 217u8 , 176u8 , 88u8 , 132u8 , 199u8 , 241u8 , 47u8 , 125u8 , 27u8 ,]) } # [doc = " The current slot of this block."] # [doc = ""] # [doc = " This will be set in `on_initialize`."] pub fn current_slot (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: current_slot :: CurrentSlot , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Aura" , "CurrentSlot" , () , [112u8 , 199u8 , 115u8 , 248u8 , 217u8 , 242u8 , 45u8 , 231u8 , 178u8 , 53u8 , 236u8 , 167u8 , 219u8 , 238u8 , 81u8 , 243u8 , 39u8 , 140u8 , 68u8 , 19u8 , 201u8 , 169u8 , 211u8 , 133u8 , 135u8 , 213u8 , 150u8 , 105u8 , 60u8 , 252u8 , 43u8 , 57u8 ,]) } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi ; impl ConstantsApi { # [doc = " The slot duration Aura should run with, expressed in milliseconds."] # [doc = " The effective value of this type should not change while the chain is running."] # [doc = ""] # [doc = " For backwards compatibility either use [`MinimumPeriodTimesTwo`] or a const."] pub fn slot_duration (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u64 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Aura" , "SlotDuration" , [128u8 , 214u8 , 205u8 , 242u8 , 181u8 , 142u8 , 124u8 , 231u8 , 190u8 , 146u8 , 59u8 , 226u8 , 157u8 , 101u8 , 103u8 , 117u8 , 249u8 , 65u8 , 18u8 , 191u8 , 103u8 , 119u8 , 53u8 , 85u8 , 81u8 , 96u8 , 220u8 , 42u8 , 184u8 , 239u8 , 42u8 , 246u8 ,]) } } } } pub mod grandpa { use super :: root_mod ; use super :: runtime_types ; # [doc = "The `Error` enum of this pallet."] pub type Error = runtime_types :: pallet_grandpa :: pallet :: Error ; # [doc = "Contains a variant per dispatchable extrinsic that this pallet has."] pub type Call = runtime_types :: pallet_grandpa :: pallet :: Call ; pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; pub mod types { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Report voter equivocation/misbehavior. This method will verify the"] # [doc = "equivocation proof and validate the given key ownership proof"] # [doc = "against the extracted offender. If both are valid, the offence"] # [doc = "will be reported."] pub struct ReportEquivocation { pub equivocation_proof : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < report_equivocation :: EquivocationProof > , pub key_owner_proof : report_equivocation :: KeyOwnerProof , } pub mod report_equivocation { use super :: runtime_types ; pub type EquivocationProof = runtime_types :: sp_consensus_grandpa :: EquivocationProof < :: subxt :: ext :: subxt_core :: utils :: H256 , :: core :: primitive :: u32 > ; pub type KeyOwnerProof = runtime_types :: sp_core :: Void ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for ReportEquivocation { const PALLET : & 'static str = "Grandpa" ; const CALL : & 'static str = "report_equivocation" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Report voter equivocation/misbehavior. This method will verify the"] # [doc = "equivocation proof and validate the given key ownership proof"] # [doc = "against the extracted offender. If both are valid, the offence"] # [doc = "will be reported."] # [doc = ""] # [doc = "This extrinsic must be called unsigned and it is expected that only"] # [doc = "block authors will call it (validated in `ValidateUnsigned`), as such"] # [doc = "if the block author is defined it will be defined as the equivocation"] # [doc = "reporter."] pub struct ReportEquivocationUnsigned { pub equivocation_proof : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < report_equivocation_unsigned :: EquivocationProof > , pub key_owner_proof : report_equivocation_unsigned :: KeyOwnerProof , } pub mod report_equivocation_unsigned { use super :: runtime_types ; pub type EquivocationProof = runtime_types :: sp_consensus_grandpa :: EquivocationProof < :: subxt :: ext :: subxt_core :: utils :: H256 , :: core :: primitive :: u32 > ; pub type KeyOwnerProof = runtime_types :: sp_core :: Void ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for ReportEquivocationUnsigned { const PALLET : & 'static str = "Grandpa" ; const CALL : & 'static str = "report_equivocation_unsigned" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Note that the current authority set of the GRANDPA finality gadget has stalled."] # [doc = ""] # [doc = "This will trigger a forced authority set change at the beginning of the next session, to"] # [doc = "be enacted `delay` blocks after that. The `delay` should be high enough to safely assume"] # [doc = "that the block signalling the forced change will not be re-orged e.g. 1000 blocks."] # [doc = "The block production rate (which may be slowed down because of finality lagging) should"] # [doc = "be taken into account when choosing the `delay`. The GRANDPA voters based on the new"] # [doc = "authority will start voting on top of `best_finalized_block_number` for new finalized"] # [doc = "blocks. `best_finalized_block_number` should be the highest of the latest finalized"] # [doc = "block of all validators of the new authority set."] # [doc = ""] # [doc = "Only callable by root."] pub struct NoteStalled { pub delay : note_stalled :: Delay , pub best_finalized_block_number : note_stalled :: BestFinalizedBlockNumber , } pub mod note_stalled { use super :: runtime_types ; pub type Delay = :: core :: primitive :: u32 ; pub type BestFinalizedBlockNumber = :: core :: primitive :: u32 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for NoteStalled { const PALLET : & 'static str = "Grandpa" ; const CALL : & 'static str = "note_stalled" ; } } pub struct TransactionApi ; impl TransactionApi { # [doc = "Report voter equivocation/misbehavior. This method will verify the"] # [doc = "equivocation proof and validate the given key ownership proof"] # [doc = "against the extracted offender. If both are valid, the offence"] # [doc = "will be reported."] pub fn report_equivocation (& self , equivocation_proof : types :: report_equivocation :: EquivocationProof , key_owner_proof : types :: report_equivocation :: KeyOwnerProof ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: ReportEquivocation > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Grandpa" , "report_equivocation" , types :: ReportEquivocation { equivocation_proof : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box :: new (equivocation_proof) , key_owner_proof , } , [187u8 , 224u8 , 115u8 , 5u8 , 236u8 , 32u8 , 180u8 , 155u8 , 218u8 , 109u8 , 238u8 , 253u8 , 30u8 , 225u8 , 4u8 , 225u8 , 132u8 , 232u8 , 243u8 , 54u8 , 56u8 , 158u8 , 94u8 , 192u8 , 94u8 , 206u8 , 189u8 , 61u8 , 14u8 , 49u8 , 48u8 , 131u8 ,]) } # [doc = "Report voter equivocation/misbehavior. This method will verify the"] # [doc = "equivocation proof and validate the given key ownership proof"] # [doc = "against the extracted offender. If both are valid, the offence"] # [doc = "will be reported."] # [doc = ""] # [doc = "This extrinsic must be called unsigned and it is expected that only"] # [doc = "block authors will call it (validated in `ValidateUnsigned`), as such"] # [doc = "if the block author is defined it will be defined as the equivocation"] # [doc = "reporter."] pub fn report_equivocation_unsigned (& self , equivocation_proof : types :: report_equivocation_unsigned :: EquivocationProof , key_owner_proof : types :: report_equivocation_unsigned :: KeyOwnerProof ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: ReportEquivocationUnsigned > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Grandpa" , "report_equivocation_unsigned" , types :: ReportEquivocationUnsigned { equivocation_proof : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box :: new (equivocation_proof) , key_owner_proof , } , [98u8 , 103u8 , 6u8 , 54u8 , 0u8 , 200u8 , 166u8 , 163u8 , 202u8 , 45u8 , 131u8 , 226u8 , 114u8 , 166u8 , 237u8 , 174u8 , 207u8 , 214u8 , 2u8 , 227u8 , 32u8 , 166u8 , 47u8 , 83u8 , 166u8 , 239u8 , 232u8 , 72u8 , 224u8 , 242u8 , 156u8 , 44u8 ,]) } # [doc = "Note that the current authority set of the GRANDPA finality gadget has stalled."] # [doc = ""] # [doc = "This will trigger a forced authority set change at the beginning of the next session, to"] # [doc = "be enacted `delay` blocks after that. The `delay` should be high enough to safely assume"] # [doc = "that the block signalling the forced change will not be re-orged e.g. 1000 blocks."] # [doc = "The block production rate (which may be slowed down because of finality lagging) should"] # [doc = "be taken into account when choosing the `delay`. The GRANDPA voters based on the new"] # [doc = "authority will start voting on top of `best_finalized_block_number` for new finalized"] # [doc = "blocks. `best_finalized_block_number` should be the highest of the latest finalized"] # [doc = "block of all validators of the new authority set."] # [doc = ""] # [doc = "Only callable by root."] pub fn note_stalled (& self , delay : types :: note_stalled :: Delay , best_finalized_block_number : types :: note_stalled :: BestFinalizedBlockNumber ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: NoteStalled > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Grandpa" , "note_stalled" , types :: NoteStalled { delay , best_finalized_block_number , } , [158u8 , 25u8 , 64u8 , 114u8 , 131u8 , 139u8 , 227u8 , 132u8 , 42u8 , 107u8 , 40u8 , 249u8 , 18u8 , 93u8 , 254u8 , 86u8 , 37u8 , 67u8 , 250u8 , 35u8 , 241u8 , 194u8 , 209u8 , 20u8 , 39u8 , 75u8 , 186u8 , 21u8 , 48u8 , 124u8 , 151u8 , 31u8 ,]) } } } # [doc = "The `Event` enum of this pallet"] pub type Event = runtime_types :: pallet_grandpa :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "New authority set has been applied."] pub struct NewAuthorities { pub authority_set : new_authorities :: AuthoritySet , } pub mod new_authorities { use super :: runtime_types ; pub type AuthoritySet = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < (runtime_types :: sp_consensus_grandpa :: app :: Public , :: core :: primitive :: u64 ,) > ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for NewAuthorities { const PALLET : & 'static str = "Grandpa" ; const EVENT : & 'static str = "NewAuthorities" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Current authority set has been paused."] pub struct Paused ; impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Paused { const PALLET : & 'static str = "Grandpa" ; const EVENT : & 'static str = "Paused" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Current authority set has been resumed."] pub struct Resumed ; impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Resumed { const PALLET : & 'static str = "Grandpa" ; const EVENT : & 'static str = "Resumed" ; } } pub mod storage { use super :: runtime_types ; pub mod types { use super :: runtime_types ; pub mod state { use super :: runtime_types ; pub type State = runtime_types :: pallet_grandpa :: StoredState < :: core :: primitive :: u32 > ; } pub mod pending_change { use super :: runtime_types ; pub type PendingChange = runtime_types :: pallet_grandpa :: StoredPendingChange < :: core :: primitive :: u32 > ; } pub mod next_forced { use super :: runtime_types ; pub type NextForced = :: core :: primitive :: u32 ; } pub mod stalled { use super :: runtime_types ; pub type Stalled = (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) ; } pub mod current_set_id { use super :: runtime_types ; pub type CurrentSetId = :: core :: primitive :: u64 ; } pub mod set_id_session { use super :: runtime_types ; pub type SetIdSession = :: core :: primitive :: u32 ; pub type Param0 = :: core :: primitive :: u64 ; } pub mod authorities { use super :: runtime_types ; pub type Authorities = runtime_types :: bounded_collections :: weak_bounded_vec :: WeakBoundedVec < (runtime_types :: sp_consensus_grandpa :: app :: Public , :: core :: primitive :: u64 ,) > ; } } pub struct StorageApi ; impl StorageApi { # [doc = " State of the current authority set."] pub fn state (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: state :: State , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Grandpa" , "State" , () , [73u8 , 71u8 , 112u8 , 83u8 , 238u8 , 75u8 , 44u8 , 9u8 , 180u8 , 33u8 , 30u8 , 121u8 , 98u8 , 96u8 , 61u8 , 133u8 , 16u8 , 70u8 , 30u8 , 249u8 , 34u8 , 148u8 , 15u8 , 239u8 , 164u8 , 157u8 , 52u8 , 27u8 , 144u8 , 52u8 , 223u8 , 109u8 ,]) } # [doc = " Pending change: (signaled at, scheduled change)."] pub fn pending_change (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: pending_change :: PendingChange , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Grandpa" , "PendingChange" , () , [32u8 , 165u8 , 141u8 , 100u8 , 109u8 , 66u8 , 58u8 , 22u8 , 118u8 , 84u8 , 92u8 , 164u8 , 119u8 , 130u8 , 104u8 , 25u8 , 244u8 , 111u8 , 223u8 , 54u8 , 184u8 , 95u8 , 196u8 , 30u8 , 244u8 , 129u8 , 110u8 , 127u8 , 200u8 , 66u8 , 226u8 , 26u8 ,]) } # [doc = " next block number where we can force a change."] pub fn next_forced (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: next_forced :: NextForced , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Grandpa" , "NextForced" , () , [3u8 , 231u8 , 56u8 , 18u8 , 87u8 , 112u8 , 227u8 , 126u8 , 180u8 , 131u8 , 255u8 , 141u8 , 82u8 , 34u8 , 61u8 , 47u8 , 234u8 , 37u8 , 95u8 , 62u8 , 33u8 , 235u8 , 231u8 , 122u8 , 125u8 , 8u8 , 223u8 , 95u8 , 255u8 , 204u8 , 40u8 , 97u8 ,]) } # [doc = " `true` if we are currently stalled."] pub fn stalled (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: stalled :: Stalled , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Grandpa" , "Stalled" , () , [6u8 , 81u8 , 205u8 , 142u8 , 195u8 , 48u8 , 0u8 , 247u8 , 108u8 , 170u8 , 10u8 , 249u8 , 72u8 , 206u8 , 32u8 , 103u8 , 109u8 , 57u8 , 51u8 , 21u8 , 144u8 , 204u8 , 79u8 , 8u8 , 191u8 , 185u8 , 38u8 , 34u8 , 118u8 , 223u8 , 75u8 , 241u8 ,]) } # [doc = " The number of changes (both in terms of keys and underlying economic responsibilities)"] # [doc = " in the \"set\" of Grandpa validators from genesis."] pub fn current_set_id (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: current_set_id :: CurrentSetId , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Grandpa" , "CurrentSetId" , () , [234u8 , 215u8 , 218u8 , 42u8 , 30u8 , 76u8 , 129u8 , 40u8 , 125u8 , 137u8 , 207u8 , 47u8 , 46u8 , 213u8 , 159u8 , 50u8 , 175u8 , 81u8 , 155u8 , 123u8 , 246u8 , 175u8 , 156u8 , 68u8 , 22u8 , 113u8 , 135u8 , 137u8 , 163u8 , 18u8 , 115u8 , 73u8 ,]) } # [doc = " A mapping from grandpa set ID to the index of the *most recent* session for which its"] # [doc = " members were responsible."] # [doc = ""] # [doc = " This is only used for validating equivocation proofs. An equivocation proof must"] # [doc = " contains a key-ownership proof for a given session, therefore we need a way to tie"] # [doc = " together sessions and GRANDPA set ids, i.e. we need to validate that a validator"] # [doc = " was the owner of a given key on a given session, and what the active set ID was"] # [doc = " during that session."] # [doc = ""] # [doc = " TWOX-NOTE: `SetId` is not under user control."] pub fn set_id_session_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: set_id_session :: SetIdSession , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Grandpa" , "SetIdSession" , () , [47u8 , 0u8 , 239u8 , 121u8 , 187u8 , 213u8 , 254u8 , 50u8 , 238u8 , 10u8 , 162u8 , 65u8 , 189u8 , 166u8 , 37u8 , 74u8 , 82u8 , 81u8 , 160u8 , 20u8 , 180u8 , 253u8 , 238u8 , 18u8 , 209u8 , 203u8 , 38u8 , 148u8 , 16u8 , 105u8 , 72u8 , 169u8 ,]) } # [doc = " A mapping from grandpa set ID to the index of the *most recent* session for which its"] # [doc = " members were responsible."] # [doc = ""] # [doc = " This is only used for validating equivocation proofs. An equivocation proof must"] # [doc = " contains a key-ownership proof for a given session, therefore we need a way to tie"] # [doc = " together sessions and GRANDPA set ids, i.e. we need to validate that a validator"] # [doc = " was the owner of a given key on a given session, and what the active set ID was"] # [doc = " during that session."] # [doc = ""] # [doc = " TWOX-NOTE: `SetId` is not under user control."] pub fn set_id_session (& self , _0 : impl :: core :: borrow :: Borrow < types :: set_id_session :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: set_id_session :: Param0 > , types :: set_id_session :: SetIdSession , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Grandpa" , "SetIdSession" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [47u8 , 0u8 , 239u8 , 121u8 , 187u8 , 213u8 , 254u8 , 50u8 , 238u8 , 10u8 , 162u8 , 65u8 , 189u8 , 166u8 , 37u8 , 74u8 , 82u8 , 81u8 , 160u8 , 20u8 , 180u8 , 253u8 , 238u8 , 18u8 , 209u8 , 203u8 , 38u8 , 148u8 , 16u8 , 105u8 , 72u8 , 169u8 ,]) } # [doc = " The current list of authorities."] pub fn authorities (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: authorities :: Authorities , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Grandpa" , "Authorities" , () , [192u8 , 157u8 , 98u8 , 244u8 , 104u8 , 38u8 , 195u8 , 114u8 , 183u8 , 62u8 , 247u8 , 18u8 , 31u8 , 152u8 , 246u8 , 206u8 , 97u8 , 13u8 , 118u8 , 211u8 , 104u8 , 54u8 , 150u8 , 152u8 , 126u8 , 170u8 , 228u8 , 158u8 , 108u8 , 129u8 , 134u8 , 44u8 ,]) } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi ; impl ConstantsApi { # [doc = " Max Authorities in use"] pub fn max_authorities (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u32 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Grandpa" , "MaxAuthorities" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " The maximum number of nominators for each validator."] pub fn max_nominators (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u32 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Grandpa" , "MaxNominators" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " The maximum number of entries to keep in the set id to session index mapping."] # [doc = ""] # [doc = " Since the `SetIdSession` map is only used for validating equivocations this"] # [doc = " value should relate to the bonding duration of whatever staking system is"] # [doc = " being used (if any). If equivocation handling is not enabled then this value"] # [doc = " can be zero."] pub fn max_set_id_session_entries (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u64 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Grandpa" , "MaxSetIdSessionEntries" , [128u8 , 214u8 , 205u8 , 242u8 , 181u8 , 142u8 , 124u8 , 231u8 , 190u8 , 146u8 , 59u8 , 226u8 , 157u8 , 101u8 , 103u8 , 117u8 , 249u8 , 65u8 , 18u8 , 191u8 , 103u8 , 119u8 , 53u8 , 85u8 , 81u8 , 96u8 , 220u8 , 42u8 , 184u8 , 239u8 , 42u8 , 246u8 ,]) } } } } pub mod balances { use super :: root_mod ; use super :: runtime_types ; # [doc = "The `Error` enum of this pallet."] pub type Error = runtime_types :: pallet_balances :: pallet :: Error ; # [doc = "Contains a variant per dispatchable extrinsic that this pallet has."] pub type Call = runtime_types :: pallet_balances :: pallet :: Call ; pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; pub mod types { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Transfer some liquid free balance to another account."] # [doc = ""] # [doc = "`transfer_allow_death` will set the `FreeBalance` of the sender and receiver."] # [doc = "If the sender's account is below the existential deposit as a result"] # [doc = "of the transfer, the account will be reaped."] # [doc = ""] # [doc = "The dispatch origin for this call must be `Signed` by the transactor."] pub struct TransferAllowDeath { pub dest : transfer_allow_death :: Dest , # [codec (compact)] pub value : transfer_allow_death :: Value , } pub mod transfer_allow_death { use super :: runtime_types ; pub type Dest = :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > ; pub type Value = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for TransferAllowDeath { const PALLET : & 'static str = "Balances" ; const CALL : & 'static str = "transfer_allow_death" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Exactly as `transfer_allow_death`, except the origin must be root and the source account"] # [doc = "may be specified."] pub struct ForceTransfer { pub source : force_transfer :: Source , pub dest : force_transfer :: Dest , # [codec (compact)] pub value : force_transfer :: Value , } pub mod force_transfer { use super :: runtime_types ; pub type Source = :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > ; pub type Dest = :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > ; pub type Value = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for ForceTransfer { const PALLET : & 'static str = "Balances" ; const CALL : & 'static str = "force_transfer" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Same as the [`transfer_allow_death`] call, but with a check that the transfer will not"] # [doc = "kill the origin account."] # [doc = ""] # [doc = "99% of the time you want [`transfer_allow_death`] instead."] # [doc = ""] # [doc = "[`transfer_allow_death`]: struct.Pallet.html#method.transfer"] pub struct TransferKeepAlive { pub dest : transfer_keep_alive :: Dest , # [codec (compact)] pub value : transfer_keep_alive :: Value , } pub mod transfer_keep_alive { use super :: runtime_types ; pub type Dest = :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > ; pub type Value = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for TransferKeepAlive { const PALLET : & 'static str = "Balances" ; const CALL : & 'static str = "transfer_keep_alive" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Transfer the entire transferable balance from the caller account."] # [doc = ""] # [doc = "NOTE: This function only attempts to transfer _transferable_ balances. This means that"] # [doc = "any locked, reserved, or existential deposits (when `keep_alive` is `true`), will not be"] # [doc = "transferred by this function. To ensure that this function results in a killed account,"] # [doc = "you might need to prepare the account by removing any reference counters, storage"] # [doc = "deposits, etc..."] # [doc = ""] # [doc = "The dispatch origin of this call must be Signed."] # [doc = ""] # [doc = "- `dest`: The recipient of the transfer."] # [doc = "- `keep_alive`: A boolean to determine if the `transfer_all` operation should send all"] # [doc = "  of the funds the account has, causing the sender account to be killed (false), or"] # [doc = "  transfer everything except at least the existential deposit, which will guarantee to"] # [doc = "  keep the sender account alive (true)."] pub struct TransferAll { pub dest : transfer_all :: Dest , pub keep_alive : transfer_all :: KeepAlive , } pub mod transfer_all { use super :: runtime_types ; pub type Dest = :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > ; pub type KeepAlive = :: core :: primitive :: bool ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for TransferAll { const PALLET : & 'static str = "Balances" ; const CALL : & 'static str = "transfer_all" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Unreserve some balance from a user by force."] # [doc = ""] # [doc = "Can only be called by ROOT."] pub struct ForceUnreserve { pub who : force_unreserve :: Who , pub amount : force_unreserve :: Amount , } pub mod force_unreserve { use super :: runtime_types ; pub type Who = :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > ; pub type Amount = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for ForceUnreserve { const PALLET : & 'static str = "Balances" ; const CALL : & 'static str = "force_unreserve" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Upgrade a specified account."] # [doc = ""] # [doc = "- `origin`: Must be `Signed`."] # [doc = "- `who`: The account to be upgraded."] # [doc = ""] # [doc = "This will waive the transaction fee if at least all but 10% of the accounts needed to"] # [doc = "be upgraded. (We let some not have to be upgraded just in order to allow for the"] # [doc = "possibility of churn)."] pub struct UpgradeAccounts { pub who : upgrade_accounts :: Who , } pub mod upgrade_accounts { use super :: runtime_types ; pub type Who = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: subxt :: ext :: subxt_core :: utils :: AccountId32 > ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for UpgradeAccounts { const PALLET : & 'static str = "Balances" ; const CALL : & 'static str = "upgrade_accounts" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Set the regular balance of a given account."] # [doc = ""] # [doc = "The dispatch origin for this call is `root`."] pub struct ForceSetBalance { pub who : force_set_balance :: Who , # [codec (compact)] pub new_free : force_set_balance :: NewFree , } pub mod force_set_balance { use super :: runtime_types ; pub type Who = :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > ; pub type NewFree = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for ForceSetBalance { const PALLET : & 'static str = "Balances" ; const CALL : & 'static str = "force_set_balance" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Adjust the total issuance in a saturating way."] # [doc = ""] # [doc = "Can only be called by root and always needs a positive `delta`."] # [doc = ""] # [doc = "# Example"] pub struct ForceAdjustTotalIssuance { pub direction : force_adjust_total_issuance :: Direction , # [codec (compact)] pub delta : force_adjust_total_issuance :: Delta , } pub mod force_adjust_total_issuance { use super :: runtime_types ; pub type Direction = runtime_types :: pallet_balances :: types :: AdjustmentDirection ; pub type Delta = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for ForceAdjustTotalIssuance { const PALLET : & 'static str = "Balances" ; const CALL : & 'static str = "force_adjust_total_issuance" ; } } pub struct TransactionApi ; impl TransactionApi { # [doc = "Transfer some liquid free balance to another account."] # [doc = ""] # [doc = "`transfer_allow_death` will set the `FreeBalance` of the sender and receiver."] # [doc = "If the sender's account is below the existential deposit as a result"] # [doc = "of the transfer, the account will be reaped."] # [doc = ""] # [doc = "The dispatch origin for this call must be `Signed` by the transactor."] pub fn transfer_allow_death (& self , dest : types :: transfer_allow_death :: Dest , value : types :: transfer_allow_death :: Value ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: TransferAllowDeath > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Balances" , "transfer_allow_death" , types :: TransferAllowDeath { dest , value , } , [55u8 , 189u8 , 102u8 , 71u8 , 231u8 , 179u8 , 169u8 , 229u8 , 206u8 , 42u8 , 10u8 , 117u8 , 36u8 , 34u8 , 30u8 , 145u8 , 227u8 , 105u8 , 252u8 , 188u8 , 162u8 , 0u8 , 84u8 , 24u8 , 123u8 , 241u8 , 152u8 , 118u8 , 181u8 , 182u8 , 137u8 , 241u8 ,]) } # [doc = "Exactly as `transfer_allow_death`, except the origin must be root and the source account"] # [doc = "may be specified."] pub fn force_transfer (& self , source : types :: force_transfer :: Source , dest : types :: force_transfer :: Dest , value : types :: force_transfer :: Value ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: ForceTransfer > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Balances" , "force_transfer" , types :: ForceTransfer { source , dest , value , } , [15u8 , 9u8 , 232u8 , 170u8 , 117u8 , 161u8 , 184u8 , 255u8 , 3u8 , 155u8 , 165u8 , 226u8 , 151u8 , 189u8 , 226u8 , 21u8 , 14u8 , 70u8 , 17u8 , 43u8 , 181u8 , 59u8 , 158u8 , 222u8 , 167u8 , 59u8 , 61u8 , 233u8 , 78u8 , 108u8 , 161u8 , 192u8 ,]) } # [doc = "Same as the [`transfer_allow_death`] call, but with a check that the transfer will not"] # [doc = "kill the origin account."] # [doc = ""] # [doc = "99% of the time you want [`transfer_allow_death`] instead."] # [doc = ""] # [doc = "[`transfer_allow_death`]: struct.Pallet.html#method.transfer"] pub fn transfer_keep_alive (& self , dest : types :: transfer_keep_alive :: Dest , value : types :: transfer_keep_alive :: Value ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: TransferKeepAlive > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Balances" , "transfer_keep_alive" , types :: TransferKeepAlive { dest , value , } , [126u8 , 208u8 , 16u8 , 244u8 , 94u8 , 74u8 , 166u8 , 13u8 , 149u8 , 95u8 , 88u8 , 250u8 , 95u8 , 0u8 , 43u8 , 57u8 , 18u8 , 129u8 , 24u8 , 210u8 , 91u8 , 50u8 , 251u8 , 73u8 , 126u8 , 218u8 , 244u8 , 52u8 , 36u8 , 175u8 , 28u8 , 210u8 ,]) } # [doc = "Transfer the entire transferable balance from the caller account."] # [doc = ""] # [doc = "NOTE: This function only attempts to transfer _transferable_ balances. This means that"] # [doc = "any locked, reserved, or existential deposits (when `keep_alive` is `true`), will not be"] # [doc = "transferred by this function. To ensure that this function results in a killed account,"] # [doc = "you might need to prepare the account by removing any reference counters, storage"] # [doc = "deposits, etc..."] # [doc = ""] # [doc = "The dispatch origin of this call must be Signed."] # [doc = ""] # [doc = "- `dest`: The recipient of the transfer."] # [doc = "- `keep_alive`: A boolean to determine if the `transfer_all` operation should send all"] # [doc = "  of the funds the account has, causing the sender account to be killed (false), or"] # [doc = "  transfer everything except at least the existential deposit, which will guarantee to"] # [doc = "  keep the sender account alive (true)."] pub fn transfer_all (& self , dest : types :: transfer_all :: Dest , keep_alive : types :: transfer_all :: KeepAlive ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: TransferAll > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Balances" , "transfer_all" , types :: TransferAll { dest , keep_alive , } , [105u8 , 132u8 , 49u8 , 144u8 , 195u8 , 250u8 , 34u8 , 46u8 , 213u8 , 248u8 , 112u8 , 188u8 , 81u8 , 228u8 , 136u8 , 18u8 , 67u8 , 172u8 , 37u8 , 38u8 , 238u8 , 9u8 , 34u8 , 15u8 , 67u8 , 34u8 , 148u8 , 195u8 , 223u8 , 29u8 , 154u8 , 6u8 ,]) } # [doc = "Unreserve some balance from a user by force."] # [doc = ""] # [doc = "Can only be called by ROOT."] pub fn force_unreserve (& self , who : types :: force_unreserve :: Who , amount : types :: force_unreserve :: Amount ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: ForceUnreserve > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Balances" , "force_unreserve" , types :: ForceUnreserve { who , amount , } , [194u8 , 160u8 , 176u8 , 186u8 , 10u8 , 132u8 , 201u8 , 232u8 , 127u8 , 9u8 , 234u8 , 37u8 , 167u8 , 77u8 , 157u8 , 228u8 , 62u8 , 207u8 , 172u8 , 240u8 , 1u8 , 10u8 , 136u8 , 97u8 , 115u8 , 13u8 , 2u8 , 61u8 , 200u8 , 235u8 , 39u8 , 97u8 ,]) } # [doc = "Upgrade a specified account."] # [doc = ""] # [doc = "- `origin`: Must be `Signed`."] # [doc = "- `who`: The account to be upgraded."] # [doc = ""] # [doc = "This will waive the transaction fee if at least all but 10% of the accounts needed to"] # [doc = "be upgraded. (We let some not have to be upgraded just in order to allow for the"] # [doc = "possibility of churn)."] pub fn upgrade_accounts (& self , who : types :: upgrade_accounts :: Who ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: UpgradeAccounts > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Balances" , "upgrade_accounts" , types :: UpgradeAccounts { who , } , [66u8 , 200u8 , 179u8 , 104u8 , 65u8 , 2u8 , 101u8 , 56u8 , 130u8 , 161u8 , 224u8 , 233u8 , 255u8 , 124u8 , 70u8 , 122u8 , 8u8 , 49u8 , 103u8 , 178u8 , 68u8 , 47u8 , 214u8 , 166u8 , 217u8 , 116u8 , 178u8 , 50u8 , 212u8 , 164u8 , 98u8 , 226u8 ,]) } # [doc = "Set the regular balance of a given account."] # [doc = ""] # [doc = "The dispatch origin for this call is `root`."] pub fn force_set_balance (& self , who : types :: force_set_balance :: Who , new_free : types :: force_set_balance :: NewFree ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: ForceSetBalance > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Balances" , "force_set_balance" , types :: ForceSetBalance { who , new_free , } , [172u8 , 128u8 , 27u8 , 158u8 , 43u8 , 74u8 , 29u8 , 195u8 , 16u8 , 214u8 , 1u8 , 128u8 , 138u8 , 144u8 , 6u8 , 236u8 , 61u8 , 41u8 , 155u8 , 208u8 , 57u8 , 42u8 , 237u8 , 229u8 , 130u8 , 214u8 , 8u8 , 93u8 , 57u8 , 219u8 , 178u8 , 197u8 ,]) } # [doc = "Adjust the total issuance in a saturating way."] # [doc = ""] # [doc = "Can only be called by root and always needs a positive `delta`."] # [doc = ""] # [doc = "# Example"] pub fn force_adjust_total_issuance (& self , direction : types :: force_adjust_total_issuance :: Direction , delta : types :: force_adjust_total_issuance :: Delta ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: ForceAdjustTotalIssuance > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Balances" , "force_adjust_total_issuance" , types :: ForceAdjustTotalIssuance { direction , delta , } , [70u8 , 239u8 , 219u8 , 254u8 , 5u8 , 227u8 , 119u8 , 182u8 , 85u8 , 96u8 , 88u8 , 71u8 , 89u8 , 73u8 , 199u8 , 50u8 , 89u8 , 157u8 , 30u8 , 121u8 , 34u8 , 184u8 , 9u8 , 118u8 , 51u8 , 182u8 , 121u8 , 109u8 , 22u8 , 155u8 , 83u8 , 198u8 ,]) } } } # [doc = "The `Event` enum of this pallet"] pub type Event = runtime_types :: pallet_balances :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "An account was created with some free balance."] pub struct Endowed { pub account : endowed :: Account , pub free_balance : endowed :: FreeBalance , } pub mod endowed { use super :: runtime_types ; pub type Account = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type FreeBalance = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Endowed { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "Endowed" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "An account was removed whose balance was non-zero but below ExistentialDeposit,"] # [doc = "resulting in an outright loss."] pub struct DustLost { pub account : dust_lost :: Account , pub amount : dust_lost :: Amount , } pub mod dust_lost { use super :: runtime_types ; pub type Account = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Amount = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for DustLost { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "DustLost" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Transfer succeeded."] pub struct Transfer { pub from : transfer :: From , pub to : transfer :: To , pub amount : transfer :: Amount , } pub mod transfer { use super :: runtime_types ; pub type From = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type To = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Amount = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Transfer { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "Transfer" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "A balance was set by root."] pub struct BalanceSet { pub who : balance_set :: Who , pub free : balance_set :: Free , } pub mod balance_set { use super :: runtime_types ; pub type Who = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Free = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for BalanceSet { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "BalanceSet" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Some balance was reserved (moved from free to reserved)."] pub struct Reserved { pub who : reserved :: Who , pub amount : reserved :: Amount , } pub mod reserved { use super :: runtime_types ; pub type Who = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Amount = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Reserved { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "Reserved" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Some balance was unreserved (moved from reserved to free)."] pub struct Unreserved { pub who : unreserved :: Who , pub amount : unreserved :: Amount , } pub mod unreserved { use super :: runtime_types ; pub type Who = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Amount = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Unreserved { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "Unreserved" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Some balance was moved from the reserve of the first account to the second account."] # [doc = "Final argument indicates the destination balance type."] pub struct ReserveRepatriated { pub from : reserve_repatriated :: From , pub to : reserve_repatriated :: To , pub amount : reserve_repatriated :: Amount , pub destination_status : reserve_repatriated :: DestinationStatus , } pub mod reserve_repatriated { use super :: runtime_types ; pub type From = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type To = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Amount = :: core :: primitive :: u64 ; pub type DestinationStatus = runtime_types :: frame_support :: traits :: tokens :: misc :: BalanceStatus ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for ReserveRepatriated { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "ReserveRepatriated" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Some amount was deposited (e.g. for transaction fees)."] pub struct Deposit { pub who : deposit :: Who , pub amount : deposit :: Amount , } pub mod deposit { use super :: runtime_types ; pub type Who = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Amount = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Deposit { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "Deposit" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Some amount was withdrawn from the account (e.g. for transaction fees)."] pub struct Withdraw { pub who : withdraw :: Who , pub amount : withdraw :: Amount , } pub mod withdraw { use super :: runtime_types ; pub type Who = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Amount = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Withdraw { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "Withdraw" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Some amount was removed from the account (e.g. for misbehavior)."] pub struct Slashed { pub who : slashed :: Who , pub amount : slashed :: Amount , } pub mod slashed { use super :: runtime_types ; pub type Who = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Amount = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Slashed { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "Slashed" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Some amount was minted into an account."] pub struct Minted { pub who : minted :: Who , pub amount : minted :: Amount , } pub mod minted { use super :: runtime_types ; pub type Who = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Amount = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Minted { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "Minted" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Some amount was burned from an account."] pub struct Burned { pub who : burned :: Who , pub amount : burned :: Amount , } pub mod burned { use super :: runtime_types ; pub type Who = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Amount = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Burned { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "Burned" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Some amount was suspended from an account (it can be restored later)."] pub struct Suspended { pub who : suspended :: Who , pub amount : suspended :: Amount , } pub mod suspended { use super :: runtime_types ; pub type Who = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Amount = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Suspended { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "Suspended" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Some amount was restored into an account."] pub struct Restored { pub who : restored :: Who , pub amount : restored :: Amount , } pub mod restored { use super :: runtime_types ; pub type Who = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Amount = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Restored { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "Restored" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "An account was upgraded."] pub struct Upgraded { pub who : upgraded :: Who , } pub mod upgraded { use super :: runtime_types ; pub type Who = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Upgraded { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "Upgraded" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Total issuance was increased by `amount`, creating a credit to be balanced."] pub struct Issued { pub amount : issued :: Amount , } pub mod issued { use super :: runtime_types ; pub type Amount = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Issued { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "Issued" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Total issuance was decreased by `amount`, creating a debt to be balanced."] pub struct Rescinded { pub amount : rescinded :: Amount , } pub mod rescinded { use super :: runtime_types ; pub type Amount = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Rescinded { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "Rescinded" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Some balance was locked."] pub struct Locked { pub who : locked :: Who , pub amount : locked :: Amount , } pub mod locked { use super :: runtime_types ; pub type Who = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Amount = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Locked { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "Locked" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Some balance was unlocked."] pub struct Unlocked { pub who : unlocked :: Who , pub amount : unlocked :: Amount , } pub mod unlocked { use super :: runtime_types ; pub type Who = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Amount = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Unlocked { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "Unlocked" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Some balance was frozen."] pub struct Frozen { pub who : frozen :: Who , pub amount : frozen :: Amount , } pub mod frozen { use super :: runtime_types ; pub type Who = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Amount = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Frozen { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "Frozen" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Some balance was thawed."] pub struct Thawed { pub who : thawed :: Who , pub amount : thawed :: Amount , } pub mod thawed { use super :: runtime_types ; pub type Who = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Amount = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Thawed { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "Thawed" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The `TotalIssuance` was forcefully changed."] pub struct TotalIssuanceForced { pub old : total_issuance_forced :: Old , pub new : total_issuance_forced :: New , } pub mod total_issuance_forced { use super :: runtime_types ; pub type Old = :: core :: primitive :: u64 ; pub type New = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for TotalIssuanceForced { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "TotalIssuanceForced" ; } } pub mod storage { use super :: runtime_types ; pub mod types { use super :: runtime_types ; pub mod total_issuance { use super :: runtime_types ; pub type TotalIssuance = :: core :: primitive :: u64 ; } pub mod inactive_issuance { use super :: runtime_types ; pub type InactiveIssuance = :: core :: primitive :: u64 ; } pub mod account { use super :: runtime_types ; pub type Account = runtime_types :: pallet_balances :: types :: AccountData < :: core :: primitive :: u64 > ; pub type Param0 = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } pub mod locks { use super :: runtime_types ; pub type Locks = runtime_types :: bounded_collections :: weak_bounded_vec :: WeakBoundedVec < runtime_types :: pallet_balances :: types :: BalanceLock < :: core :: primitive :: u64 > > ; pub type Param0 = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } pub mod reserves { use super :: runtime_types ; pub type Reserves = runtime_types :: bounded_collections :: bounded_vec :: BoundedVec < runtime_types :: pallet_balances :: types :: ReserveData < [:: core :: primitive :: u8 ; 8usize] , :: core :: primitive :: u64 > > ; pub type Param0 = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } pub mod holds { use super :: runtime_types ; pub type Holds = runtime_types :: bounded_collections :: bounded_vec :: BoundedVec < runtime_types :: pallet_balances :: types :: IdAmount < runtime_types :: node_subtensor_runtime :: RuntimeHoldReason , :: core :: primitive :: u64 > > ; pub type Param0 = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } pub mod freezes { use super :: runtime_types ; pub type Freezes = runtime_types :: bounded_collections :: bounded_vec :: BoundedVec < runtime_types :: pallet_balances :: types :: IdAmount < runtime_types :: node_subtensor_runtime :: RuntimeFreezeReason , :: core :: primitive :: u64 > > ; pub type Param0 = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } } pub struct StorageApi ; impl StorageApi { # [doc = " The total units issued in the system."] pub fn total_issuance (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: total_issuance :: TotalIssuance , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Balances" , "TotalIssuance" , () , [157u8 , 166u8 , 49u8 , 95u8 , 245u8 , 38u8 , 96u8 , 83u8 , 23u8 , 203u8 , 246u8 , 208u8 , 251u8 , 175u8 , 40u8 , 92u8 , 163u8 , 112u8 , 43u8 , 190u8 , 14u8 , 128u8 , 45u8 , 22u8 , 157u8 , 205u8 , 181u8 , 84u8 , 79u8 , 132u8 , 160u8 , 149u8 ,]) } # [doc = " The total units of outstanding deactivated balance in the system."] pub fn inactive_issuance (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: inactive_issuance :: InactiveIssuance , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Balances" , "InactiveIssuance" , () , [33u8 , 251u8 , 197u8 , 148u8 , 61u8 , 202u8 , 85u8 , 164u8 , 169u8 , 36u8 , 163u8 , 147u8 , 243u8 , 250u8 , 178u8 , 40u8 , 199u8 , 147u8 , 196u8 , 206u8 , 163u8 , 246u8 , 154u8 , 51u8 , 208u8 , 250u8 , 127u8 , 89u8 , 118u8 , 21u8 , 225u8 , 248u8 ,]) } # [doc = " The Balances pallet example of storing the balance of an account."] # [doc = ""] # [doc = " # Example"] # [doc = ""] # [doc = " ```nocompile"] # [doc = "  impl pallet_balances::Config for Runtime {"] # [doc = "    type AccountStore = StorageMapShim<Self::Account<Runtime>, frame_system::Provider<Runtime>, AccountId, Self::AccountData<Balance>>"] # [doc = "  }"] # [doc = " ```"] # [doc = ""] # [doc = " You can also store the balance of an account in the `System` pallet."] # [doc = ""] # [doc = " # Example"] # [doc = ""] # [doc = " ```nocompile"] # [doc = "  impl pallet_balances::Config for Runtime {"] # [doc = "   type AccountStore = System"] # [doc = "  }"] # [doc = " ```"] # [doc = ""] # [doc = " But this comes with tradeoffs, storing account balances in the system pallet stores"] # [doc = " `frame_system` data alongside the account data contrary to storing account balances in the"] # [doc = " `Balances` pallet, which uses a `StorageMap` to store balances data only."] # [doc = " NOTE: This is only used in the case that this pallet is used to store balances."] pub fn account_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: account :: Account , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Balances" , "Account" , () , [0u8 , 34u8 , 91u8 , 238u8 , 87u8 , 151u8 , 107u8 , 4u8 , 104u8 , 111u8 , 47u8 , 9u8 , 10u8 , 169u8 , 173u8 , 69u8 , 182u8 , 183u8 , 227u8 , 37u8 , 148u8 , 135u8 , 184u8 , 83u8 , 67u8 , 66u8 , 238u8 , 130u8 , 90u8 , 28u8 , 248u8 , 68u8 ,]) } # [doc = " The Balances pallet example of storing the balance of an account."] # [doc = ""] # [doc = " # Example"] # [doc = ""] # [doc = " ```nocompile"] # [doc = "  impl pallet_balances::Config for Runtime {"] # [doc = "    type AccountStore = StorageMapShim<Self::Account<Runtime>, frame_system::Provider<Runtime>, AccountId, Self::AccountData<Balance>>"] # [doc = "  }"] # [doc = " ```"] # [doc = ""] # [doc = " You can also store the balance of an account in the `System` pallet."] # [doc = ""] # [doc = " # Example"] # [doc = ""] # [doc = " ```nocompile"] # [doc = "  impl pallet_balances::Config for Runtime {"] # [doc = "   type AccountStore = System"] # [doc = "  }"] # [doc = " ```"] # [doc = ""] # [doc = " But this comes with tradeoffs, storing account balances in the system pallet stores"] # [doc = " `frame_system` data alongside the account data contrary to storing account balances in the"] # [doc = " `Balances` pallet, which uses a `StorageMap` to store balances data only."] # [doc = " NOTE: This is only used in the case that this pallet is used to store balances."] pub fn account (& self , _0 : impl :: core :: borrow :: Borrow < types :: account :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: account :: Param0 > , types :: account :: Account , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Balances" , "Account" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [0u8 , 34u8 , 91u8 , 238u8 , 87u8 , 151u8 , 107u8 , 4u8 , 104u8 , 111u8 , 47u8 , 9u8 , 10u8 , 169u8 , 173u8 , 69u8 , 182u8 , 183u8 , 227u8 , 37u8 , 148u8 , 135u8 , 184u8 , 83u8 , 67u8 , 66u8 , 238u8 , 130u8 , 90u8 , 28u8 , 248u8 , 68u8 ,]) } # [doc = " Any liquidity locks on some account balances."] # [doc = " NOTE: Should only be accessed when setting, changing and freeing a lock."] # [doc = ""] # [doc = " Use of locks is deprecated in favour of freezes. See `https://github.com/paritytech/substrate/pull/12951/`"] pub fn locks_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: locks :: Locks , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Balances" , "Locks" , () , [184u8 , 159u8 , 77u8 , 3u8 , 45u8 , 154u8 , 149u8 , 191u8 , 33u8 , 212u8 , 190u8 , 76u8 , 222u8 , 65u8 , 62u8 , 163u8 , 44u8 , 141u8 , 151u8 , 114u8 , 109u8 , 98u8 , 70u8 , 103u8 , 41u8 , 93u8 , 14u8 , 171u8 , 115u8 , 127u8 , 71u8 , 114u8 ,]) } # [doc = " Any liquidity locks on some account balances."] # [doc = " NOTE: Should only be accessed when setting, changing and freeing a lock."] # [doc = ""] # [doc = " Use of locks is deprecated in favour of freezes. See `https://github.com/paritytech/substrate/pull/12951/`"] pub fn locks (& self , _0 : impl :: core :: borrow :: Borrow < types :: locks :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: locks :: Param0 > , types :: locks :: Locks , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Balances" , "Locks" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [184u8 , 159u8 , 77u8 , 3u8 , 45u8 , 154u8 , 149u8 , 191u8 , 33u8 , 212u8 , 190u8 , 76u8 , 222u8 , 65u8 , 62u8 , 163u8 , 44u8 , 141u8 , 151u8 , 114u8 , 109u8 , 98u8 , 70u8 , 103u8 , 41u8 , 93u8 , 14u8 , 171u8 , 115u8 , 127u8 , 71u8 , 114u8 ,]) } # [doc = " Named reserves on some account balances."] # [doc = ""] # [doc = " Use of reserves is deprecated in favour of holds. See `https://github.com/paritytech/substrate/pull/12951/`"] pub fn reserves_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: reserves :: Reserves , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Balances" , "Reserves" , () , [229u8 , 249u8 , 203u8 , 167u8 , 55u8 , 45u8 , 194u8 , 217u8 , 66u8 , 155u8 , 16u8 , 204u8 , 106u8 , 207u8 , 49u8 , 127u8 , 193u8 , 192u8 , 147u8 , 242u8 , 31u8 , 220u8 , 137u8 , 8u8 , 247u8 , 96u8 , 175u8 , 28u8 , 246u8 , 50u8 , 254u8 , 222u8 ,]) } # [doc = " Named reserves on some account balances."] # [doc = ""] # [doc = " Use of reserves is deprecated in favour of holds. See `https://github.com/paritytech/substrate/pull/12951/`"] pub fn reserves (& self , _0 : impl :: core :: borrow :: Borrow < types :: reserves :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: reserves :: Param0 > , types :: reserves :: Reserves , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Balances" , "Reserves" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [229u8 , 249u8 , 203u8 , 167u8 , 55u8 , 45u8 , 194u8 , 217u8 , 66u8 , 155u8 , 16u8 , 204u8 , 106u8 , 207u8 , 49u8 , 127u8 , 193u8 , 192u8 , 147u8 , 242u8 , 31u8 , 220u8 , 137u8 , 8u8 , 247u8 , 96u8 , 175u8 , 28u8 , 246u8 , 50u8 , 254u8 , 222u8 ,]) } # [doc = " Holds on account balances."] pub fn holds_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: holds :: Holds , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Balances" , "Holds" , () , [45u8 , 20u8 , 255u8 , 248u8 , 91u8 , 92u8 , 19u8 , 120u8 , 216u8 , 121u8 , 46u8 , 13u8 , 188u8 , 79u8 , 124u8 , 254u8 , 252u8 , 41u8 , 107u8 , 21u8 , 215u8 , 242u8 , 220u8 , 136u8 , 14u8 , 200u8 , 102u8 , 147u8 , 141u8 , 50u8 , 162u8 , 201u8 ,]) } # [doc = " Holds on account balances."] pub fn holds (& self , _0 : impl :: core :: borrow :: Borrow < types :: holds :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: holds :: Param0 > , types :: holds :: Holds , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Balances" , "Holds" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [45u8 , 20u8 , 255u8 , 248u8 , 91u8 , 92u8 , 19u8 , 120u8 , 216u8 , 121u8 , 46u8 , 13u8 , 188u8 , 79u8 , 124u8 , 254u8 , 252u8 , 41u8 , 107u8 , 21u8 , 215u8 , 242u8 , 220u8 , 136u8 , 14u8 , 200u8 , 102u8 , 147u8 , 141u8 , 50u8 , 162u8 , 201u8 ,]) } # [doc = " Freeze locks on account balances."] pub fn freezes_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: freezes :: Freezes , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Balances" , "Freezes" , () , [53u8 , 28u8 , 230u8 , 230u8 , 26u8 , 176u8 , 210u8 , 21u8 , 149u8 , 240u8 , 217u8 , 196u8 , 134u8 , 217u8 , 43u8 , 98u8 , 245u8 , 54u8 , 222u8 , 227u8 , 140u8 , 204u8 , 119u8 , 99u8 , 198u8 , 252u8 , 76u8 , 83u8 , 140u8 , 122u8 , 55u8 , 236u8 ,]) } # [doc = " Freeze locks on account balances."] pub fn freezes (& self , _0 : impl :: core :: borrow :: Borrow < types :: freezes :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: freezes :: Param0 > , types :: freezes :: Freezes , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Balances" , "Freezes" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [53u8 , 28u8 , 230u8 , 230u8 , 26u8 , 176u8 , 210u8 , 21u8 , 149u8 , 240u8 , 217u8 , 196u8 , 134u8 , 217u8 , 43u8 , 98u8 , 245u8 , 54u8 , 222u8 , 227u8 , 140u8 , 204u8 , 119u8 , 99u8 , 198u8 , 252u8 , 76u8 , 83u8 , 140u8 , 122u8 , 55u8 , 236u8 ,]) } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi ; impl ConstantsApi { # [doc = " The minimum amount required to keep an account open. MUST BE GREATER THAN ZERO!"] # [doc = ""] # [doc = " If you *really* need it to be zero, you can enable the feature `insecure_zero_ed` for"] # [doc = " this pallet. However, you do so at your own risk: this will open up a major DoS vector."] # [doc = " In case you have multiple sources of provider references, you may also get unexpected"] # [doc = " behaviour if you set this to zero."] # [doc = ""] # [doc = " Bottom line: Do yourself a favour and make it at least one!"] pub fn existential_deposit (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u64 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Balances" , "ExistentialDeposit" , [128u8 , 214u8 , 205u8 , 242u8 , 181u8 , 142u8 , 124u8 , 231u8 , 190u8 , 146u8 , 59u8 , 226u8 , 157u8 , 101u8 , 103u8 , 117u8 , 249u8 , 65u8 , 18u8 , 191u8 , 103u8 , 119u8 , 53u8 , 85u8 , 81u8 , 96u8 , 220u8 , 42u8 , 184u8 , 239u8 , 42u8 , 246u8 ,]) } # [doc = " The maximum number of locks that should exist on an account."] # [doc = " Not strictly enforced, but used for weight estimation."] # [doc = ""] # [doc = " Use of locks is deprecated in favour of freezes. See `https://github.com/paritytech/substrate/pull/12951/`"] pub fn max_locks (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u32 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Balances" , "MaxLocks" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " The maximum number of named reserves that can exist on an account."] # [doc = ""] # [doc = " Use of reserves is deprecated in favour of holds. See `https://github.com/paritytech/substrate/pull/12951/`"] pub fn max_reserves (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u32 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Balances" , "MaxReserves" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " The maximum number of individual freeze locks that can exist on an account at any time."] pub fn max_freezes (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u32 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Balances" , "MaxFreezes" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } } } } pub mod transaction_payment { use super :: root_mod ; use super :: runtime_types ; # [doc = "The `Event` enum of this pallet"] pub type Event = runtime_types :: pallet_transaction_payment :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "A transaction fee `actual_fee`, of which `tip` was added to the minimum inclusion fee,"] # [doc = "has been paid by `who`."] pub struct TransactionFeePaid { pub who : transaction_fee_paid :: Who , pub actual_fee : transaction_fee_paid :: ActualFee , pub tip : transaction_fee_paid :: Tip , } pub mod transaction_fee_paid { use super :: runtime_types ; pub type Who = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type ActualFee = :: core :: primitive :: u64 ; pub type Tip = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for TransactionFeePaid { const PALLET : & 'static str = "TransactionPayment" ; const EVENT : & 'static str = "TransactionFeePaid" ; } } pub mod storage { use super :: runtime_types ; pub mod types { use super :: runtime_types ; pub mod next_fee_multiplier { use super :: runtime_types ; pub type NextFeeMultiplier = runtime_types :: sp_arithmetic :: fixed_point :: FixedU128 ; } pub mod storage_version { use super :: runtime_types ; pub type StorageVersion = runtime_types :: pallet_transaction_payment :: Releases ; } } pub struct StorageApi ; impl StorageApi { pub fn next_fee_multiplier (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: next_fee_multiplier :: NextFeeMultiplier , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("TransactionPayment" , "NextFeeMultiplier" , () , [247u8 , 39u8 , 81u8 , 170u8 , 225u8 , 226u8 , 82u8 , 147u8 , 34u8 , 113u8 , 147u8 , 213u8 , 59u8 , 80u8 , 139u8 , 35u8 , 36u8 , 196u8 , 152u8 , 19u8 , 9u8 , 159u8 , 176u8 , 79u8 , 249u8 , 201u8 , 170u8 , 1u8 , 129u8 , 79u8 , 146u8 , 197u8 ,]) } pub fn storage_version (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: storage_version :: StorageVersion , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("TransactionPayment" , "StorageVersion" , () , [105u8 , 243u8 , 158u8 , 241u8 , 159u8 , 231u8 , 253u8 , 6u8 , 4u8 , 32u8 , 85u8 , 178u8 , 126u8 , 31u8 , 203u8 , 134u8 , 154u8 , 38u8 , 122u8 , 155u8 , 150u8 , 251u8 , 174u8 , 15u8 , 74u8 , 134u8 , 216u8 , 244u8 , 168u8 , 175u8 , 158u8 , 144u8 ,]) } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi ; impl ConstantsApi { # [doc = " A fee multiplier for `Operational` extrinsics to compute \"virtual tip\" to boost their"] # [doc = " `priority`"] # [doc = ""] # [doc = " This value is multiplied by the `final_fee` to obtain a \"virtual tip\" that is later"] # [doc = " added to a tip component in regular `priority` calculations."] # [doc = " It means that a `Normal` transaction can front-run a similarly-sized `Operational`"] # [doc = " extrinsic (with no tip), by including a tip value greater than the virtual tip."] # [doc = ""] # [doc = " ```rust,ignore"] # [doc = " // For `Normal`"] # [doc = " let priority = priority_calc(tip);"] # [doc = ""] # [doc = " // For `Operational`"] # [doc = " let virtual_tip = (inclusion_fee + tip) * OperationalFeeMultiplier;"] # [doc = " let priority = priority_calc(tip + virtual_tip);"] # [doc = " ```"] # [doc = ""] # [doc = " Note that since we use `final_fee` the multiplier applies also to the regular `tip`"] # [doc = " sent with the transaction. So, not only does the transaction get a priority bump based"] # [doc = " on the `inclusion_fee`, but we also amplify the impact of tips applied to `Operational`"] # [doc = " transactions."] pub fn operational_fee_multiplier (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u8 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("TransactionPayment" , "OperationalFeeMultiplier" , [141u8 , 130u8 , 11u8 , 35u8 , 226u8 , 114u8 , 92u8 , 179u8 , 168u8 , 110u8 , 28u8 , 91u8 , 221u8 , 64u8 , 4u8 , 148u8 , 201u8 , 193u8 , 185u8 , 66u8 , 226u8 , 114u8 , 97u8 , 79u8 , 62u8 , 212u8 , 202u8 , 114u8 , 237u8 , 228u8 , 183u8 , 165u8 ,]) } } } } pub mod subtensor_module { use super :: root_mod ; use super :: runtime_types ; # [doc = "The `Error` enum of this pallet."] pub type Error = runtime_types :: pallet_subtensor :: pallet :: Error ; # [doc = "Dispatchable functions allow users to interact with the pallet and invoke state changes."] # [doc = "These functions materialize as \"extrinsics\", which are often compared to transactions."] # [doc = "Dispatchable functions must be annotated with a weight and must return a DispatchResult."] pub type Call = runtime_types :: pallet_subtensor :: pallet :: Call ; pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; pub mod types { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "--- Sets the caller weights for the incentive mechanism. The call can be"] # [doc = "made from the hotkey account so is potentially insecure, however, the damage"] # [doc = "of changing weights is minimal if caught early. This function includes all the"] # [doc = "checks that the passed weights meet the requirements. Stored as u16s they represent"] # [doc = "rational values in the range [0,1] which sum to 1 and can be interpreted as"] # [doc = "probabilities. The specific weights determine how inflation propagates outward"] # [doc = "from this peer."] # [doc = ""] # [doc = "Note: The 16 bit integers weights should represent 1.0 as the max u16."] # [doc = "However, the function normalizes all integers to u16_max anyway. This means that if the sum of all"] # [doc = "elements is larger or smaller than the amount of elements * u16_max, all elements"] # [doc = "will be corrected for this deviation."] # [doc = ""] # [doc = "# Args:"] # [doc = "* `origin`: (<T as frame_system::Config>Origin):"] # [doc = "    - The caller, a hotkey who wishes to set their weights."] # [doc = ""] # [doc = "* `netuid` (u16):"] # [doc = "\t- The network uid we are setting these weights on."] # [doc = ""] # [doc = "* `dests` (Vec<u16>):"] # [doc = "\t- The edge endpoint for the weight, i.e. j for w_ij."] # [doc = ""] # [doc = "* 'weights' (Vec<u16>):"] # [doc = "\t- The u16 integer encoded weights. Interpreted as rational"] # [doc = "\t\tvalues in the range [0,1]. They must sum to in32::MAX."] # [doc = ""] # [doc = "* 'version_key' ( u64 ):"] # [doc = "\t- The network version key to check if the validator is up to date."] # [doc = ""] # [doc = "# Event:"] # [doc = "* WeightsSet;"] # [doc = "\t- On successfully setting the weights on chain."] # [doc = ""] # [doc = "# Raises:"] # [doc = "* 'SubNetworkDoesNotExist':"] # [doc = "\t- Attempting to set weights on a non-existent network."] # [doc = ""] # [doc = "* 'NotRegistered':"] # [doc = "\t- Attempting to set weights from a non registered account."] # [doc = ""] # [doc = "* 'WeightVecNotEqualSize':"] # [doc = "\t- Attempting to set weights with uids not of same length."] # [doc = ""] # [doc = "* 'DuplicateUids':"] # [doc = "\t- Attempting to set weights with duplicate uids."] # [doc = ""] # [doc = "    * 'UidsLengthExceedUidsInSubNet':"] # [doc = "\t- Attempting to set weights above the max allowed uids."] # [doc = ""] # [doc = "* 'UidVecContainInvalidOne':"] # [doc = "\t- Attempting to set weights with invalid uids."] # [doc = ""] # [doc = "* 'WeightVecLengthIsLow':"] # [doc = "\t- Attempting to set weights with fewer weights than min."] # [doc = ""] # [doc = "* 'MaxWeightExceeded':"] # [doc = "\t- Attempting to set weights with max value exceeding limit."] pub struct SetWeights { pub netuid : set_weights :: Netuid , pub dests : set_weights :: Dests , pub weights : set_weights :: Weights , pub version_key : set_weights :: VersionKey , } pub mod set_weights { use super :: runtime_types ; pub type Netuid = :: core :: primitive :: u16 ; pub type Dests = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u16 > ; pub type Weights = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u16 > ; pub type VersionKey = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SetWeights { const PALLET : & 'static str = "SubtensorModule" ; const CALL : & 'static str = "set_weights" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "---- Used to commit a hash of your weight values to later be revealed."] # [doc = ""] # [doc = "# Args:"] # [doc = "* `origin`: (`<T as frame_system::Config>::RuntimeOrigin`):"] # [doc = "  - The signature of the committing hotkey."] # [doc = ""] # [doc = "* `netuid` (`u16`):"] # [doc = "  - The u16 network identifier."] # [doc = ""] # [doc = "* `commit_hash` (`H256`):"] # [doc = "  - The hash representing the committed weights."] # [doc = ""] # [doc = "# Raises:"] # [doc = "* `WeightsCommitNotAllowed`:"] # [doc = "  - Attempting to commit when it is not allowed."] # [doc = ""] pub struct CommitWeights { pub netuid : commit_weights :: Netuid , pub commit_hash : commit_weights :: CommitHash , } pub mod commit_weights { use super :: runtime_types ; pub type Netuid = :: core :: primitive :: u16 ; pub type CommitHash = :: subxt :: ext :: subxt_core :: utils :: H256 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for CommitWeights { const PALLET : & 'static str = "SubtensorModule" ; const CALL : & 'static str = "commit_weights" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "---- Used to reveal the weights for a previously committed hash."] # [doc = ""] # [doc = "# Args:"] # [doc = "* `origin`: (`<T as frame_system::Config>::RuntimeOrigin`):"] # [doc = "  - The signature of the revealing hotkey."] # [doc = ""] # [doc = "* `netuid` (`u16`):"] # [doc = "  - The u16 network identifier."] # [doc = ""] # [doc = "* `uids` (`Vec<u16>`):"] # [doc = "  - The uids for the weights being revealed."] # [doc = ""] # [doc = "* `values` (`Vec<u16>`):"] # [doc = "  - The values of the weights being revealed."] # [doc = ""] # [doc = "* `salt` (`Vec<u8>`):"] # [doc = "  - The random salt to protect from brute-force guessing attack in case of small weight changes bit-wise."] # [doc = ""] # [doc = "* `version_key` (`u64`):"] # [doc = "  - The network version key."] # [doc = ""] # [doc = "# Raises:"] # [doc = "* `NoWeightsCommitFound`:"] # [doc = "  - Attempting to reveal weights without an existing commit."] # [doc = ""] # [doc = "* `InvalidRevealCommitHashNotMatchTempo`:"] # [doc = "  - Attempting to reveal weights outside the valid tempo."] # [doc = ""] # [doc = "* `InvalidRevealCommitHashNotMatch`:"] # [doc = "  - The revealed hash does not match the committed hash."] # [doc = ""] pub struct RevealWeights { pub netuid : reveal_weights :: Netuid , pub uids : reveal_weights :: Uids , pub values : reveal_weights :: Values , pub salt : reveal_weights :: Salt , pub version_key : reveal_weights :: VersionKey , } pub mod reveal_weights { use super :: runtime_types ; pub type Netuid = :: core :: primitive :: u16 ; pub type Uids = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u16 > ; pub type Values = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u16 > ; pub type Salt = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u16 > ; pub type VersionKey = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for RevealWeights { const PALLET : & 'static str = "SubtensorModule" ; const CALL : & 'static str = "reveal_weights" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "# Args:"] # [doc = "* `origin`: (<T as frame_system::Config>Origin):"] # [doc = "\t- The caller, a hotkey who wishes to set their weights."] # [doc = ""] # [doc = "* `netuid` (u16):"] # [doc = "\t- The network uid we are setting these weights on."] # [doc = ""] # [doc = "* `hotkey` (T::AccountId):"] # [doc = "\t- The hotkey associated with the operation and the calling coldkey."] # [doc = ""] # [doc = "* `dests` (Vec<u16>):"] # [doc = "\t- The edge endpoint for the weight, i.e. j for w_ij."] # [doc = ""] # [doc = "* 'weights' (Vec<u16>):"] # [doc = "\t- The u16 integer encoded weights. Interpreted as rational"] # [doc = "\t\tvalues in the range [0,1]. They must sum to in32::MAX."] # [doc = ""] # [doc = "* 'version_key' ( u64 ):"] # [doc = "\t- The network version key to check if the validator is up to date."] # [doc = ""] # [doc = "# Event:"] # [doc = ""] # [doc = "* WeightsSet;"] # [doc = "\t- On successfully setting the weights on chain."] # [doc = ""] # [doc = "# Raises:"] # [doc = ""] # [doc = "* NonAssociatedColdKey;"] # [doc = "\t- Attempting to set weights on a non-associated cold key."] # [doc = ""] # [doc = "* 'SubNetworkDoesNotExist':"] # [doc = "\t- Attempting to set weights on a non-existent network."] # [doc = ""] # [doc = "* 'NotRootSubnet':"] # [doc = "\t- Attempting to set weights on a subnet that is not the root network."] # [doc = ""] # [doc = "* 'WeightVecNotEqualSize':"] # [doc = "\t- Attempting to set weights with uids not of same length."] # [doc = ""] # [doc = "* 'UidVecContainInvalidOne':"] # [doc = "\t- Attempting to set weights with invalid uids."] # [doc = ""] # [doc = "* 'NotRegistered':"] # [doc = "\t- Attempting to set weights from a non registered account."] # [doc = ""] # [doc = "* 'WeightVecLengthIsLow':"] # [doc = "\t- Attempting to set weights with fewer weights than min."] # [doc = ""] # [doc = " * 'IncorrectWeightVersionKey':"] # [doc = "     - Attempting to set weights with the incorrect network version key."] # [doc = ""] # [doc = " * 'SettingWeightsTooFast':"] # [doc = "     - Attempting to set weights too fast."] # [doc = ""] # [doc = "* 'WeightVecLengthIsLow':"] # [doc = "\t- Attempting to set weights with fewer weights than min."] # [doc = ""] # [doc = "* 'MaxWeightExceeded':"] # [doc = "\t- Attempting to set weights with max value exceeding limit."] # [doc = ""] pub struct SetRootWeights { pub netuid : set_root_weights :: Netuid , pub hotkey : set_root_weights :: Hotkey , pub dests : set_root_weights :: Dests , pub weights : set_root_weights :: Weights , pub version_key : set_root_weights :: VersionKey , } pub mod set_root_weights { use super :: runtime_types ; pub type Netuid = :: core :: primitive :: u16 ; pub type Hotkey = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Dests = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u16 > ; pub type Weights = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u16 > ; pub type VersionKey = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SetRootWeights { const PALLET : & 'static str = "SubtensorModule" ; const CALL : & 'static str = "set_root_weights" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "--- Sets the key as a delegate."] # [doc = ""] # [doc = "# Args:"] # [doc = "* 'origin': (<T as frame_system::Config>Origin):"] # [doc = "\t- The signature of the caller's coldkey."] # [doc = ""] # [doc = "* 'hotkey' (T::AccountId):"] # [doc = "\t- The hotkey we are delegating (must be owned by the coldkey.)"] # [doc = ""] # [doc = "* 'take' (u64):"] # [doc = "\t- The stake proportion that this hotkey takes from delegations."] # [doc = ""] # [doc = "# Event:"] # [doc = "* DelegateAdded;"] # [doc = "\t- On successfully setting a hotkey as a delegate."] # [doc = ""] # [doc = "# Raises:"] # [doc = "* 'NotRegistered':"] # [doc = "\t- The hotkey we are delegating is not registered on the network."] # [doc = ""] # [doc = "* 'NonAssociatedColdKey':"] # [doc = "\t- The hotkey we are delegating is not owned by the calling coldket."] # [doc = ""] pub struct BecomeDelegate { pub hotkey : become_delegate :: Hotkey , } pub mod become_delegate { use super :: runtime_types ; pub type Hotkey = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for BecomeDelegate { const PALLET : & 'static str = "SubtensorModule" ; const CALL : & 'static str = "become_delegate" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "--- Allows delegates to decrease its take value."] # [doc = ""] # [doc = "# Args:"] # [doc = "* 'origin': (<T as frame_system::Config>::Origin):"] # [doc = "\t- The signature of the caller's coldkey."] # [doc = ""] # [doc = "* 'hotkey' (T::AccountId):"] # [doc = "\t- The hotkey we are delegating (must be owned by the coldkey.)"] # [doc = ""] # [doc = "* 'netuid' (u16):"] # [doc = "\t- Subnet ID to decrease take for"] # [doc = ""] # [doc = "* 'take' (u16):"] # [doc = "\t- The new stake proportion that this hotkey takes from delegations."] # [doc = "       The new value can be between 0 and 11_796 and should be strictly"] # [doc = "       lower than the previous value. It T is the new value (rational number),"] # [doc = "       the the parameter is calculated as [65535 * T]. For example, 1% would be"] # [doc = "       [0.01 * 65535] = [655.35] = 655"] # [doc = ""] # [doc = "# Event:"] # [doc = "* TakeDecreased;"] # [doc = "\t- On successfully setting a decreased take for this hotkey."] # [doc = ""] # [doc = "# Raises:"] # [doc = "* 'NotRegistered':"] # [doc = "\t- The hotkey we are delegating is not registered on the network."] # [doc = ""] # [doc = "* 'NonAssociatedColdKey':"] # [doc = "\t- The hotkey we are delegating is not owned by the calling coldkey."] # [doc = ""] # [doc = "* 'DelegateTakeTooLow':"] # [doc = "\t- The delegate is setting a take which is not lower than the previous."] # [doc = ""] pub struct DecreaseTake { pub hotkey : decrease_take :: Hotkey , pub take : decrease_take :: Take , } pub mod decrease_take { use super :: runtime_types ; pub type Hotkey = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Take = :: core :: primitive :: u16 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for DecreaseTake { const PALLET : & 'static str = "SubtensorModule" ; const CALL : & 'static str = "decrease_take" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "--- Allows delegates to increase its take value. This call is rate-limited."] # [doc = ""] # [doc = "# Args:"] # [doc = "* 'origin': (<T as frame_system::Config>::Origin):"] # [doc = "\t- The signature of the caller's coldkey."] # [doc = ""] # [doc = "* 'hotkey' (T::AccountId):"] # [doc = "\t- The hotkey we are delegating (must be owned by the coldkey.)"] # [doc = ""] # [doc = "* 'take' (u16):"] # [doc = "\t- The new stake proportion that this hotkey takes from delegations."] # [doc = "       The new value can be between 0 and 11_796 and should be strictly"] # [doc = "       greater than the previous value. T is the new value (rational number),"] # [doc = "       the the parameter is calculated as [65535 * T]. For example, 1% would be"] # [doc = "       [0.01 * 65535] = [655.35] = 655"] # [doc = ""] # [doc = "# Event:"] # [doc = "* TakeIncreased;"] # [doc = "\t- On successfully setting a increased take for this hotkey."] # [doc = ""] # [doc = "# Raises:"] # [doc = "* 'NotRegistered':"] # [doc = "\t- The hotkey we are delegating is not registered on the network."] # [doc = ""] # [doc = "* 'NonAssociatedColdKey':"] # [doc = "\t- The hotkey we are delegating is not owned by the calling coldkey."] # [doc = ""] # [doc = "* 'DelegateTakeTooHigh':"] # [doc = "\t- The delegate is setting a take which is not greater than the previous."] # [doc = ""] pub struct IncreaseTake { pub hotkey : increase_take :: Hotkey , pub take : increase_take :: Take , } pub mod increase_take { use super :: runtime_types ; pub type Hotkey = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Take = :: core :: primitive :: u16 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for IncreaseTake { const PALLET : & 'static str = "SubtensorModule" ; const CALL : & 'static str = "increase_take" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "--- Adds stake to a hotkey. The call is made from the"] # [doc = "coldkey account linked in the hotkey."] # [doc = "Only the associated coldkey is allowed to make staking and"] # [doc = "unstaking requests. This protects the neuron against"] # [doc = "attacks on its hotkey running in production code."] # [doc = ""] # [doc = "# Args:"] # [doc = " * 'origin': (<T as frame_system::Config>Origin):"] # [doc = "\t- The signature of the caller's coldkey."] # [doc = ""] # [doc = " * 'hotkey' (T::AccountId):"] # [doc = "\t- The associated hotkey account."] # [doc = ""] # [doc = " * 'amount_staked' (u64):"] # [doc = "\t- The amount of stake to be added to the hotkey staking account."] # [doc = ""] # [doc = "# Event:"] # [doc = " * StakeAdded;"] # [doc = "\t- On the successfully adding stake to a global account."] # [doc = ""] # [doc = "# Raises:"] # [doc = " * 'NotEnoughBalanceToStake':"] # [doc = "\t- Not enough balance on the coldkey to add onto the global account."] # [doc = ""] # [doc = " * 'NonAssociatedColdKey':"] # [doc = "\t- The calling coldkey is not associated with this hotkey."] # [doc = ""] # [doc = " * 'BalanceWithdrawalError':"] # [doc = " \t- Errors stemming from transaction pallet."] # [doc = ""] pub struct AddStake { pub hotkey : add_stake :: Hotkey , pub amount_staked : add_stake :: AmountStaked , } pub mod add_stake { use super :: runtime_types ; pub type Hotkey = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type AmountStaked = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for AddStake { const PALLET : & 'static str = "SubtensorModule" ; const CALL : & 'static str = "add_stake" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Remove stake from the staking account. The call must be made"] # [doc = "from the coldkey account attached to the neuron metadata. Only this key"] # [doc = "has permission to make staking and unstaking requests."] # [doc = ""] # [doc = "# Args:"] # [doc = "* 'origin': (<T as frame_system::Config>Origin):"] # [doc = "\t- The signature of the caller's coldkey."] # [doc = ""] # [doc = "* 'hotkey' (T::AccountId):"] # [doc = "\t- The associated hotkey account."] # [doc = ""] # [doc = "* 'amount_unstaked' (u64):"] # [doc = "\t- The amount of stake to be added to the hotkey staking account."] # [doc = ""] # [doc = "# Event:"] # [doc = "* StakeRemoved;"] # [doc = "\t- On the successfully removing stake from the hotkey account."] # [doc = ""] # [doc = "# Raises:"] # [doc = "* 'NotRegistered':"] # [doc = "\t- Thrown if the account we are attempting to unstake from is non existent."] # [doc = ""] # [doc = "* 'NonAssociatedColdKey':"] # [doc = "\t- Thrown if the coldkey does not own the hotkey we are unstaking from."] # [doc = ""] # [doc = "* 'NotEnoughStakeToWithdraw':"] # [doc = "\t- Thrown if there is not enough stake on the hotkey to withdwraw this amount."] # [doc = ""] pub struct RemoveStake { pub hotkey : remove_stake :: Hotkey , pub amount_unstaked : remove_stake :: AmountUnstaked , } pub mod remove_stake { use super :: runtime_types ; pub type Hotkey = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type AmountUnstaked = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for RemoveStake { const PALLET : & 'static str = "SubtensorModule" ; const CALL : & 'static str = "remove_stake" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Serves or updates axon /promethteus information for the neuron associated with the caller. If the caller is"] # [doc = "already registered the metadata is updated. If the caller is not registered this call throws NotRegistered."] # [doc = ""] # [doc = "# Args:"] # [doc = "* 'origin': (<T as frame_system::Config>Origin):"] # [doc = "\t- The signature of the caller."] # [doc = ""] # [doc = "* 'netuid' (u16):"] # [doc = "\t- The u16 network identifier."] # [doc = ""] # [doc = "* 'version' (u64):"] # [doc = "\t- The bittensor version identifier."] # [doc = ""] # [doc = "* 'ip' (u64):"] # [doc = "\t- The endpoint ip information as a u128 encoded integer."] # [doc = ""] # [doc = "* 'port' (u16):"] # [doc = "\t- The endpoint port information as a u16 encoded integer."] # [doc = ""] # [doc = "* 'ip_type' (u8):"] # [doc = "\t- The endpoint ip version as a u8, 4 or 6."] # [doc = ""] # [doc = "* 'protocol' (u8):"] # [doc = "\t- UDP:1 or TCP:0"] # [doc = ""] # [doc = "* 'placeholder1' (u8):"] # [doc = "\t- Placeholder for further extra params."] # [doc = ""] # [doc = "* 'placeholder2' (u8):"] # [doc = "\t- Placeholder for further extra params."] # [doc = ""] # [doc = "# Event:"] # [doc = "* AxonServed;"] # [doc = "\t- On successfully serving the axon info."] # [doc = ""] # [doc = "# Raises:"] # [doc = "* 'SubNetworkDoesNotExist':"] # [doc = "\t- Attempting to set weights on a non-existent network."] # [doc = ""] # [doc = "* 'NotRegistered':"] # [doc = "\t- Attempting to set weights from a non registered account."] # [doc = ""] # [doc = "* 'InvalidIpType':"] # [doc = "\t- The ip type is not 4 or 6."] # [doc = ""] # [doc = "* 'InvalidIpAddress':"] # [doc = "\t- The numerically encoded ip address does not resolve to a proper ip."] # [doc = ""] # [doc = "* 'ServingRateLimitExceeded':"] # [doc = "\t- Attempting to set prometheus information withing the rate limit min."] # [doc = ""] pub struct ServeAxon { pub netuid : serve_axon :: Netuid , pub version : serve_axon :: Version , pub ip : serve_axon :: Ip , pub port : serve_axon :: Port , pub ip_type : serve_axon :: IpType , pub protocol : serve_axon :: Protocol , pub placeholder1 : serve_axon :: Placeholder1 , pub placeholder2 : serve_axon :: Placeholder2 , } pub mod serve_axon { use super :: runtime_types ; pub type Netuid = :: core :: primitive :: u16 ; pub type Version = :: core :: primitive :: u32 ; pub type Ip = :: core :: primitive :: u128 ; pub type Port = :: core :: primitive :: u16 ; pub type IpType = :: core :: primitive :: u8 ; pub type Protocol = :: core :: primitive :: u8 ; pub type Placeholder1 = :: core :: primitive :: u8 ; pub type Placeholder2 = :: core :: primitive :: u8 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for ServeAxon { const PALLET : & 'static str = "SubtensorModule" ; const CALL : & 'static str = "serve_axon" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "---- Set prometheus information for the neuron."] # [doc = "# Args:"] # [doc = "* 'origin': (<T as frame_system::Config>Origin):"] # [doc = "\t- The signature of the calling hotkey."] # [doc = ""] # [doc = "* 'netuid' (u16):"] # [doc = "\t- The u16 network identifier."] # [doc = ""] # [doc = "* 'version' (u16):"] # [doc = "\t-  The bittensor version identifier."] # [doc = ""] # [doc = "* 'ip' (u128):"] # [doc = "\t- The prometheus ip information as a u128 encoded integer."] # [doc = ""] # [doc = "* 'port' (u16):"] # [doc = "\t- The prometheus port information as a u16 encoded integer."] # [doc = ""] # [doc = "* 'ip_type' (u8):"] # [doc = "\t- The ip type v4 or v6."] # [doc = ""] pub struct ServePrometheus { pub netuid : serve_prometheus :: Netuid , pub version : serve_prometheus :: Version , pub ip : serve_prometheus :: Ip , pub port : serve_prometheus :: Port , pub ip_type : serve_prometheus :: IpType , } pub mod serve_prometheus { use super :: runtime_types ; pub type Netuid = :: core :: primitive :: u16 ; pub type Version = :: core :: primitive :: u32 ; pub type Ip = :: core :: primitive :: u128 ; pub type Port = :: core :: primitive :: u16 ; pub type IpType = :: core :: primitive :: u8 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for ServePrometheus { const PALLET : & 'static str = "SubtensorModule" ; const CALL : & 'static str = "serve_prometheus" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "---- Registers a new neuron to the subnetwork."] # [doc = ""] # [doc = "# Args:"] # [doc = "* 'origin': (<T as frame_system::Config>Origin):"] # [doc = "\t- The signature of the calling hotkey."] # [doc = ""] # [doc = "* 'netuid' (u16):"] # [doc = "\t- The u16 network identifier."] # [doc = ""] # [doc = "* 'block_number' ( u64 ):"] # [doc = "\t- Block hash used to prove work done."] # [doc = ""] # [doc = "* 'nonce' ( u64 ):"] # [doc = "\t- Positive integer nonce used in POW."] # [doc = ""] # [doc = "* 'work' ( Vec<u8> ):"] # [doc = "\t- Vector encoded bytes representing work done."] # [doc = ""] # [doc = "* 'hotkey' ( T::AccountId ):"] # [doc = "\t- Hotkey to be registered to the network."] # [doc = ""] # [doc = "* 'coldkey' ( T::AccountId ):"] # [doc = "\t- Associated coldkey account."] # [doc = ""] # [doc = "# Event:"] # [doc = "* NeuronRegistered;"] # [doc = "\t- On successfully registering a uid to a neuron slot on a subnetwork."] # [doc = ""] # [doc = "# Raises:"] # [doc = "* 'SubNetworkDoesNotExist':"] # [doc = "\t- Attempting to register to a non existent network."] # [doc = ""] # [doc = "* 'TooManyRegistrationsThisBlock':"] # [doc = "\t- This registration exceeds the total allowed on this network this block."] # [doc = ""] # [doc = "* 'HotKeyAlreadyRegisteredInSubNet':"] # [doc = "\t- The hotkey is already registered on this network."] # [doc = ""] # [doc = "* 'InvalidWorkBlock':"] # [doc = "\t- The work has been performed on a stale, future, or non existent block."] # [doc = ""] # [doc = "* 'InvalidDifficulty':"] # [doc = "\t- The work does not match the difficulty."] # [doc = ""] # [doc = "* 'InvalidSeal':"] # [doc = "\t- The seal is incorrect."] # [doc = ""] pub struct Register { pub netuid : register :: Netuid , pub block_number : register :: BlockNumber , pub nonce : register :: Nonce , pub work : register :: Work , pub hotkey : register :: Hotkey , pub coldkey : register :: Coldkey , } pub mod register { use super :: runtime_types ; pub type Netuid = :: core :: primitive :: u16 ; pub type BlockNumber = :: core :: primitive :: u64 ; pub type Nonce = :: core :: primitive :: u64 ; pub type Work = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ; pub type Hotkey = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Coldkey = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for Register { const PALLET : & 'static str = "SubtensorModule" ; const CALL : & 'static str = "register" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Register the hotkey to root network"] pub struct RootRegister { pub hotkey : root_register :: Hotkey , } pub mod root_register { use super :: runtime_types ; pub type Hotkey = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for RootRegister { const PALLET : & 'static str = "SubtensorModule" ; const CALL : & 'static str = "root_register" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Attempt to adjust the senate membership to include a hotkey"] pub struct AdjustSenate { pub hotkey : adjust_senate :: Hotkey , } pub mod adjust_senate { use super :: runtime_types ; pub type Hotkey = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for AdjustSenate { const PALLET : & 'static str = "SubtensorModule" ; const CALL : & 'static str = "adjust_senate" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "User register a new subnetwork via burning token"] pub struct BurnedRegister { pub netuid : burned_register :: Netuid , pub hotkey : burned_register :: Hotkey , } pub mod burned_register { use super :: runtime_types ; pub type Netuid = :: core :: primitive :: u16 ; pub type Hotkey = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for BurnedRegister { const PALLET : & 'static str = "SubtensorModule" ; const CALL : & 'static str = "burned_register" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The extrinsic for user to change its hotkey"] pub struct SwapHotkey { pub hotkey : swap_hotkey :: Hotkey , pub new_hotkey : swap_hotkey :: NewHotkey , } pub mod swap_hotkey { use super :: runtime_types ; pub type Hotkey = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type NewHotkey = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SwapHotkey { const PALLET : & 'static str = "SubtensorModule" ; const CALL : & 'static str = "swap_hotkey" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The extrinsic for user to change the coldkey associated with their account."] # [doc = ""] # [doc = "# Arguments"] # [doc = ""] # [doc = "* `origin` - The origin of the call, must be signed by the old coldkey."] # [doc = "* `old_coldkey` - The current coldkey associated with the account."] # [doc = "* `new_coldkey` - The new coldkey to be associated with the account."] # [doc = ""] # [doc = "# Returns"] # [doc = ""] # [doc = "Returns a `DispatchResultWithPostInfo` indicating success or failure of the operation."] # [doc = ""] # [doc = "# Weight"] # [doc = ""] # [doc = "Weight is calculated based on the number of database reads and writes."] pub struct SwapColdkey { pub old_coldkey : swap_coldkey :: OldColdkey , pub new_coldkey : swap_coldkey :: NewColdkey , } pub mod swap_coldkey { use super :: runtime_types ; pub type OldColdkey = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type NewColdkey = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SwapColdkey { const PALLET : & 'static str = "SubtensorModule" ; const CALL : & 'static str = "swap_coldkey" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Sets the childkey take for a given hotkey."] # [doc = ""] # [doc = "This function allows a coldkey to set the childkey take for a given hotkey."] # [doc = "The childkey take determines the proportion of stake that the hotkey keeps for itself"] # [doc = "when distributing stake to its children."] # [doc = ""] # [doc = "# Arguments:"] # [doc = "* `origin` (<T as frame_system::Config>::RuntimeOrigin):"] # [doc = "    - The signature of the calling coldkey. Setting childkey take can only be done by the coldkey."] # [doc = ""] # [doc = "* `hotkey` (T::AccountId):"] # [doc = "    - The hotkey for which the childkey take will be set."] # [doc = ""] # [doc = "* `take` (u16):"] # [doc = "    - The new childkey take value. This is a percentage represented as a value between 0 and 10000,"] # [doc = "      where 10000 represents 100%."] # [doc = ""] # [doc = "# Events:"] # [doc = "* `ChildkeyTakeSet`:"] # [doc = "    - On successfully setting the childkey take for a hotkey."] # [doc = ""] # [doc = "# Errors:"] # [doc = "* `NonAssociatedColdKey`:"] # [doc = "    - The coldkey does not own the hotkey."] # [doc = "* `InvalidChildkeyTake`:"] # [doc = "    - The provided take value is invalid (greater than the maximum allowed take)."] # [doc = "* `TxChildkeyTakeRateLimitExceeded`:"] # [doc = "    - The rate limit for changing childkey take has been exceeded."] # [doc = ""] pub struct SetChildkeyTake { pub hotkey : set_childkey_take :: Hotkey , pub netuid : set_childkey_take :: Netuid , pub take : set_childkey_take :: Take , } pub mod set_childkey_take { use super :: runtime_types ; pub type Hotkey = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Netuid = :: core :: primitive :: u16 ; pub type Take = :: core :: primitive :: u16 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SetChildkeyTake { const PALLET : & 'static str = "SubtensorModule" ; const CALL : & 'static str = "set_childkey_take" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Sets the transaction rate limit for changing childkey take."] # [doc = ""] # [doc = "This function can only be called by the root origin."] # [doc = ""] # [doc = "# Arguments:"] # [doc = "* `origin` - The origin of the call, must be root."] # [doc = "* `tx_rate_limit` - The new rate limit in blocks."] # [doc = ""] # [doc = "# Errors:"] # [doc = "* `BadOrigin` - If the origin is not root."] # [doc = ""] pub struct SudoSetTxChildkeyTakeRateLimit { pub tx_rate_limit : sudo_set_tx_childkey_take_rate_limit :: TxRateLimit , } pub mod sudo_set_tx_childkey_take_rate_limit { use super :: runtime_types ; pub type TxRateLimit = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SudoSetTxChildkeyTakeRateLimit { const PALLET : & 'static str = "SubtensorModule" ; const CALL : & 'static str = "sudo_set_tx_childkey_take_rate_limit" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Sets the minimum allowed childkey take."] # [doc = ""] # [doc = "This function can only be called by the root origin."] # [doc = ""] # [doc = "# Arguments:"] # [doc = "* `origin` - The origin of the call, must be root."] # [doc = "* `take` - The new minimum childkey take value."] # [doc = ""] # [doc = "# Errors:"] # [doc = "* `BadOrigin` - If the origin is not root."] # [doc = ""] pub struct SudoSetMinChildkeyTake { pub take : sudo_set_min_childkey_take :: Take , } pub mod sudo_set_min_childkey_take { use super :: runtime_types ; pub type Take = :: core :: primitive :: u16 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SudoSetMinChildkeyTake { const PALLET : & 'static str = "SubtensorModule" ; const CALL : & 'static str = "sudo_set_min_childkey_take" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Sets the maximum allowed childkey take."] # [doc = ""] # [doc = "This function can only be called by the root origin."] # [doc = ""] # [doc = "# Arguments:"] # [doc = "* `origin` - The origin of the call, must be root."] # [doc = "* `take` - The new maximum childkey take value."] # [doc = ""] # [doc = "# Errors:"] # [doc = "* `BadOrigin` - If the origin is not root."] # [doc = ""] pub struct SudoSetMaxChildkeyTake { pub take : sudo_set_max_childkey_take :: Take , } pub mod sudo_set_max_childkey_take { use super :: runtime_types ; pub type Take = :: core :: primitive :: u16 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SudoSetMaxChildkeyTake { const PALLET : & 'static str = "SubtensorModule" ; const CALL : & 'static str = "sudo_set_max_childkey_take" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Authenticates a council proposal and dispatches a function call with `Root` origin."] # [doc = ""] # [doc = "The dispatch origin for this call must be a council majority."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- O(1)."] pub struct Sudo { pub call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < sudo :: Call > , } pub mod sudo { use super :: runtime_types ; pub type Call = runtime_types :: node_subtensor_runtime :: RuntimeCall ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for Sudo { const PALLET : & 'static str = "SubtensorModule" ; const CALL : & 'static str = "sudo" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Authenticates a council proposal and dispatches a function call with `Root` origin."] # [doc = "This function does not check the weight of the call, and instead allows the"] # [doc = "user to specify the weight of the call."] # [doc = ""] # [doc = "The dispatch origin for this call must be a council majority."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- O(1)."] pub struct SudoUncheckedWeight { pub call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < sudo_unchecked_weight :: Call > , pub weight : sudo_unchecked_weight :: Weight , } pub mod sudo_unchecked_weight { use super :: runtime_types ; pub type Call = runtime_types :: node_subtensor_runtime :: RuntimeCall ; pub type Weight = runtime_types :: sp_weights :: weight_v2 :: Weight ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SudoUncheckedWeight { const PALLET : & 'static str = "SubtensorModule" ; const CALL : & 'static str = "sudo_unchecked_weight" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "User vote on a proposal"] pub struct Vote { pub hotkey : vote :: Hotkey , pub proposal : vote :: Proposal , # [codec (compact)] pub index : vote :: Index , pub approve : vote :: Approve , } pub mod vote { use super :: runtime_types ; pub type Hotkey = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Proposal = :: subxt :: ext :: subxt_core :: utils :: H256 ; pub type Index = :: core :: primitive :: u32 ; pub type Approve = :: core :: primitive :: bool ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for Vote { const PALLET : & 'static str = "SubtensorModule" ; const CALL : & 'static str = "vote" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "User register a new subnetwork"] pub struct RegisterNetwork ; impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for RegisterNetwork { const PALLET : & 'static str = "SubtensorModule" ; const CALL : & 'static str = "register_network" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Facility extrinsic for user to get taken from faucet"] # [doc = "It is only available when pow-faucet feature enabled"] # [doc = "Just deployed in testnet and devnet for testing purpose"] pub struct Faucet { pub block_number : faucet :: BlockNumber , pub nonce : faucet :: Nonce , pub work : faucet :: Work , } pub mod faucet { use super :: runtime_types ; pub type BlockNumber = :: core :: primitive :: u64 ; pub type Nonce = :: core :: primitive :: u64 ; pub type Work = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for Faucet { const PALLET : & 'static str = "SubtensorModule" ; const CALL : & 'static str = "faucet" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Remove a user's subnetwork"] # [doc = "The caller must be the owner of the network"] pub struct DissolveNetwork { pub coldkey : dissolve_network :: Coldkey , pub netuid : dissolve_network :: Netuid , } pub mod dissolve_network { use super :: runtime_types ; pub type Coldkey = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Netuid = :: core :: primitive :: u16 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for DissolveNetwork { const PALLET : & 'static str = "SubtensorModule" ; const CALL : & 'static str = "dissolve_network" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Set a single child for a given hotkey on a specified network."] # [doc = ""] # [doc = "This function allows a coldkey to set a single child for a given hotkey on a specified network."] # [doc = "The proportion of the hotkey's stake to be allocated to the child is also specified."] # [doc = ""] # [doc = "# Arguments:"] # [doc = "* `origin` (<T as frame_system::Config>::RuntimeOrigin):"] # [doc = "    - The signature of the calling coldkey. Setting a hotkey child can only be done by the coldkey."] # [doc = ""] # [doc = "* `hotkey` (T::AccountId):"] # [doc = "    - The hotkey which will be assigned the child."] # [doc = ""] # [doc = "* `child` (T::AccountId):"] # [doc = "    - The child which will be assigned to the hotkey."] # [doc = ""] # [doc = "* `netuid` (u16):"] # [doc = "    - The u16 network identifier where the childkey will exist."] # [doc = ""] # [doc = "* `proportion` (u64):"] # [doc = "    - Proportion of the hotkey's stake to be given to the child, the value must be u64 normalized."] # [doc = ""] # [doc = "# Events:"] # [doc = "* `ChildAddedSingular`:"] # [doc = "    - On successfully registering a child to a hotkey."] # [doc = ""] # [doc = "# Errors:"] # [doc = "* `SubNetworkDoesNotExist`:"] # [doc = "    - Attempting to register to a non-existent network."] # [doc = "* `RegistrationNotPermittedOnRootSubnet`:"] # [doc = "    - Attempting to register a child on the root network."] # [doc = "* `NonAssociatedColdKey`:"] # [doc = "    - The coldkey does not own the hotkey or the child is the same as the hotkey."] # [doc = "* `HotKeyAccountNotExists`:"] # [doc = "    - The hotkey account does not exist."] # [doc = ""] # [doc = "# Detailed Explanation of Checks:"] # [doc = "1. **Signature Verification**: Ensures that the caller has signed the transaction, verifying the coldkey."] # [doc = "2. **Root Network Check**: Ensures that the delegation is not on the root network, as child hotkeys are not valid on the root."] # [doc = "3. **Network Existence Check**: Ensures that the specified network exists."] # [doc = "4. **Ownership Verification**: Ensures that the coldkey owns the hotkey."] # [doc = "5. **Hotkey Account Existence Check**: Ensures that the hotkey account already exists."] # [doc = "6. **Child-Hotkey Distinction**: Ensures that the child is not the same as the hotkey."] # [doc = "7. **Old Children Cleanup**: Removes the hotkey from the parent list of its old children."] # [doc = "8. **New Children Assignment**: Assigns the new child to the hotkey and updates the parent list for the new child."] pub struct SetChildren { pub hotkey : set_children :: Hotkey , pub netuid : set_children :: Netuid , pub children : set_children :: Children , } pub mod set_children { use super :: runtime_types ; pub type Hotkey = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Netuid = :: core :: primitive :: u16 ; pub type Children = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < (:: core :: primitive :: u64 , :: subxt :: ext :: subxt_core :: utils :: AccountId32 ,) > ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SetChildren { const PALLET : & 'static str = "SubtensorModule" ; const CALL : & 'static str = "set_children" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Schedules a coldkey swap operation to be executed at a future block."] # [doc = ""] # [doc = "This function allows a user to schedule the swapping of their coldkey to a new one"] # [doc = "at a specified future block. The swap is not executed immediately but is scheduled"] # [doc = "to occur at the specified block number."] # [doc = ""] # [doc = "# Arguments"] # [doc = ""] # [doc = "* `origin` - The origin of the call, which should be signed by the current coldkey owner."] # [doc = "* `new_coldkey` - The account ID of the new coldkey that will replace the current one."] # [doc = "* `when` - The block number at which the coldkey swap should be executed."] # [doc = ""] # [doc = "# Returns"] # [doc = ""] # [doc = "Returns a `DispatchResultWithPostInfo` indicating whether the scheduling was successful."] # [doc = ""] # [doc = "# Errors"] # [doc = ""] # [doc = "This function may return an error if:"] # [doc = "* The origin is not signed."] # [doc = "* The scheduling fails due to conflicts or system constraints."] # [doc = ""] # [doc = "# Notes"] # [doc = ""] # [doc = "- The actual swap is not performed by this function. It merely schedules the swap operation."] # [doc = "- The weight of this call is set to a fixed value and may need adjustment based on benchmarking."] # [doc = ""] # [doc = "# TODO"] # [doc = ""] # [doc = "- Implement proper weight calculation based on the complexity of the operation."] # [doc = "- Consider adding checks to prevent scheduling too far into the future."] # [doc = "TODO: Benchmark this call"] pub struct ScheduleSwapColdkey { pub new_coldkey : schedule_swap_coldkey :: NewColdkey , } pub mod schedule_swap_coldkey { use super :: runtime_types ; pub type NewColdkey = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for ScheduleSwapColdkey { const PALLET : & 'static str = "SubtensorModule" ; const CALL : & 'static str = "schedule_swap_coldkey" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Schedule the dissolution of a network at a specified block number."] # [doc = ""] # [doc = "# Arguments"] # [doc = ""] # [doc = "* `origin` - The origin of the call, must be signed by the sender."] # [doc = "* `netuid` - The u16 network identifier to be dissolved."] # [doc = ""] # [doc = "# Returns"] # [doc = ""] # [doc = "Returns a `DispatchResultWithPostInfo` indicating success or failure of the operation."] # [doc = ""] # [doc = "# Weight"] # [doc = ""] # [doc = "Weight is calculated based on the number of database reads and writes."] pub struct ScheduleDissolveNetwork { pub netuid : schedule_dissolve_network :: Netuid , } pub mod schedule_dissolve_network { use super :: runtime_types ; pub type Netuid = :: core :: primitive :: u16 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for ScheduleDissolveNetwork { const PALLET : & 'static str = "SubtensorModule" ; const CALL : & 'static str = "schedule_dissolve_network" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "---- Set prometheus information for the neuron."] # [doc = "# Args:"] # [doc = "* 'origin': (<T as frame_system::Config>Origin):"] # [doc = "\t- The signature of the calling hotkey."] # [doc = ""] # [doc = "* 'netuid' (u16):"] # [doc = "\t- The u16 network identifier."] # [doc = ""] # [doc = "* 'version' (u16):"] # [doc = "\t-  The bittensor version identifier."] # [doc = ""] # [doc = "* 'ip' (u128):"] # [doc = "\t- The prometheus ip information as a u128 encoded integer."] # [doc = ""] # [doc = "* 'port' (u16):"] # [doc = "\t- The prometheus port information as a u16 encoded integer."] # [doc = ""] # [doc = "* 'ip_type' (u8):"] # [doc = "\t- The ip type v4 or v6."] # [doc = ""] pub struct SetIdentity { pub name : set_identity :: Name , pub url : set_identity :: Url , pub image : set_identity :: Image , pub discord : set_identity :: Discord , pub description : set_identity :: Description , pub additional : set_identity :: Additional , } pub mod set_identity { use super :: runtime_types ; pub type Name = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ; pub type Url = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ; pub type Image = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ; pub type Discord = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ; pub type Description = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ; pub type Additional = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SetIdentity { const PALLET : & 'static str = "SubtensorModule" ; const CALL : & 'static str = "set_identity" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "---- Set the identity information for a subnet."] # [doc = "# Args:"] # [doc = "* `origin` - (<T as frame_system::Config>::Origin):"] # [doc = "    - The signature of the calling coldkey, which must be the owner of the subnet."] # [doc = ""] # [doc = "* `netuid` (u16):"] # [doc = "    - The unique network identifier of the subnet."] # [doc = ""] # [doc = "* `subnet_name` (Vec<u8>):"] # [doc = "    - The name of the subnet."] # [doc = ""] # [doc = "* `github_repo` (Vec<u8>):"] # [doc = "    - The GitHub repository associated with the subnet identity."] # [doc = ""] # [doc = "* `subnet_contact` (Vec<u8>):"] # [doc = "    - The contact information for the subnet."] pub struct SetSubnetIdentity { pub netuid : set_subnet_identity :: Netuid , pub subnet_name : set_subnet_identity :: SubnetName , pub github_repo : set_subnet_identity :: GithubRepo , pub subnet_contact : set_subnet_identity :: SubnetContact , } pub mod set_subnet_identity { use super :: runtime_types ; pub type Netuid = :: core :: primitive :: u16 ; pub type SubnetName = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ; pub type GithubRepo = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ; pub type SubnetContact = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SetSubnetIdentity { const PALLET : & 'static str = "SubtensorModule" ; const CALL : & 'static str = "set_subnet_identity" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "User register a new subnetwork"] pub struct RegisterNetworkWithIdentity { pub identity : register_network_with_identity :: Identity , } pub mod register_network_with_identity { use super :: runtime_types ; pub type Identity = :: core :: option :: Option < runtime_types :: pallet_subtensor :: pallet :: SubnetIdentity > ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for RegisterNetworkWithIdentity { const PALLET : & 'static str = "SubtensorModule" ; const CALL : & 'static str = "register_network_with_identity" ; } } pub struct TransactionApi ; impl TransactionApi { # [doc = "--- Sets the caller weights for the incentive mechanism. The call can be"] # [doc = "made from the hotkey account so is potentially insecure, however, the damage"] # [doc = "of changing weights is minimal if caught early. This function includes all the"] # [doc = "checks that the passed weights meet the requirements. Stored as u16s they represent"] # [doc = "rational values in the range [0,1] which sum to 1 and can be interpreted as"] # [doc = "probabilities. The specific weights determine how inflation propagates outward"] # [doc = "from this peer."] # [doc = ""] # [doc = "Note: The 16 bit integers weights should represent 1.0 as the max u16."] # [doc = "However, the function normalizes all integers to u16_max anyway. This means that if the sum of all"] # [doc = "elements is larger or smaller than the amount of elements * u16_max, all elements"] # [doc = "will be corrected for this deviation."] # [doc = ""] # [doc = "# Args:"] # [doc = "* `origin`: (<T as frame_system::Config>Origin):"] # [doc = "    - The caller, a hotkey who wishes to set their weights."] # [doc = ""] # [doc = "* `netuid` (u16):"] # [doc = "\t- The network uid we are setting these weights on."] # [doc = ""] # [doc = "* `dests` (Vec<u16>):"] # [doc = "\t- The edge endpoint for the weight, i.e. j for w_ij."] # [doc = ""] # [doc = "* 'weights' (Vec<u16>):"] # [doc = "\t- The u16 integer encoded weights. Interpreted as rational"] # [doc = "\t\tvalues in the range [0,1]. They must sum to in32::MAX."] # [doc = ""] # [doc = "* 'version_key' ( u64 ):"] # [doc = "\t- The network version key to check if the validator is up to date."] # [doc = ""] # [doc = "# Event:"] # [doc = "* WeightsSet;"] # [doc = "\t- On successfully setting the weights on chain."] # [doc = ""] # [doc = "# Raises:"] # [doc = "* 'SubNetworkDoesNotExist':"] # [doc = "\t- Attempting to set weights on a non-existent network."] # [doc = ""] # [doc = "* 'NotRegistered':"] # [doc = "\t- Attempting to set weights from a non registered account."] # [doc = ""] # [doc = "* 'WeightVecNotEqualSize':"] # [doc = "\t- Attempting to set weights with uids not of same length."] # [doc = ""] # [doc = "* 'DuplicateUids':"] # [doc = "\t- Attempting to set weights with duplicate uids."] # [doc = ""] # [doc = "    * 'UidsLengthExceedUidsInSubNet':"] # [doc = "\t- Attempting to set weights above the max allowed uids."] # [doc = ""] # [doc = "* 'UidVecContainInvalidOne':"] # [doc = "\t- Attempting to set weights with invalid uids."] # [doc = ""] # [doc = "* 'WeightVecLengthIsLow':"] # [doc = "\t- Attempting to set weights with fewer weights than min."] # [doc = ""] # [doc = "* 'MaxWeightExceeded':"] # [doc = "\t- Attempting to set weights with max value exceeding limit."] pub fn set_weights (& self , netuid : types :: set_weights :: Netuid , dests : types :: set_weights :: Dests , weights : types :: set_weights :: Weights , version_key : types :: set_weights :: VersionKey ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SetWeights > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("SubtensorModule" , "set_weights" , types :: SetWeights { netuid , dests , weights , version_key , } , [26u8 , 113u8 , 253u8 , 232u8 , 169u8 , 61u8 , 9u8 , 102u8 , 199u8 , 147u8 , 148u8 , 10u8 , 248u8 , 38u8 , 32u8 , 13u8 , 141u8 , 199u8 , 11u8 , 40u8 , 238u8 , 233u8 , 56u8 , 125u8 , 156u8 , 213u8 , 224u8 , 244u8 , 72u8 , 93u8 , 195u8 , 62u8 ,]) } # [doc = "---- Used to commit a hash of your weight values to later be revealed."] # [doc = ""] # [doc = "# Args:"] # [doc = "* `origin`: (`<T as frame_system::Config>::RuntimeOrigin`):"] # [doc = "  - The signature of the committing hotkey."] # [doc = ""] # [doc = "* `netuid` (`u16`):"] # [doc = "  - The u16 network identifier."] # [doc = ""] # [doc = "* `commit_hash` (`H256`):"] # [doc = "  - The hash representing the committed weights."] # [doc = ""] # [doc = "# Raises:"] # [doc = "* `WeightsCommitNotAllowed`:"] # [doc = "  - Attempting to commit when it is not allowed."] # [doc = ""] pub fn commit_weights (& self , netuid : types :: commit_weights :: Netuid , commit_hash : types :: commit_weights :: CommitHash ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: CommitWeights > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("SubtensorModule" , "commit_weights" , types :: CommitWeights { netuid , commit_hash , } , [228u8 , 64u8 , 192u8 , 9u8 , 130u8 , 55u8 , 179u8 , 227u8 , 55u8 , 103u8 , 173u8 , 38u8 , 39u8 , 238u8 , 250u8 , 79u8 , 152u8 , 145u8 , 158u8 , 183u8 , 40u8 , 242u8 , 211u8 , 236u8 , 69u8 , 77u8 , 47u8 , 193u8 , 140u8 , 230u8 , 240u8 , 65u8 ,]) } # [doc = "---- Used to reveal the weights for a previously committed hash."] # [doc = ""] # [doc = "# Args:"] # [doc = "* `origin`: (`<T as frame_system::Config>::RuntimeOrigin`):"] # [doc = "  - The signature of the revealing hotkey."] # [doc = ""] # [doc = "* `netuid` (`u16`):"] # [doc = "  - The u16 network identifier."] # [doc = ""] # [doc = "* `uids` (`Vec<u16>`):"] # [doc = "  - The uids for the weights being revealed."] # [doc = ""] # [doc = "* `values` (`Vec<u16>`):"] # [doc = "  - The values of the weights being revealed."] # [doc = ""] # [doc = "* `salt` (`Vec<u8>`):"] # [doc = "  - The random salt to protect from brute-force guessing attack in case of small weight changes bit-wise."] # [doc = ""] # [doc = "* `version_key` (`u64`):"] # [doc = "  - The network version key."] # [doc = ""] # [doc = "# Raises:"] # [doc = "* `NoWeightsCommitFound`:"] # [doc = "  - Attempting to reveal weights without an existing commit."] # [doc = ""] # [doc = "* `InvalidRevealCommitHashNotMatchTempo`:"] # [doc = "  - Attempting to reveal weights outside the valid tempo."] # [doc = ""] # [doc = "* `InvalidRevealCommitHashNotMatch`:"] # [doc = "  - The revealed hash does not match the committed hash."] # [doc = ""] pub fn reveal_weights (& self , netuid : types :: reveal_weights :: Netuid , uids : types :: reveal_weights :: Uids , values : types :: reveal_weights :: Values , salt : types :: reveal_weights :: Salt , version_key : types :: reveal_weights :: VersionKey ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: RevealWeights > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("SubtensorModule" , "reveal_weights" , types :: RevealWeights { netuid , uids , values , salt , version_key , } , [100u8 , 200u8 , 201u8 , 32u8 , 249u8 , 125u8 , 40u8 , 49u8 , 6u8 , 165u8 , 255u8 , 194u8 , 88u8 , 105u8 , 13u8 , 162u8 , 95u8 , 3u8 , 68u8 , 92u8 , 179u8 , 172u8 , 156u8 , 135u8 , 133u8 , 189u8 , 107u8 , 140u8 , 198u8 , 113u8 , 164u8 , 108u8 ,]) } # [doc = "# Args:"] # [doc = "* `origin`: (<T as frame_system::Config>Origin):"] # [doc = "\t- The caller, a hotkey who wishes to set their weights."] # [doc = ""] # [doc = "* `netuid` (u16):"] # [doc = "\t- The network uid we are setting these weights on."] # [doc = ""] # [doc = "* `hotkey` (T::AccountId):"] # [doc = "\t- The hotkey associated with the operation and the calling coldkey."] # [doc = ""] # [doc = "* `dests` (Vec<u16>):"] # [doc = "\t- The edge endpoint for the weight, i.e. j for w_ij."] # [doc = ""] # [doc = "* 'weights' (Vec<u16>):"] # [doc = "\t- The u16 integer encoded weights. Interpreted as rational"] # [doc = "\t\tvalues in the range [0,1]. They must sum to in32::MAX."] # [doc = ""] # [doc = "* 'version_key' ( u64 ):"] # [doc = "\t- The network version key to check if the validator is up to date."] # [doc = ""] # [doc = "# Event:"] # [doc = ""] # [doc = "* WeightsSet;"] # [doc = "\t- On successfully setting the weights on chain."] # [doc = ""] # [doc = "# Raises:"] # [doc = ""] # [doc = "* NonAssociatedColdKey;"] # [doc = "\t- Attempting to set weights on a non-associated cold key."] # [doc = ""] # [doc = "* 'SubNetworkDoesNotExist':"] # [doc = "\t- Attempting to set weights on a non-existent network."] # [doc = ""] # [doc = "* 'NotRootSubnet':"] # [doc = "\t- Attempting to set weights on a subnet that is not the root network."] # [doc = ""] # [doc = "* 'WeightVecNotEqualSize':"] # [doc = "\t- Attempting to set weights with uids not of same length."] # [doc = ""] # [doc = "* 'UidVecContainInvalidOne':"] # [doc = "\t- Attempting to set weights with invalid uids."] # [doc = ""] # [doc = "* 'NotRegistered':"] # [doc = "\t- Attempting to set weights from a non registered account."] # [doc = ""] # [doc = "* 'WeightVecLengthIsLow':"] # [doc = "\t- Attempting to set weights with fewer weights than min."] # [doc = ""] # [doc = " * 'IncorrectWeightVersionKey':"] # [doc = "     - Attempting to set weights with the incorrect network version key."] # [doc = ""] # [doc = " * 'SettingWeightsTooFast':"] # [doc = "     - Attempting to set weights too fast."] # [doc = ""] # [doc = "* 'WeightVecLengthIsLow':"] # [doc = "\t- Attempting to set weights with fewer weights than min."] # [doc = ""] # [doc = "* 'MaxWeightExceeded':"] # [doc = "\t- Attempting to set weights with max value exceeding limit."] # [doc = ""] pub fn set_root_weights (& self , netuid : types :: set_root_weights :: Netuid , hotkey : types :: set_root_weights :: Hotkey , dests : types :: set_root_weights :: Dests , weights : types :: set_root_weights :: Weights , version_key : types :: set_root_weights :: VersionKey ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SetRootWeights > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("SubtensorModule" , "set_root_weights" , types :: SetRootWeights { netuid , hotkey , dests , weights , version_key , } , [174u8 , 83u8 , 121u8 , 2u8 , 215u8 , 147u8 , 168u8 , 85u8 , 186u8 , 57u8 , 108u8 , 145u8 , 164u8 , 164u8 , 114u8 , 226u8 , 33u8 , 49u8 , 36u8 , 147u8 , 156u8 , 222u8 , 189u8 , 216u8 , 15u8 , 108u8 , 190u8 , 189u8 , 3u8 , 23u8 , 122u8 , 8u8 ,]) } # [doc = "--- Sets the key as a delegate."] # [doc = ""] # [doc = "# Args:"] # [doc = "* 'origin': (<T as frame_system::Config>Origin):"] # [doc = "\t- The signature of the caller's coldkey."] # [doc = ""] # [doc = "* 'hotkey' (T::AccountId):"] # [doc = "\t- The hotkey we are delegating (must be owned by the coldkey.)"] # [doc = ""] # [doc = "* 'take' (u64):"] # [doc = "\t- The stake proportion that this hotkey takes from delegations."] # [doc = ""] # [doc = "# Event:"] # [doc = "* DelegateAdded;"] # [doc = "\t- On successfully setting a hotkey as a delegate."] # [doc = ""] # [doc = "# Raises:"] # [doc = "* 'NotRegistered':"] # [doc = "\t- The hotkey we are delegating is not registered on the network."] # [doc = ""] # [doc = "* 'NonAssociatedColdKey':"] # [doc = "\t- The hotkey we are delegating is not owned by the calling coldket."] # [doc = ""] pub fn become_delegate (& self , hotkey : types :: become_delegate :: Hotkey ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: BecomeDelegate > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("SubtensorModule" , "become_delegate" , types :: BecomeDelegate { hotkey , } , [203u8 , 35u8 , 56u8 , 221u8 , 32u8 , 244u8 , 108u8 , 117u8 , 57u8 , 16u8 , 244u8 , 226u8 , 201u8 , 173u8 , 128u8 , 134u8 , 26u8 , 169u8 , 5u8 , 132u8 , 98u8 , 220u8 , 214u8 , 207u8 , 250u8 , 232u8 , 234u8 , 42u8 , 212u8 , 81u8 , 98u8 , 57u8 ,]) } # [doc = "--- Allows delegates to decrease its take value."] # [doc = ""] # [doc = "# Args:"] # [doc = "* 'origin': (<T as frame_system::Config>::Origin):"] # [doc = "\t- The signature of the caller's coldkey."] # [doc = ""] # [doc = "* 'hotkey' (T::AccountId):"] # [doc = "\t- The hotkey we are delegating (must be owned by the coldkey.)"] # [doc = ""] # [doc = "* 'netuid' (u16):"] # [doc = "\t- Subnet ID to decrease take for"] # [doc = ""] # [doc = "* 'take' (u16):"] # [doc = "\t- The new stake proportion that this hotkey takes from delegations."] # [doc = "       The new value can be between 0 and 11_796 and should be strictly"] # [doc = "       lower than the previous value. It T is the new value (rational number),"] # [doc = "       the the parameter is calculated as [65535 * T]. For example, 1% would be"] # [doc = "       [0.01 * 65535] = [655.35] = 655"] # [doc = ""] # [doc = "# Event:"] # [doc = "* TakeDecreased;"] # [doc = "\t- On successfully setting a decreased take for this hotkey."] # [doc = ""] # [doc = "# Raises:"] # [doc = "* 'NotRegistered':"] # [doc = "\t- The hotkey we are delegating is not registered on the network."] # [doc = ""] # [doc = "* 'NonAssociatedColdKey':"] # [doc = "\t- The hotkey we are delegating is not owned by the calling coldkey."] # [doc = ""] # [doc = "* 'DelegateTakeTooLow':"] # [doc = "\t- The delegate is setting a take which is not lower than the previous."] # [doc = ""] pub fn decrease_take (& self , hotkey : types :: decrease_take :: Hotkey , take : types :: decrease_take :: Take ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: DecreaseTake > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("SubtensorModule" , "decrease_take" , types :: DecreaseTake { hotkey , take , } , [220u8 , 18u8 , 152u8 , 244u8 , 15u8 , 135u8 , 42u8 , 101u8 , 78u8 , 32u8 , 61u8 , 230u8 , 248u8 , 203u8 , 252u8 , 150u8 , 109u8 , 187u8 , 44u8 , 194u8 , 239u8 , 16u8 , 162u8 , 67u8 , 90u8 , 34u8 , 245u8 , 120u8 , 33u8 , 57u8 , 155u8 , 33u8 ,]) } # [doc = "--- Allows delegates to increase its take value. This call is rate-limited."] # [doc = ""] # [doc = "# Args:"] # [doc = "* 'origin': (<T as frame_system::Config>::Origin):"] # [doc = "\t- The signature of the caller's coldkey."] # [doc = ""] # [doc = "* 'hotkey' (T::AccountId):"] # [doc = "\t- The hotkey we are delegating (must be owned by the coldkey.)"] # [doc = ""] # [doc = "* 'take' (u16):"] # [doc = "\t- The new stake proportion that this hotkey takes from delegations."] # [doc = "       The new value can be between 0 and 11_796 and should be strictly"] # [doc = "       greater than the previous value. T is the new value (rational number),"] # [doc = "       the the parameter is calculated as [65535 * T]. For example, 1% would be"] # [doc = "       [0.01 * 65535] = [655.35] = 655"] # [doc = ""] # [doc = "# Event:"] # [doc = "* TakeIncreased;"] # [doc = "\t- On successfully setting a increased take for this hotkey."] # [doc = ""] # [doc = "# Raises:"] # [doc = "* 'NotRegistered':"] # [doc = "\t- The hotkey we are delegating is not registered on the network."] # [doc = ""] # [doc = "* 'NonAssociatedColdKey':"] # [doc = "\t- The hotkey we are delegating is not owned by the calling coldkey."] # [doc = ""] # [doc = "* 'DelegateTakeTooHigh':"] # [doc = "\t- The delegate is setting a take which is not greater than the previous."] # [doc = ""] pub fn increase_take (& self , hotkey : types :: increase_take :: Hotkey , take : types :: increase_take :: Take ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: IncreaseTake > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("SubtensorModule" , "increase_take" , types :: IncreaseTake { hotkey , take , } , [119u8 , 250u8 , 49u8 , 96u8 , 123u8 , 185u8 , 96u8 , 196u8 , 0u8 , 65u8 , 142u8 , 148u8 , 174u8 , 144u8 , 93u8 , 217u8 , 119u8 , 230u8 , 62u8 , 6u8 , 108u8 , 40u8 , 121u8 , 7u8 , 11u8 , 25u8 , 80u8 , 8u8 , 145u8 , 186u8 , 25u8 , 153u8 ,]) } # [doc = "--- Adds stake to a hotkey. The call is made from the"] # [doc = "coldkey account linked in the hotkey."] # [doc = "Only the associated coldkey is allowed to make staking and"] # [doc = "unstaking requests. This protects the neuron against"] # [doc = "attacks on its hotkey running in production code."] # [doc = ""] # [doc = "# Args:"] # [doc = " * 'origin': (<T as frame_system::Config>Origin):"] # [doc = "\t- The signature of the caller's coldkey."] # [doc = ""] # [doc = " * 'hotkey' (T::AccountId):"] # [doc = "\t- The associated hotkey account."] # [doc = ""] # [doc = " * 'amount_staked' (u64):"] # [doc = "\t- The amount of stake to be added to the hotkey staking account."] # [doc = ""] # [doc = "# Event:"] # [doc = " * StakeAdded;"] # [doc = "\t- On the successfully adding stake to a global account."] # [doc = ""] # [doc = "# Raises:"] # [doc = " * 'NotEnoughBalanceToStake':"] # [doc = "\t- Not enough balance on the coldkey to add onto the global account."] # [doc = ""] # [doc = " * 'NonAssociatedColdKey':"] # [doc = "\t- The calling coldkey is not associated with this hotkey."] # [doc = ""] # [doc = " * 'BalanceWithdrawalError':"] # [doc = " \t- Errors stemming from transaction pallet."] # [doc = ""] pub fn add_stake (& self , hotkey : types :: add_stake :: Hotkey , amount_staked : types :: add_stake :: AmountStaked ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: AddStake > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("SubtensorModule" , "add_stake" , types :: AddStake { hotkey , amount_staked , } , [113u8 , 193u8 , 204u8 , 50u8 , 217u8 , 3u8 , 188u8 , 239u8 , 106u8 , 211u8 , 38u8 , 172u8 , 217u8 , 53u8 , 249u8 , 103u8 , 250u8 , 17u8 , 183u8 , 209u8 , 59u8 , 123u8 , 123u8 , 246u8 , 96u8 , 247u8 , 137u8 , 83u8 , 91u8 , 64u8 , 48u8 , 220u8 ,]) } # [doc = "Remove stake from the staking account. The call must be made"] # [doc = "from the coldkey account attached to the neuron metadata. Only this key"] # [doc = "has permission to make staking and unstaking requests."] # [doc = ""] # [doc = "# Args:"] # [doc = "* 'origin': (<T as frame_system::Config>Origin):"] # [doc = "\t- The signature of the caller's coldkey."] # [doc = ""] # [doc = "* 'hotkey' (T::AccountId):"] # [doc = "\t- The associated hotkey account."] # [doc = ""] # [doc = "* 'amount_unstaked' (u64):"] # [doc = "\t- The amount of stake to be added to the hotkey staking account."] # [doc = ""] # [doc = "# Event:"] # [doc = "* StakeRemoved;"] # [doc = "\t- On the successfully removing stake from the hotkey account."] # [doc = ""] # [doc = "# Raises:"] # [doc = "* 'NotRegistered':"] # [doc = "\t- Thrown if the account we are attempting to unstake from is non existent."] # [doc = ""] # [doc = "* 'NonAssociatedColdKey':"] # [doc = "\t- Thrown if the coldkey does not own the hotkey we are unstaking from."] # [doc = ""] # [doc = "* 'NotEnoughStakeToWithdraw':"] # [doc = "\t- Thrown if there is not enough stake on the hotkey to withdwraw this amount."] # [doc = ""] pub fn remove_stake (& self , hotkey : types :: remove_stake :: Hotkey , amount_unstaked : types :: remove_stake :: AmountUnstaked ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: RemoveStake > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("SubtensorModule" , "remove_stake" , types :: RemoveStake { hotkey , amount_unstaked , } , [85u8 , 16u8 , 7u8 , 153u8 , 156u8 , 159u8 , 196u8 , 107u8 , 96u8 , 49u8 , 203u8 , 83u8 , 36u8 , 112u8 , 116u8 , 208u8 , 40u8 , 242u8 , 103u8 , 119u8 , 173u8 , 131u8 , 241u8 , 31u8 , 246u8 , 65u8 , 136u8 , 79u8 , 45u8 , 209u8 , 166u8 , 200u8 ,]) } # [doc = "Serves or updates axon /promethteus information for the neuron associated with the caller. If the caller is"] # [doc = "already registered the metadata is updated. If the caller is not registered this call throws NotRegistered."] # [doc = ""] # [doc = "# Args:"] # [doc = "* 'origin': (<T as frame_system::Config>Origin):"] # [doc = "\t- The signature of the caller."] # [doc = ""] # [doc = "* 'netuid' (u16):"] # [doc = "\t- The u16 network identifier."] # [doc = ""] # [doc = "* 'version' (u64):"] # [doc = "\t- The bittensor version identifier."] # [doc = ""] # [doc = "* 'ip' (u64):"] # [doc = "\t- The endpoint ip information as a u128 encoded integer."] # [doc = ""] # [doc = "* 'port' (u16):"] # [doc = "\t- The endpoint port information as a u16 encoded integer."] # [doc = ""] # [doc = "* 'ip_type' (u8):"] # [doc = "\t- The endpoint ip version as a u8, 4 or 6."] # [doc = ""] # [doc = "* 'protocol' (u8):"] # [doc = "\t- UDP:1 or TCP:0"] # [doc = ""] # [doc = "* 'placeholder1' (u8):"] # [doc = "\t- Placeholder for further extra params."] # [doc = ""] # [doc = "* 'placeholder2' (u8):"] # [doc = "\t- Placeholder for further extra params."] # [doc = ""] # [doc = "# Event:"] # [doc = "* AxonServed;"] # [doc = "\t- On successfully serving the axon info."] # [doc = ""] # [doc = "# Raises:"] # [doc = "* 'SubNetworkDoesNotExist':"] # [doc = "\t- Attempting to set weights on a non-existent network."] # [doc = ""] # [doc = "* 'NotRegistered':"] # [doc = "\t- Attempting to set weights from a non registered account."] # [doc = ""] # [doc = "* 'InvalidIpType':"] # [doc = "\t- The ip type is not 4 or 6."] # [doc = ""] # [doc = "* 'InvalidIpAddress':"] # [doc = "\t- The numerically encoded ip address does not resolve to a proper ip."] # [doc = ""] # [doc = "* 'ServingRateLimitExceeded':"] # [doc = "\t- Attempting to set prometheus information withing the rate limit min."] # [doc = ""] pub fn serve_axon (& self , netuid : types :: serve_axon :: Netuid , version : types :: serve_axon :: Version , ip : types :: serve_axon :: Ip , port : types :: serve_axon :: Port , ip_type : types :: serve_axon :: IpType , protocol : types :: serve_axon :: Protocol , placeholder1 : types :: serve_axon :: Placeholder1 , placeholder2 : types :: serve_axon :: Placeholder2 ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: ServeAxon > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("SubtensorModule" , "serve_axon" , types :: ServeAxon { netuid , version , ip , port , ip_type , protocol , placeholder1 , placeholder2 , } , [115u8 , 192u8 , 140u8 , 60u8 , 59u8 , 74u8 , 35u8 , 185u8 , 142u8 , 224u8 , 166u8 , 121u8 , 135u8 , 13u8 , 247u8 , 54u8 , 152u8 , 178u8 , 119u8 , 176u8 , 131u8 , 22u8 , 125u8 , 241u8 , 162u8 , 174u8 , 238u8 , 35u8 , 245u8 , 254u8 , 254u8 , 205u8 ,]) } # [doc = "---- Set prometheus information for the neuron."] # [doc = "# Args:"] # [doc = "* 'origin': (<T as frame_system::Config>Origin):"] # [doc = "\t- The signature of the calling hotkey."] # [doc = ""] # [doc = "* 'netuid' (u16):"] # [doc = "\t- The u16 network identifier."] # [doc = ""] # [doc = "* 'version' (u16):"] # [doc = "\t-  The bittensor version identifier."] # [doc = ""] # [doc = "* 'ip' (u128):"] # [doc = "\t- The prometheus ip information as a u128 encoded integer."] # [doc = ""] # [doc = "* 'port' (u16):"] # [doc = "\t- The prometheus port information as a u16 encoded integer."] # [doc = ""] # [doc = "* 'ip_type' (u8):"] # [doc = "\t- The ip type v4 or v6."] # [doc = ""] pub fn serve_prometheus (& self , netuid : types :: serve_prometheus :: Netuid , version : types :: serve_prometheus :: Version , ip : types :: serve_prometheus :: Ip , port : types :: serve_prometheus :: Port , ip_type : types :: serve_prometheus :: IpType ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: ServePrometheus > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("SubtensorModule" , "serve_prometheus" , types :: ServePrometheus { netuid , version , ip , port , ip_type , } , [20u8 , 125u8 , 112u8 , 212u8 , 213u8 , 9u8 , 36u8 , 152u8 , 252u8 , 42u8 , 37u8 , 90u8 , 11u8 , 166u8 , 1u8 , 224u8 , 116u8 , 108u8 , 124u8 , 61u8 , 93u8 , 220u8 , 88u8 , 62u8 , 71u8 , 65u8 , 225u8 , 166u8 , 66u8 , 236u8 , 238u8 , 126u8 ,]) } # [doc = "---- Registers a new neuron to the subnetwork."] # [doc = ""] # [doc = "# Args:"] # [doc = "* 'origin': (<T as frame_system::Config>Origin):"] # [doc = "\t- The signature of the calling hotkey."] # [doc = ""] # [doc = "* 'netuid' (u16):"] # [doc = "\t- The u16 network identifier."] # [doc = ""] # [doc = "* 'block_number' ( u64 ):"] # [doc = "\t- Block hash used to prove work done."] # [doc = ""] # [doc = "* 'nonce' ( u64 ):"] # [doc = "\t- Positive integer nonce used in POW."] # [doc = ""] # [doc = "* 'work' ( Vec<u8> ):"] # [doc = "\t- Vector encoded bytes representing work done."] # [doc = ""] # [doc = "* 'hotkey' ( T::AccountId ):"] # [doc = "\t- Hotkey to be registered to the network."] # [doc = ""] # [doc = "* 'coldkey' ( T::AccountId ):"] # [doc = "\t- Associated coldkey account."] # [doc = ""] # [doc = "# Event:"] # [doc = "* NeuronRegistered;"] # [doc = "\t- On successfully registering a uid to a neuron slot on a subnetwork."] # [doc = ""] # [doc = "# Raises:"] # [doc = "* 'SubNetworkDoesNotExist':"] # [doc = "\t- Attempting to register to a non existent network."] # [doc = ""] # [doc = "* 'TooManyRegistrationsThisBlock':"] # [doc = "\t- This registration exceeds the total allowed on this network this block."] # [doc = ""] # [doc = "* 'HotKeyAlreadyRegisteredInSubNet':"] # [doc = "\t- The hotkey is already registered on this network."] # [doc = ""] # [doc = "* 'InvalidWorkBlock':"] # [doc = "\t- The work has been performed on a stale, future, or non existent block."] # [doc = ""] # [doc = "* 'InvalidDifficulty':"] # [doc = "\t- The work does not match the difficulty."] # [doc = ""] # [doc = "* 'InvalidSeal':"] # [doc = "\t- The seal is incorrect."] # [doc = ""] pub fn register (& self , netuid : types :: register :: Netuid , block_number : types :: register :: BlockNumber , nonce : types :: register :: Nonce , work : types :: register :: Work , hotkey : types :: register :: Hotkey , coldkey : types :: register :: Coldkey ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: Register > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("SubtensorModule" , "register" , types :: Register { netuid , block_number , nonce , work , hotkey , coldkey , } , [224u8 , 165u8 , 251u8 , 192u8 , 6u8 , 131u8 , 79u8 , 41u8 , 143u8 , 150u8 , 200u8 , 247u8 , 68u8 , 7u8 , 4u8 , 195u8 , 139u8 , 31u8 , 130u8 , 173u8 , 230u8 , 99u8 , 39u8 , 220u8 , 244u8 , 120u8 , 81u8 , 87u8 , 34u8 , 207u8 , 70u8 , 193u8 ,]) } # [doc = "Register the hotkey to root network"] pub fn root_register (& self , hotkey : types :: root_register :: Hotkey ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: RootRegister > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("SubtensorModule" , "root_register" , types :: RootRegister { hotkey , } , [196u8 , 149u8 , 100u8 , 179u8 , 32u8 , 69u8 , 216u8 , 177u8 , 78u8 , 22u8 , 227u8 , 176u8 , 63u8 , 178u8 , 27u8 , 80u8 , 74u8 , 246u8 , 223u8 , 236u8 , 183u8 , 226u8 , 210u8 , 249u8 , 133u8 , 103u8 , 174u8 , 43u8 , 153u8 , 201u8 , 8u8 , 55u8 ,]) } # [doc = "Attempt to adjust the senate membership to include a hotkey"] pub fn adjust_senate (& self , hotkey : types :: adjust_senate :: Hotkey ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: AdjustSenate > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("SubtensorModule" , "adjust_senate" , types :: AdjustSenate { hotkey , } , [99u8 , 190u8 , 20u8 , 241u8 , 251u8 , 175u8 , 215u8 , 232u8 , 255u8 , 169u8 , 22u8 , 233u8 , 46u8 , 228u8 , 144u8 , 179u8 , 217u8 , 92u8 , 164u8 , 178u8 , 157u8 , 218u8 , 255u8 , 63u8 , 82u8 , 53u8 , 126u8 , 114u8 , 178u8 , 249u8 , 37u8 , 251u8 ,]) } # [doc = "User register a new subnetwork via burning token"] pub fn burned_register (& self , netuid : types :: burned_register :: Netuid , hotkey : types :: burned_register :: Hotkey ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: BurnedRegister > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("SubtensorModule" , "burned_register" , types :: BurnedRegister { netuid , hotkey , } , [66u8 , 182u8 , 83u8 , 185u8 , 109u8 , 48u8 , 136u8 , 88u8 , 198u8 , 19u8 , 54u8 , 132u8 , 245u8 , 28u8 , 243u8 , 177u8 , 110u8 , 11u8 , 118u8 , 109u8 , 17u8 , 188u8 , 221u8 , 94u8 , 216u8 , 72u8 , 0u8 , 101u8 , 155u8 , 87u8 , 140u8 , 251u8 ,]) } # [doc = "The extrinsic for user to change its hotkey"] pub fn swap_hotkey (& self , hotkey : types :: swap_hotkey :: Hotkey , new_hotkey : types :: swap_hotkey :: NewHotkey ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SwapHotkey > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("SubtensorModule" , "swap_hotkey" , types :: SwapHotkey { hotkey , new_hotkey , } , [203u8 , 136u8 , 78u8 , 79u8 , 43u8 , 211u8 , 137u8 , 210u8 , 82u8 , 46u8 , 250u8 , 109u8 , 181u8 , 172u8 , 206u8 , 26u8 , 111u8 , 6u8 , 15u8 , 81u8 , 139u8 , 246u8 , 47u8 , 125u8 , 67u8 , 62u8 , 249u8 , 14u8 , 227u8 , 41u8 , 102u8 , 250u8 ,]) } # [doc = "The extrinsic for user to change the coldkey associated with their account."] # [doc = ""] # [doc = "# Arguments"] # [doc = ""] # [doc = "* `origin` - The origin of the call, must be signed by the old coldkey."] # [doc = "* `old_coldkey` - The current coldkey associated with the account."] # [doc = "* `new_coldkey` - The new coldkey to be associated with the account."] # [doc = ""] # [doc = "# Returns"] # [doc = ""] # [doc = "Returns a `DispatchResultWithPostInfo` indicating success or failure of the operation."] # [doc = ""] # [doc = "# Weight"] # [doc = ""] # [doc = "Weight is calculated based on the number of database reads and writes."] pub fn swap_coldkey (& self , old_coldkey : types :: swap_coldkey :: OldColdkey , new_coldkey : types :: swap_coldkey :: NewColdkey ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SwapColdkey > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("SubtensorModule" , "swap_coldkey" , types :: SwapColdkey { old_coldkey , new_coldkey , } , [168u8 , 226u8 , 150u8 , 210u8 , 58u8 , 75u8 , 179u8 , 151u8 , 51u8 , 92u8 , 177u8 , 158u8 , 79u8 , 174u8 , 241u8 , 237u8 , 78u8 , 87u8 , 109u8 , 125u8 , 222u8 , 100u8 , 236u8 , 80u8 , 6u8 , 234u8 , 143u8 , 188u8 , 151u8 , 222u8 , 240u8 , 134u8 ,]) } # [doc = "Sets the childkey take for a given hotkey."] # [doc = ""] # [doc = "This function allows a coldkey to set the childkey take for a given hotkey."] # [doc = "The childkey take determines the proportion of stake that the hotkey keeps for itself"] # [doc = "when distributing stake to its children."] # [doc = ""] # [doc = "# Arguments:"] # [doc = "* `origin` (<T as frame_system::Config>::RuntimeOrigin):"] # [doc = "    - The signature of the calling coldkey. Setting childkey take can only be done by the coldkey."] # [doc = ""] # [doc = "* `hotkey` (T::AccountId):"] # [doc = "    - The hotkey for which the childkey take will be set."] # [doc = ""] # [doc = "* `take` (u16):"] # [doc = "    - The new childkey take value. This is a percentage represented as a value between 0 and 10000,"] # [doc = "      where 10000 represents 100%."] # [doc = ""] # [doc = "# Events:"] # [doc = "* `ChildkeyTakeSet`:"] # [doc = "    - On successfully setting the childkey take for a hotkey."] # [doc = ""] # [doc = "# Errors:"] # [doc = "* `NonAssociatedColdKey`:"] # [doc = "    - The coldkey does not own the hotkey."] # [doc = "* `InvalidChildkeyTake`:"] # [doc = "    - The provided take value is invalid (greater than the maximum allowed take)."] # [doc = "* `TxChildkeyTakeRateLimitExceeded`:"] # [doc = "    - The rate limit for changing childkey take has been exceeded."] # [doc = ""] pub fn set_childkey_take (& self , hotkey : types :: set_childkey_take :: Hotkey , netuid : types :: set_childkey_take :: Netuid , take : types :: set_childkey_take :: Take ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SetChildkeyTake > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("SubtensorModule" , "set_childkey_take" , types :: SetChildkeyTake { hotkey , netuid , take , } , [121u8 , 93u8 , 32u8 , 255u8 , 50u8 , 102u8 , 154u8 , 191u8 , 45u8 , 27u8 , 53u8 , 78u8 , 108u8 , 88u8 , 147u8 , 83u8 , 170u8 , 32u8 , 114u8 , 16u8 , 119u8 , 178u8 , 138u8 , 107u8 , 211u8 , 73u8 , 71u8 , 151u8 , 178u8 , 44u8 , 250u8 , 224u8 ,]) } # [doc = "Sets the transaction rate limit for changing childkey take."] # [doc = ""] # [doc = "This function can only be called by the root origin."] # [doc = ""] # [doc = "# Arguments:"] # [doc = "* `origin` - The origin of the call, must be root."] # [doc = "* `tx_rate_limit` - The new rate limit in blocks."] # [doc = ""] # [doc = "# Errors:"] # [doc = "* `BadOrigin` - If the origin is not root."] # [doc = ""] pub fn sudo_set_tx_childkey_take_rate_limit (& self , tx_rate_limit : types :: sudo_set_tx_childkey_take_rate_limit :: TxRateLimit ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SudoSetTxChildkeyTakeRateLimit > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("SubtensorModule" , "sudo_set_tx_childkey_take_rate_limit" , types :: SudoSetTxChildkeyTakeRateLimit { tx_rate_limit , } , [91u8 , 243u8 , 210u8 , 65u8 , 149u8 , 33u8 , 8u8 , 69u8 , 42u8 , 197u8 , 4u8 , 202u8 , 73u8 , 167u8 , 185u8 , 75u8 , 203u8 , 98u8 , 21u8 , 230u8 , 66u8 , 192u8 , 108u8 , 254u8 , 37u8 , 246u8 , 156u8 , 120u8 , 59u8 , 180u8 , 175u8 , 156u8 ,]) } # [doc = "Sets the minimum allowed childkey take."] # [doc = ""] # [doc = "This function can only be called by the root origin."] # [doc = ""] # [doc = "# Arguments:"] # [doc = "* `origin` - The origin of the call, must be root."] # [doc = "* `take` - The new minimum childkey take value."] # [doc = ""] # [doc = "# Errors:"] # [doc = "* `BadOrigin` - If the origin is not root."] # [doc = ""] pub fn sudo_set_min_childkey_take (& self , take : types :: sudo_set_min_childkey_take :: Take ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SudoSetMinChildkeyTake > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("SubtensorModule" , "sudo_set_min_childkey_take" , types :: SudoSetMinChildkeyTake { take , } , [229u8 , 132u8 , 126u8 , 102u8 , 220u8 , 249u8 , 9u8 , 110u8 , 89u8 , 137u8 , 46u8 , 248u8 , 54u8 , 95u8 , 124u8 , 194u8 , 190u8 , 6u8 , 198u8 , 113u8 , 35u8 , 21u8 , 214u8 , 165u8 , 231u8 , 91u8 , 158u8 , 133u8 , 6u8 , 192u8 , 14u8 , 170u8 ,]) } # [doc = "Sets the maximum allowed childkey take."] # [doc = ""] # [doc = "This function can only be called by the root origin."] # [doc = ""] # [doc = "# Arguments:"] # [doc = "* `origin` - The origin of the call, must be root."] # [doc = "* `take` - The new maximum childkey take value."] # [doc = ""] # [doc = "# Errors:"] # [doc = "* `BadOrigin` - If the origin is not root."] # [doc = ""] pub fn sudo_set_max_childkey_take (& self , take : types :: sudo_set_max_childkey_take :: Take ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SudoSetMaxChildkeyTake > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("SubtensorModule" , "sudo_set_max_childkey_take" , types :: SudoSetMaxChildkeyTake { take , } , [232u8 , 17u8 , 96u8 , 93u8 , 108u8 , 28u8 , 113u8 , 84u8 , 10u8 , 189u8 , 180u8 , 155u8 , 200u8 , 40u8 , 10u8 , 242u8 , 93u8 , 38u8 , 64u8 , 131u8 , 72u8 , 204u8 , 77u8 , 95u8 , 236u8 , 174u8 , 245u8 , 180u8 , 59u8 , 128u8 , 44u8 , 50u8 ,]) } # [doc = "Authenticates a council proposal and dispatches a function call with `Root` origin."] # [doc = ""] # [doc = "The dispatch origin for this call must be a council majority."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- O(1)."] pub fn sudo (& self , call : types :: sudo :: Call ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: Sudo > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("SubtensorModule" , "sudo" , types :: Sudo { call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box :: new (call) , } , [41u8 , 238u8 , 226u8 , 94u8 , 35u8 , 223u8 , 125u8 , 105u8 , 141u8 , 141u8 , 157u8 , 159u8 , 42u8 , 203u8 , 2u8 , 105u8 , 251u8 , 249u8 , 252u8 , 114u8 , 61u8 , 43u8 , 116u8 , 153u8 , 151u8 , 248u8 , 139u8 , 6u8 , 65u8 , 191u8 , 13u8 , 205u8 ,]) } # [doc = "Authenticates a council proposal and dispatches a function call with `Root` origin."] # [doc = "This function does not check the weight of the call, and instead allows the"] # [doc = "user to specify the weight of the call."] # [doc = ""] # [doc = "The dispatch origin for this call must be a council majority."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- O(1)."] pub fn sudo_unchecked_weight (& self , call : types :: sudo_unchecked_weight :: Call , weight : types :: sudo_unchecked_weight :: Weight ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SudoUncheckedWeight > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("SubtensorModule" , "sudo_unchecked_weight" , types :: SudoUncheckedWeight { call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box :: new (call) , weight , } , [199u8 , 170u8 , 67u8 , 209u8 , 33u8 , 161u8 , 120u8 , 195u8 , 43u8 , 78u8 , 216u8 , 125u8 , 57u8 , 24u8 , 30u8 , 218u8 , 25u8 , 42u8 , 49u8 , 167u8 , 46u8 , 0u8 , 240u8 , 230u8 , 7u8 , 244u8 , 179u8 , 99u8 , 245u8 , 231u8 , 234u8 , 59u8 ,]) } # [doc = "User vote on a proposal"] pub fn vote (& self , hotkey : types :: vote :: Hotkey , proposal : types :: vote :: Proposal , index : types :: vote :: Index , approve : types :: vote :: Approve ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: Vote > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("SubtensorModule" , "vote" , types :: Vote { hotkey , proposal , index , approve , } , [193u8 , 173u8 , 105u8 , 135u8 , 203u8 , 205u8 , 84u8 , 240u8 , 190u8 , 83u8 , 45u8 , 196u8 , 82u8 , 3u8 , 88u8 , 189u8 , 234u8 , 106u8 , 197u8 , 108u8 , 37u8 , 21u8 , 236u8 , 94u8 , 242u8 , 148u8 , 61u8 , 13u8 , 199u8 , 2u8 , 159u8 , 56u8 ,]) } # [doc = "User register a new subnetwork"] pub fn register_network (& self ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: RegisterNetwork > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("SubtensorModule" , "register_network" , types :: RegisterNetwork { } , [201u8 , 94u8 , 81u8 , 163u8 , 111u8 , 143u8 , 250u8 , 29u8 , 225u8 , 250u8 , 37u8 , 229u8 , 45u8 , 101u8 , 56u8 , 242u8 , 5u8 , 195u8 , 112u8 , 246u8 , 40u8 , 122u8 , 75u8 , 147u8 , 112u8 , 122u8 , 67u8 , 225u8 , 115u8 , 101u8 , 211u8 , 59u8 ,]) } # [doc = "Facility extrinsic for user to get taken from faucet"] # [doc = "It is only available when pow-faucet feature enabled"] # [doc = "Just deployed in testnet and devnet for testing purpose"] pub fn faucet (& self , block_number : types :: faucet :: BlockNumber , nonce : types :: faucet :: Nonce , work : types :: faucet :: Work ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: Faucet > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("SubtensorModule" , "faucet" , types :: Faucet { block_number , nonce , work , } , [122u8 , 187u8 , 66u8 , 141u8 , 160u8 , 202u8 , 28u8 , 177u8 , 251u8 , 180u8 , 35u8 , 60u8 , 1u8 , 79u8 , 187u8 , 247u8 , 150u8 , 199u8 , 154u8 , 37u8 , 161u8 , 229u8 , 97u8 , 36u8 , 213u8 , 31u8 , 101u8 , 143u8 , 138u8 , 52u8 , 45u8 , 169u8 ,]) } # [doc = "Remove a user's subnetwork"] # [doc = "The caller must be the owner of the network"] pub fn dissolve_network (& self , coldkey : types :: dissolve_network :: Coldkey , netuid : types :: dissolve_network :: Netuid ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: DissolveNetwork > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("SubtensorModule" , "dissolve_network" , types :: DissolveNetwork { coldkey , netuid , } , [54u8 , 42u8 , 87u8 , 170u8 , 5u8 , 130u8 , 20u8 , 182u8 , 95u8 , 226u8 , 55u8 , 193u8 , 60u8 , 185u8 , 139u8 , 45u8 , 107u8 , 158u8 , 210u8 , 61u8 , 133u8 , 222u8 , 92u8 , 57u8 , 137u8 , 217u8 , 93u8 , 143u8 , 66u8 , 97u8 , 88u8 , 11u8 ,]) } # [doc = "Set a single child for a given hotkey on a specified network."] # [doc = ""] # [doc = "This function allows a coldkey to set a single child for a given hotkey on a specified network."] # [doc = "The proportion of the hotkey's stake to be allocated to the child is also specified."] # [doc = ""] # [doc = "# Arguments:"] # [doc = "* `origin` (<T as frame_system::Config>::RuntimeOrigin):"] # [doc = "    - The signature of the calling coldkey. Setting a hotkey child can only be done by the coldkey."] # [doc = ""] # [doc = "* `hotkey` (T::AccountId):"] # [doc = "    - The hotkey which will be assigned the child."] # [doc = ""] # [doc = "* `child` (T::AccountId):"] # [doc = "    - The child which will be assigned to the hotkey."] # [doc = ""] # [doc = "* `netuid` (u16):"] # [doc = "    - The u16 network identifier where the childkey will exist."] # [doc = ""] # [doc = "* `proportion` (u64):"] # [doc = "    - Proportion of the hotkey's stake to be given to the child, the value must be u64 normalized."] # [doc = ""] # [doc = "# Events:"] # [doc = "* `ChildAddedSingular`:"] # [doc = "    - On successfully registering a child to a hotkey."] # [doc = ""] # [doc = "# Errors:"] # [doc = "* `SubNetworkDoesNotExist`:"] # [doc = "    - Attempting to register to a non-existent network."] # [doc = "* `RegistrationNotPermittedOnRootSubnet`:"] # [doc = "    - Attempting to register a child on the root network."] # [doc = "* `NonAssociatedColdKey`:"] # [doc = "    - The coldkey does not own the hotkey or the child is the same as the hotkey."] # [doc = "* `HotKeyAccountNotExists`:"] # [doc = "    - The hotkey account does not exist."] # [doc = ""] # [doc = "# Detailed Explanation of Checks:"] # [doc = "1. **Signature Verification**: Ensures that the caller has signed the transaction, verifying the coldkey."] # [doc = "2. **Root Network Check**: Ensures that the delegation is not on the root network, as child hotkeys are not valid on the root."] # [doc = "3. **Network Existence Check**: Ensures that the specified network exists."] # [doc = "4. **Ownership Verification**: Ensures that the coldkey owns the hotkey."] # [doc = "5. **Hotkey Account Existence Check**: Ensures that the hotkey account already exists."] # [doc = "6. **Child-Hotkey Distinction**: Ensures that the child is not the same as the hotkey."] # [doc = "7. **Old Children Cleanup**: Removes the hotkey from the parent list of its old children."] # [doc = "8. **New Children Assignment**: Assigns the new child to the hotkey and updates the parent list for the new child."] pub fn set_children (& self , hotkey : types :: set_children :: Hotkey , netuid : types :: set_children :: Netuid , children : types :: set_children :: Children ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SetChildren > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("SubtensorModule" , "set_children" , types :: SetChildren { hotkey , netuid , children , } , [17u8 , 215u8 , 125u8 , 24u8 , 155u8 , 166u8 , 225u8 , 40u8 , 207u8 , 43u8 , 193u8 , 5u8 , 198u8 , 99u8 , 220u8 , 214u8 , 5u8 , 251u8 , 156u8 , 83u8 , 230u8 , 246u8 , 93u8 , 231u8 , 155u8 , 254u8 , 179u8 , 98u8 , 6u8 , 40u8 , 183u8 , 140u8 ,]) } # [doc = "Schedules a coldkey swap operation to be executed at a future block."] # [doc = ""] # [doc = "This function allows a user to schedule the swapping of their coldkey to a new one"] # [doc = "at a specified future block. The swap is not executed immediately but is scheduled"] # [doc = "to occur at the specified block number."] # [doc = ""] # [doc = "# Arguments"] # [doc = ""] # [doc = "* `origin` - The origin of the call, which should be signed by the current coldkey owner."] # [doc = "* `new_coldkey` - The account ID of the new coldkey that will replace the current one."] # [doc = "* `when` - The block number at which the coldkey swap should be executed."] # [doc = ""] # [doc = "# Returns"] # [doc = ""] # [doc = "Returns a `DispatchResultWithPostInfo` indicating whether the scheduling was successful."] # [doc = ""] # [doc = "# Errors"] # [doc = ""] # [doc = "This function may return an error if:"] # [doc = "* The origin is not signed."] # [doc = "* The scheduling fails due to conflicts or system constraints."] # [doc = ""] # [doc = "# Notes"] # [doc = ""] # [doc = "- The actual swap is not performed by this function. It merely schedules the swap operation."] # [doc = "- The weight of this call is set to a fixed value and may need adjustment based on benchmarking."] # [doc = ""] # [doc = "# TODO"] # [doc = ""] # [doc = "- Implement proper weight calculation based on the complexity of the operation."] # [doc = "- Consider adding checks to prevent scheduling too far into the future."] # [doc = "TODO: Benchmark this call"] pub fn schedule_swap_coldkey (& self , new_coldkey : types :: schedule_swap_coldkey :: NewColdkey ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: ScheduleSwapColdkey > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("SubtensorModule" , "schedule_swap_coldkey" , types :: ScheduleSwapColdkey { new_coldkey , } , [66u8 , 101u8 , 41u8 , 48u8 , 176u8 , 72u8 , 84u8 , 50u8 , 72u8 , 60u8 , 8u8 , 241u8 , 164u8 , 96u8 , 160u8 , 55u8 , 31u8 , 204u8 , 167u8 , 233u8 , 184u8 , 5u8 , 106u8 , 178u8 , 49u8 , 38u8 , 199u8 , 171u8 , 125u8 , 2u8 , 163u8 , 98u8 ,]) } # [doc = "Schedule the dissolution of a network at a specified block number."] # [doc = ""] # [doc = "# Arguments"] # [doc = ""] # [doc = "* `origin` - The origin of the call, must be signed by the sender."] # [doc = "* `netuid` - The u16 network identifier to be dissolved."] # [doc = ""] # [doc = "# Returns"] # [doc = ""] # [doc = "Returns a `DispatchResultWithPostInfo` indicating success or failure of the operation."] # [doc = ""] # [doc = "# Weight"] # [doc = ""] # [doc = "Weight is calculated based on the number of database reads and writes."] pub fn schedule_dissolve_network (& self , netuid : types :: schedule_dissolve_network :: Netuid ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: ScheduleDissolveNetwork > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("SubtensorModule" , "schedule_dissolve_network" , types :: ScheduleDissolveNetwork { netuid , } , [226u8 , 8u8 , 148u8 , 200u8 , 65u8 , 242u8 , 123u8 , 255u8 , 171u8 , 207u8 , 68u8 , 87u8 , 122u8 , 55u8 , 61u8 , 194u8 , 198u8 , 222u8 , 33u8 , 139u8 , 0u8 , 166u8 , 153u8 , 210u8 , 172u8 , 58u8 , 116u8 , 235u8 , 191u8 , 95u8 , 116u8 , 229u8 ,]) } # [doc = "---- Set prometheus information for the neuron."] # [doc = "# Args:"] # [doc = "* 'origin': (<T as frame_system::Config>Origin):"] # [doc = "\t- The signature of the calling hotkey."] # [doc = ""] # [doc = "* 'netuid' (u16):"] # [doc = "\t- The u16 network identifier."] # [doc = ""] # [doc = "* 'version' (u16):"] # [doc = "\t-  The bittensor version identifier."] # [doc = ""] # [doc = "* 'ip' (u128):"] # [doc = "\t- The prometheus ip information as a u128 encoded integer."] # [doc = ""] # [doc = "* 'port' (u16):"] # [doc = "\t- The prometheus port information as a u16 encoded integer."] # [doc = ""] # [doc = "* 'ip_type' (u8):"] # [doc = "\t- The ip type v4 or v6."] # [doc = ""] pub fn set_identity (& self , name : types :: set_identity :: Name , url : types :: set_identity :: Url , image : types :: set_identity :: Image , discord : types :: set_identity :: Discord , description : types :: set_identity :: Description , additional : types :: set_identity :: Additional ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SetIdentity > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("SubtensorModule" , "set_identity" , types :: SetIdentity { name , url , image , discord , description , additional , } , [80u8 , 18u8 , 141u8 , 21u8 , 156u8 , 169u8 , 67u8 , 63u8 , 210u8 , 93u8 , 24u8 , 94u8 , 162u8 , 73u8 , 60u8 , 205u8 , 21u8 , 122u8 , 206u8 , 171u8 , 134u8 , 117u8 , 229u8 , 183u8 , 196u8 , 150u8 , 72u8 , 184u8 , 135u8 , 98u8 , 209u8 , 4u8 ,]) } # [doc = "---- Set the identity information for a subnet."] # [doc = "# Args:"] # [doc = "* `origin` - (<T as frame_system::Config>::Origin):"] # [doc = "    - The signature of the calling coldkey, which must be the owner of the subnet."] # [doc = ""] # [doc = "* `netuid` (u16):"] # [doc = "    - The unique network identifier of the subnet."] # [doc = ""] # [doc = "* `subnet_name` (Vec<u8>):"] # [doc = "    - The name of the subnet."] # [doc = ""] # [doc = "* `github_repo` (Vec<u8>):"] # [doc = "    - The GitHub repository associated with the subnet identity."] # [doc = ""] # [doc = "* `subnet_contact` (Vec<u8>):"] # [doc = "    - The contact information for the subnet."] pub fn set_subnet_identity (& self , netuid : types :: set_subnet_identity :: Netuid , subnet_name : types :: set_subnet_identity :: SubnetName , github_repo : types :: set_subnet_identity :: GithubRepo , subnet_contact : types :: set_subnet_identity :: SubnetContact ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SetSubnetIdentity > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("SubtensorModule" , "set_subnet_identity" , types :: SetSubnetIdentity { netuid , subnet_name , github_repo , subnet_contact , } , [55u8 , 165u8 , 148u8 , 244u8 , 92u8 , 106u8 , 147u8 , 37u8 , 106u8 , 119u8 , 182u8 , 82u8 , 97u8 , 22u8 , 254u8 , 222u8 , 40u8 , 112u8 , 33u8 , 202u8 , 62u8 , 245u8 , 126u8 , 224u8 , 182u8 , 64u8 , 164u8 , 79u8 , 232u8 , 69u8 , 59u8 , 37u8 ,]) } # [doc = "User register a new subnetwork"] pub fn register_network_with_identity (& self , identity : types :: register_network_with_identity :: Identity ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: RegisterNetworkWithIdentity > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("SubtensorModule" , "register_network_with_identity" , types :: RegisterNetworkWithIdentity { identity , } , [189u8 , 108u8 , 82u8 , 156u8 , 83u8 , 143u8 , 81u8 , 239u8 , 239u8 , 129u8 , 0u8 , 159u8 , 12u8 , 203u8 , 207u8 , 136u8 , 135u8 , 220u8 , 9u8 , 15u8 , 241u8 , 38u8 , 100u8 , 53u8 , 161u8 , 241u8 , 254u8 , 62u8 , 101u8 , 70u8 , 6u8 , 191u8 ,]) } } } # [doc = "The `Event` enum of this pallet"] pub type Event = runtime_types :: pallet_subtensor :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "a new network is added."] pub struct NetworkAdded (pub network_added :: Field0 , pub network_added :: Field1 ,) ; pub mod network_added { use super :: runtime_types ; pub type Field0 = :: core :: primitive :: u16 ; pub type Field1 = :: core :: primitive :: u16 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for NetworkAdded { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "NetworkAdded" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "a network is removed."] pub struct NetworkRemoved (pub network_removed :: Field0 ,) ; pub mod network_removed { use super :: runtime_types ; pub type Field0 = :: core :: primitive :: u16 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for NetworkRemoved { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "NetworkRemoved" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "stake has been transferred from the a coldkey account onto the hotkey staking account."] pub struct StakeAdded (pub stake_added :: Field0 , pub stake_added :: Field1 ,) ; pub mod stake_added { use super :: runtime_types ; pub type Field0 = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Field1 = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for StakeAdded { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "StakeAdded" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "stake has been removed from the hotkey staking account onto the coldkey account."] pub struct StakeRemoved (pub stake_removed :: Field0 , pub stake_removed :: Field1 ,) ; pub mod stake_removed { use super :: runtime_types ; pub type Field0 = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Field1 = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for StakeRemoved { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "StakeRemoved" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "a caller successfully sets their weights on a subnetwork."] pub struct WeightsSet (pub weights_set :: Field0 , pub weights_set :: Field1 ,) ; pub mod weights_set { use super :: runtime_types ; pub type Field0 = :: core :: primitive :: u16 ; pub type Field1 = :: core :: primitive :: u16 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for WeightsSet { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "WeightsSet" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "a new neuron account has been registered to the chain."] pub struct NeuronRegistered (pub neuron_registered :: Field0 , pub neuron_registered :: Field1 , pub neuron_registered :: Field2 ,) ; pub mod neuron_registered { use super :: runtime_types ; pub type Field0 = :: core :: primitive :: u16 ; pub type Field1 = :: core :: primitive :: u16 ; pub type Field2 = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for NeuronRegistered { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "NeuronRegistered" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "multiple uids have been concurrently registered."] pub struct BulkNeuronsRegistered (pub bulk_neurons_registered :: Field0 , pub bulk_neurons_registered :: Field1 ,) ; pub mod bulk_neurons_registered { use super :: runtime_types ; pub type Field0 = :: core :: primitive :: u16 ; pub type Field1 = :: core :: primitive :: u16 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for BulkNeuronsRegistered { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "BulkNeuronsRegistered" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "FIXME: Not used yet"] pub struct BulkBalancesSet (pub bulk_balances_set :: Field0 , pub bulk_balances_set :: Field1 ,) ; pub mod bulk_balances_set { use super :: runtime_types ; pub type Field0 = :: core :: primitive :: u16 ; pub type Field1 = :: core :: primitive :: u16 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for BulkBalancesSet { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "BulkBalancesSet" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "max allowed uids has been set for a subnetwork."] pub struct MaxAllowedUidsSet (pub max_allowed_uids_set :: Field0 , pub max_allowed_uids_set :: Field1 ,) ; pub mod max_allowed_uids_set { use super :: runtime_types ; pub type Field0 = :: core :: primitive :: u16 ; pub type Field1 = :: core :: primitive :: u16 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for MaxAllowedUidsSet { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "MaxAllowedUidsSet" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "the max weight limit has been set for a subnetwork."] pub struct MaxWeightLimitSet (pub max_weight_limit_set :: Field0 , pub max_weight_limit_set :: Field1 ,) ; pub mod max_weight_limit_set { use super :: runtime_types ; pub type Field0 = :: core :: primitive :: u16 ; pub type Field1 = :: core :: primitive :: u16 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for MaxWeightLimitSet { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "MaxWeightLimitSet" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "the difficulty has been set for a subnet."] pub struct DifficultySet (pub difficulty_set :: Field0 , pub difficulty_set :: Field1 ,) ; pub mod difficulty_set { use super :: runtime_types ; pub type Field0 = :: core :: primitive :: u16 ; pub type Field1 = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for DifficultySet { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "DifficultySet" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "the adjustment interval is set for a subnet."] pub struct AdjustmentIntervalSet (pub adjustment_interval_set :: Field0 , pub adjustment_interval_set :: Field1 ,) ; pub mod adjustment_interval_set { use super :: runtime_types ; pub type Field0 = :: core :: primitive :: u16 ; pub type Field1 = :: core :: primitive :: u16 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for AdjustmentIntervalSet { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "AdjustmentIntervalSet" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "registration per interval is set for a subnet."] pub struct RegistrationPerIntervalSet (pub registration_per_interval_set :: Field0 , pub registration_per_interval_set :: Field1 ,) ; pub mod registration_per_interval_set { use super :: runtime_types ; pub type Field0 = :: core :: primitive :: u16 ; pub type Field1 = :: core :: primitive :: u16 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for RegistrationPerIntervalSet { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "RegistrationPerIntervalSet" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "we set max registrations per block."] pub struct MaxRegistrationsPerBlockSet (pub max_registrations_per_block_set :: Field0 , pub max_registrations_per_block_set :: Field1 ,) ; pub mod max_registrations_per_block_set { use super :: runtime_types ; pub type Field0 = :: core :: primitive :: u16 ; pub type Field1 = :: core :: primitive :: u16 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for MaxRegistrationsPerBlockSet { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "MaxRegistrationsPerBlockSet" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "an activity cutoff is set for a subnet."] pub struct ActivityCutoffSet (pub activity_cutoff_set :: Field0 , pub activity_cutoff_set :: Field1 ,) ; pub mod activity_cutoff_set { use super :: runtime_types ; pub type Field0 = :: core :: primitive :: u16 ; pub type Field1 = :: core :: primitive :: u16 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for ActivityCutoffSet { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "ActivityCutoffSet" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Rho value is set."] pub struct RhoSet (pub rho_set :: Field0 , pub rho_set :: Field1 ,) ; pub mod rho_set { use super :: runtime_types ; pub type Field0 = :: core :: primitive :: u16 ; pub type Field1 = :: core :: primitive :: u16 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for RhoSet { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "RhoSet" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Kappa is set for a subnet."] pub struct KappaSet (pub kappa_set :: Field0 , pub kappa_set :: Field1 ,) ; pub mod kappa_set { use super :: runtime_types ; pub type Field0 = :: core :: primitive :: u16 ; pub type Field1 = :: core :: primitive :: u16 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for KappaSet { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "KappaSet" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "minimum allowed weight is set for a subnet."] pub struct MinAllowedWeightSet (pub min_allowed_weight_set :: Field0 , pub min_allowed_weight_set :: Field1 ,) ; pub mod min_allowed_weight_set { use super :: runtime_types ; pub type Field0 = :: core :: primitive :: u16 ; pub type Field1 = :: core :: primitive :: u16 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for MinAllowedWeightSet { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "MinAllowedWeightSet" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "the validator pruning length has been set."] pub struct ValidatorPruneLenSet (pub validator_prune_len_set :: Field0 , pub validator_prune_len_set :: Field1 ,) ; pub mod validator_prune_len_set { use super :: runtime_types ; pub type Field0 = :: core :: primitive :: u16 ; pub type Field1 = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for ValidatorPruneLenSet { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "ValidatorPruneLenSet" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "the scaling law power has been set for a subnet."] pub struct ScalingLawPowerSet (pub scaling_law_power_set :: Field0 , pub scaling_law_power_set :: Field1 ,) ; pub mod scaling_law_power_set { use super :: runtime_types ; pub type Field0 = :: core :: primitive :: u16 ; pub type Field1 = :: core :: primitive :: u16 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for ScalingLawPowerSet { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "ScalingLawPowerSet" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "weights set rate limit has been set for a subnet."] pub struct WeightsSetRateLimitSet (pub weights_set_rate_limit_set :: Field0 , pub weights_set_rate_limit_set :: Field1 ,) ; pub mod weights_set_rate_limit_set { use super :: runtime_types ; pub type Field0 = :: core :: primitive :: u16 ; pub type Field1 = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for WeightsSetRateLimitSet { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "WeightsSetRateLimitSet" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "immunity period is set for a subnet."] pub struct ImmunityPeriodSet (pub immunity_period_set :: Field0 , pub immunity_period_set :: Field1 ,) ; pub mod immunity_period_set { use super :: runtime_types ; pub type Field0 = :: core :: primitive :: u16 ; pub type Field1 = :: core :: primitive :: u16 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for ImmunityPeriodSet { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "ImmunityPeriodSet" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "bonds moving average is set for a subnet."] pub struct BondsMovingAverageSet (pub bonds_moving_average_set :: Field0 , pub bonds_moving_average_set :: Field1 ,) ; pub mod bonds_moving_average_set { use super :: runtime_types ; pub type Field0 = :: core :: primitive :: u16 ; pub type Field1 = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for BondsMovingAverageSet { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "BondsMovingAverageSet" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "setting the max number of allowed validators on a subnet."] pub struct MaxAllowedValidatorsSet (pub max_allowed_validators_set :: Field0 , pub max_allowed_validators_set :: Field1 ,) ; pub mod max_allowed_validators_set { use super :: runtime_types ; pub type Field0 = :: core :: primitive :: u16 ; pub type Field1 = :: core :: primitive :: u16 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for MaxAllowedValidatorsSet { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "MaxAllowedValidatorsSet" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "the axon server information is added to the network."] pub struct AxonServed (pub axon_served :: Field0 , pub axon_served :: Field1 ,) ; pub mod axon_served { use super :: runtime_types ; pub type Field0 = :: core :: primitive :: u16 ; pub type Field1 = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for AxonServed { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "AxonServed" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "the prometheus server information is added to the network."] pub struct PrometheusServed (pub prometheus_served :: Field0 , pub prometheus_served :: Field1 ,) ; pub mod prometheus_served { use super :: runtime_types ; pub type Field0 = :: core :: primitive :: u16 ; pub type Field1 = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for PrometheusServed { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "PrometheusServed" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "emission ratios for all networks is set."] pub struct EmissionValuesSet ; impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for EmissionValuesSet { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "EmissionValuesSet" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "a hotkey has become a delegate."] pub struct DelegateAdded (pub delegate_added :: Field0 , pub delegate_added :: Field1 , pub delegate_added :: Field2 ,) ; pub mod delegate_added { use super :: runtime_types ; pub type Field0 = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Field1 = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Field2 = :: core :: primitive :: u16 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for DelegateAdded { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "DelegateAdded" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "the default take is set."] pub struct DefaultTakeSet (pub default_take_set :: Field0 ,) ; pub mod default_take_set { use super :: runtime_types ; pub type Field0 = :: core :: primitive :: u16 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for DefaultTakeSet { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "DefaultTakeSet" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "weights version key is set for a network."] pub struct WeightsVersionKeySet (pub weights_version_key_set :: Field0 , pub weights_version_key_set :: Field1 ,) ; pub mod weights_version_key_set { use super :: runtime_types ; pub type Field0 = :: core :: primitive :: u16 ; pub type Field1 = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for WeightsVersionKeySet { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "WeightsVersionKeySet" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "setting min difficulty on a network."] pub struct MinDifficultySet (pub min_difficulty_set :: Field0 , pub min_difficulty_set :: Field1 ,) ; pub mod min_difficulty_set { use super :: runtime_types ; pub type Field0 = :: core :: primitive :: u16 ; pub type Field1 = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for MinDifficultySet { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "MinDifficultySet" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "setting max difficulty on a network."] pub struct MaxDifficultySet (pub max_difficulty_set :: Field0 , pub max_difficulty_set :: Field1 ,) ; pub mod max_difficulty_set { use super :: runtime_types ; pub type Field0 = :: core :: primitive :: u16 ; pub type Field1 = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for MaxDifficultySet { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "MaxDifficultySet" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "setting the prometheus serving rate limit."] pub struct ServingRateLimitSet (pub serving_rate_limit_set :: Field0 , pub serving_rate_limit_set :: Field1 ,) ; pub mod serving_rate_limit_set { use super :: runtime_types ; pub type Field0 = :: core :: primitive :: u16 ; pub type Field1 = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for ServingRateLimitSet { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "ServingRateLimitSet" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "setting burn on a network."] pub struct BurnSet (pub burn_set :: Field0 , pub burn_set :: Field1 ,) ; pub mod burn_set { use super :: runtime_types ; pub type Field0 = :: core :: primitive :: u16 ; pub type Field1 = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for BurnSet { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "BurnSet" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "setting max burn on a network."] pub struct MaxBurnSet (pub max_burn_set :: Field0 , pub max_burn_set :: Field1 ,) ; pub mod max_burn_set { use super :: runtime_types ; pub type Field0 = :: core :: primitive :: u16 ; pub type Field1 = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for MaxBurnSet { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "MaxBurnSet" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "setting min burn on a network."] pub struct MinBurnSet (pub min_burn_set :: Field0 , pub min_burn_set :: Field1 ,) ; pub mod min_burn_set { use super :: runtime_types ; pub type Field0 = :: core :: primitive :: u16 ; pub type Field1 = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for MinBurnSet { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "MinBurnSet" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "setting the transaction rate limit."] pub struct TxRateLimitSet (pub tx_rate_limit_set :: Field0 ,) ; pub mod tx_rate_limit_set { use super :: runtime_types ; pub type Field0 = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for TxRateLimitSet { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "TxRateLimitSet" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "setting the delegate take transaction rate limit."] pub struct TxDelegateTakeRateLimitSet (pub tx_delegate_take_rate_limit_set :: Field0 ,) ; pub mod tx_delegate_take_rate_limit_set { use super :: runtime_types ; pub type Field0 = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for TxDelegateTakeRateLimitSet { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "TxDelegateTakeRateLimitSet" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "setting the childkey take transaction rate limit."] pub struct TxChildKeyTakeRateLimitSet (pub tx_child_key_take_rate_limit_set :: Field0 ,) ; pub mod tx_child_key_take_rate_limit_set { use super :: runtime_types ; pub type Field0 = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for TxChildKeyTakeRateLimitSet { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "TxChildKeyTakeRateLimitSet" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "minimum childkey take set"] pub struct MinChildKeyTakeSet (pub min_child_key_take_set :: Field0 ,) ; pub mod min_child_key_take_set { use super :: runtime_types ; pub type Field0 = :: core :: primitive :: u16 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for MinChildKeyTakeSet { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "MinChildKeyTakeSet" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "maximum childkey take set"] pub struct MaxChildKeyTakeSet (pub max_child_key_take_set :: Field0 ,) ; pub mod max_child_key_take_set { use super :: runtime_types ; pub type Field0 = :: core :: primitive :: u16 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for MaxChildKeyTakeSet { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "MaxChildKeyTakeSet" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "childkey take set"] pub struct ChildKeyTakeSet (pub child_key_take_set :: Field0 , pub child_key_take_set :: Field1 ,) ; pub mod child_key_take_set { use super :: runtime_types ; pub type Field0 = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Field1 = :: core :: primitive :: u16 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for ChildKeyTakeSet { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "ChildKeyTakeSet" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "a sudo call is done."] pub struct Sudid (pub sudid :: Field0 ,) ; pub mod sudid { use super :: runtime_types ; pub type Field0 = :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Sudid { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "Sudid" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "registration is allowed/disallowed for a subnet."] pub struct RegistrationAllowed (pub registration_allowed :: Field0 , pub registration_allowed :: Field1 ,) ; pub mod registration_allowed { use super :: runtime_types ; pub type Field0 = :: core :: primitive :: u16 ; pub type Field1 = :: core :: primitive :: bool ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for RegistrationAllowed { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "RegistrationAllowed" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "POW registration is allowed/disallowed for a subnet."] pub struct PowRegistrationAllowed (pub pow_registration_allowed :: Field0 , pub pow_registration_allowed :: Field1 ,) ; pub mod pow_registration_allowed { use super :: runtime_types ; pub type Field0 = :: core :: primitive :: u16 ; pub type Field1 = :: core :: primitive :: bool ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for PowRegistrationAllowed { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "PowRegistrationAllowed" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "setting tempo on a network"] pub struct TempoSet (pub tempo_set :: Field0 , pub tempo_set :: Field1 ,) ; pub mod tempo_set { use super :: runtime_types ; pub type Field0 = :: core :: primitive :: u16 ; pub type Field1 = :: core :: primitive :: u16 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for TempoSet { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "TempoSet" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "setting the RAO recycled for registration."] pub struct RAORecycledForRegistrationSet (pub rao_recycled_for_registration_set :: Field0 , pub rao_recycled_for_registration_set :: Field1 ,) ; pub mod rao_recycled_for_registration_set { use super :: runtime_types ; pub type Field0 = :: core :: primitive :: u16 ; pub type Field1 = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for RAORecycledForRegistrationSet { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "RAORecycledForRegistrationSet" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "min stake is set for validators to set weights."] pub struct WeightsMinStake (pub weights_min_stake :: Field0 ,) ; pub mod weights_min_stake { use super :: runtime_types ; pub type Field0 = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for WeightsMinStake { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "WeightsMinStake" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "setting the minimum required stake amount for senate registration."] pub struct SenateRequiredStakePercentSet (pub senate_required_stake_percent_set :: Field0 ,) ; pub mod senate_required_stake_percent_set { use super :: runtime_types ; pub type Field0 = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for SenateRequiredStakePercentSet { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "SenateRequiredStakePercentSet" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "setting the adjustment alpha on a subnet."] pub struct AdjustmentAlphaSet (pub adjustment_alpha_set :: Field0 , pub adjustment_alpha_set :: Field1 ,) ; pub mod adjustment_alpha_set { use super :: runtime_types ; pub type Field0 = :: core :: primitive :: u16 ; pub type Field1 = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for AdjustmentAlphaSet { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "AdjustmentAlphaSet" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "the faucet it called on the test net."] pub struct Faucet (pub faucet :: Field0 , pub faucet :: Field1 ,) ; pub mod faucet { use super :: runtime_types ; pub type Field0 = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Field1 = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Faucet { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "Faucet" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "the subnet owner cut is set."] pub struct SubnetOwnerCutSet (pub subnet_owner_cut_set :: Field0 ,) ; pub mod subnet_owner_cut_set { use super :: runtime_types ; pub type Field0 = :: core :: primitive :: u16 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for SubnetOwnerCutSet { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "SubnetOwnerCutSet" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "the network creation rate limit is set."] pub struct NetworkRateLimitSet (pub network_rate_limit_set :: Field0 ,) ; pub mod network_rate_limit_set { use super :: runtime_types ; pub type Field0 = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for NetworkRateLimitSet { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "NetworkRateLimitSet" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "the network immunity period is set."] pub struct NetworkImmunityPeriodSet (pub network_immunity_period_set :: Field0 ,) ; pub mod network_immunity_period_set { use super :: runtime_types ; pub type Field0 = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for NetworkImmunityPeriodSet { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "NetworkImmunityPeriodSet" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "the network minimum locking cost is set."] pub struct NetworkMinLockCostSet (pub network_min_lock_cost_set :: Field0 ,) ; pub mod network_min_lock_cost_set { use super :: runtime_types ; pub type Field0 = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for NetworkMinLockCostSet { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "NetworkMinLockCostSet" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "the maximum number of subnets is set"] pub struct SubnetLimitSet (pub subnet_limit_set :: Field0 ,) ; pub mod subnet_limit_set { use super :: runtime_types ; pub type Field0 = :: core :: primitive :: u16 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for SubnetLimitSet { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "SubnetLimitSet" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "the lock cost reduction is set"] pub struct NetworkLockCostReductionIntervalSet (pub network_lock_cost_reduction_interval_set :: Field0 ,) ; pub mod network_lock_cost_reduction_interval_set { use super :: runtime_types ; pub type Field0 = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for NetworkLockCostReductionIntervalSet { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "NetworkLockCostReductionIntervalSet" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "the take for a delegate is decreased."] pub struct TakeDecreased (pub take_decreased :: Field0 , pub take_decreased :: Field1 , pub take_decreased :: Field2 ,) ; pub mod take_decreased { use super :: runtime_types ; pub type Field0 = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Field1 = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Field2 = :: core :: primitive :: u16 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for TakeDecreased { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "TakeDecreased" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "the take for a delegate is increased."] pub struct TakeIncreased (pub take_increased :: Field0 , pub take_increased :: Field1 , pub take_increased :: Field2 ,) ; pub mod take_increased { use super :: runtime_types ; pub type Field0 = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Field1 = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Field2 = :: core :: primitive :: u16 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for TakeIncreased { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "TakeIncreased" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "the hotkey is swapped"] pub struct HotkeySwapped { pub coldkey : hotkey_swapped :: Coldkey , pub old_hotkey : hotkey_swapped :: OldHotkey , pub new_hotkey : hotkey_swapped :: NewHotkey , } pub mod hotkey_swapped { use super :: runtime_types ; pub type Coldkey = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type OldHotkey = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type NewHotkey = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for HotkeySwapped { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "HotkeySwapped" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "maximum delegate take is set by sudo/admin transaction"] pub struct MaxDelegateTakeSet (pub max_delegate_take_set :: Field0 ,) ; pub mod max_delegate_take_set { use super :: runtime_types ; pub type Field0 = :: core :: primitive :: u16 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for MaxDelegateTakeSet { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "MaxDelegateTakeSet" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "minimum delegate take is set by sudo/admin transaction"] pub struct MinDelegateTakeSet (pub min_delegate_take_set :: Field0 ,) ; pub mod min_delegate_take_set { use super :: runtime_types ; pub type Field0 = :: core :: primitive :: u16 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for MinDelegateTakeSet { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "MinDelegateTakeSet" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "the target stakes per interval is set by sudo/admin transaction"] pub struct TargetStakesPerIntervalSet (pub target_stakes_per_interval_set :: Field0 ,) ; pub mod target_stakes_per_interval_set { use super :: runtime_types ; pub type Field0 = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for TargetStakesPerIntervalSet { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "TargetStakesPerIntervalSet" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "a member of the senate is adjusted"] pub struct SenateAdjusted { pub old_member : senate_adjusted :: OldMember , pub new_member : senate_adjusted :: NewMember , } pub mod senate_adjusted { use super :: runtime_types ; pub type OldMember = :: core :: option :: Option < :: subxt :: ext :: subxt_core :: utils :: AccountId32 > ; pub type NewMember = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for SenateAdjusted { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "SenateAdjusted" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "A coldkey has been swapped"] pub struct ColdkeySwapped { pub old_coldkey : coldkey_swapped :: OldColdkey , pub new_coldkey : coldkey_swapped :: NewColdkey , } pub mod coldkey_swapped { use super :: runtime_types ; pub type OldColdkey = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type NewColdkey = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for ColdkeySwapped { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "ColdkeySwapped" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "All balance of a hotkey has been unstaked and transferred to a new coldkey"] pub struct AllBalanceUnstakedAndTransferredToNewColdkey { pub current_coldkey : all_balance_unstaked_and_transferred_to_new_coldkey :: CurrentColdkey , pub new_coldkey : all_balance_unstaked_and_transferred_to_new_coldkey :: NewColdkey , pub total_balance : all_balance_unstaked_and_transferred_to_new_coldkey :: TotalBalance , } pub mod all_balance_unstaked_and_transferred_to_new_coldkey { use super :: runtime_types ; pub type CurrentColdkey = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type NewColdkey = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type TotalBalance = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for AllBalanceUnstakedAndTransferredToNewColdkey { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "AllBalanceUnstakedAndTransferredToNewColdkey" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "A coldkey swap has been scheduled"] pub struct ColdkeySwapScheduled { pub old_coldkey : coldkey_swap_scheduled :: OldColdkey , pub new_coldkey : coldkey_swap_scheduled :: NewColdkey , pub execution_block : coldkey_swap_scheduled :: ExecutionBlock , } pub mod coldkey_swap_scheduled { use super :: runtime_types ; pub type OldColdkey = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type NewColdkey = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type ExecutionBlock = :: core :: primitive :: u32 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for ColdkeySwapScheduled { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "ColdkeySwapScheduled" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The arbitration period has been extended"] pub struct ArbitrationPeriodExtended { pub coldkey : arbitration_period_extended :: Coldkey , } pub mod arbitration_period_extended { use super :: runtime_types ; pub type Coldkey = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for ArbitrationPeriodExtended { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "ArbitrationPeriodExtended" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The children of a hotkey have been set"] pub struct SetChildren (pub set_children :: Field0 , pub set_children :: Field1 , pub set_children :: Field2 ,) ; pub mod set_children { use super :: runtime_types ; pub type Field0 = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Field1 = :: core :: primitive :: u16 ; pub type Field2 = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < (:: core :: primitive :: u64 , :: subxt :: ext :: subxt_core :: utils :: AccountId32 ,) > ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for SetChildren { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "SetChildren" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The hotkey emission tempo has been set"] pub struct HotkeyEmissionTempoSet (pub hotkey_emission_tempo_set :: Field0 ,) ; pub mod hotkey_emission_tempo_set { use super :: runtime_types ; pub type Field0 = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for HotkeyEmissionTempoSet { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "HotkeyEmissionTempoSet" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The network maximum stake has been set"] pub struct NetworkMaxStakeSet (pub network_max_stake_set :: Field0 , pub network_max_stake_set :: Field1 ,) ; pub mod network_max_stake_set { use super :: runtime_types ; pub type Field0 = :: core :: primitive :: u16 ; pub type Field1 = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for NetworkMaxStakeSet { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "NetworkMaxStakeSet" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The identity of a coldkey has been set"] pub struct ChainIdentitySet (pub chain_identity_set :: Field0 ,) ; pub mod chain_identity_set { use super :: runtime_types ; pub type Field0 = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for ChainIdentitySet { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "ChainIdentitySet" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The identity of a subnet has been set"] pub struct SubnetIdentitySet (pub subnet_identity_set :: Field0 ,) ; pub mod subnet_identity_set { use super :: runtime_types ; pub type Field0 = :: core :: primitive :: u16 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for SubnetIdentitySet { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "SubnetIdentitySet" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The identity of a subnet has been removed"] pub struct SubnetIdentityRemoved (pub subnet_identity_removed :: Field0 ,) ; pub mod subnet_identity_removed { use super :: runtime_types ; pub type Field0 = :: core :: primitive :: u16 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for SubnetIdentityRemoved { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "SubnetIdentityRemoved" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "A dissolve network extrinsic scheduled."] pub struct DissolveNetworkScheduled { pub account : dissolve_network_scheduled :: Account , pub netuid : dissolve_network_scheduled :: Netuid , pub execution_block : dissolve_network_scheduled :: ExecutionBlock , } pub mod dissolve_network_scheduled { use super :: runtime_types ; pub type Account = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Netuid = :: core :: primitive :: u16 ; pub type ExecutionBlock = :: core :: primitive :: u32 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for DissolveNetworkScheduled { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "DissolveNetworkScheduled" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The duration of schedule coldkey swap has been set"] pub struct ColdkeySwapScheduleDurationSet (pub coldkey_swap_schedule_duration_set :: Field0 ,) ; pub mod coldkey_swap_schedule_duration_set { use super :: runtime_types ; pub type Field0 = :: core :: primitive :: u32 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for ColdkeySwapScheduleDurationSet { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "ColdkeySwapScheduleDurationSet" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The duration of dissolve network has been set"] pub struct DissolveNetworkScheduleDurationSet (pub dissolve_network_schedule_duration_set :: Field0 ,) ; pub mod dissolve_network_schedule_duration_set { use super :: runtime_types ; pub type Field0 = :: core :: primitive :: u32 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for DissolveNetworkScheduleDurationSet { const PALLET : & 'static str = "SubtensorModule" ; const EVENT : & 'static str = "DissolveNetworkScheduleDurationSet" ; } } pub mod storage { use super :: runtime_types ; pub mod types { use super :: runtime_types ; pub mod coldkey_swap_schedule_duration { use super :: runtime_types ; pub type ColdkeySwapScheduleDuration = :: core :: primitive :: u32 ; } pub mod dissolve_network_schedule_duration { use super :: runtime_types ; pub type DissolveNetworkScheduleDuration = :: core :: primitive :: u32 ; } pub mod senate_required_stake_percentage { use super :: runtime_types ; pub type SenateRequiredStakePercentage = :: core :: primitive :: u64 ; } pub mod total_issuance { use super :: runtime_types ; pub type TotalIssuance = :: core :: primitive :: u64 ; } pub mod total_stake { use super :: runtime_types ; pub type TotalStake = :: core :: primitive :: u64 ; } pub mod max_delegate_take { use super :: runtime_types ; pub type MaxDelegateTake = :: core :: primitive :: u16 ; } pub mod min_delegate_take { use super :: runtime_types ; pub type MinDelegateTake = :: core :: primitive :: u16 ; } pub mod max_childkey_take { use super :: runtime_types ; pub type MaxChildkeyTake = :: core :: primitive :: u16 ; } pub mod min_childkey_take { use super :: runtime_types ; pub type MinChildkeyTake = :: core :: primitive :: u16 ; } pub mod block_emission { use super :: runtime_types ; pub type BlockEmission = :: core :: primitive :: u64 ; } pub mod target_stakes_per_interval { use super :: runtime_types ; pub type TargetStakesPerInterval = :: core :: primitive :: u64 ; } pub mod stake_interval { use super :: runtime_types ; pub type StakeInterval = :: core :: primitive :: u64 ; } pub mod total_hotkey_stake { use super :: runtime_types ; pub type TotalHotkeyStake = :: core :: primitive :: u64 ; pub type Param0 = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } pub mod total_coldkey_stake { use super :: runtime_types ; pub type TotalColdkeyStake = :: core :: primitive :: u64 ; pub type Param0 = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } pub mod total_hotkey_coldkey_stakes_this_interval { use super :: runtime_types ; pub type TotalHotkeyColdkeyStakesThisInterval = (:: core :: primitive :: u64 , :: core :: primitive :: u64 ,) ; pub type Param0 = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Param1 = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } pub mod owner { use super :: runtime_types ; pub type Owner = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Param0 = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } pub mod delegates { use super :: runtime_types ; pub type Delegates = :: core :: primitive :: u16 ; pub type Param0 = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } pub mod childkey_take { use super :: runtime_types ; pub type ChildkeyTake = :: core :: primitive :: u16 ; pub type Param0 = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Param1 = :: core :: primitive :: u16 ; } pub mod stake { use super :: runtime_types ; pub type Stake = :: core :: primitive :: u64 ; pub type Param0 = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Param1 = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } pub mod last_hotkey_emission_drain { use super :: runtime_types ; pub type LastHotkeyEmissionDrain = :: core :: primitive :: u64 ; pub type Param0 = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } pub mod hotkey_emission_tempo { use super :: runtime_types ; pub type HotkeyEmissionTempo = :: core :: primitive :: u64 ; } pub mod pendingd_hotkey_emission { use super :: runtime_types ; pub type PendingdHotkeyEmission = :: core :: primitive :: u64 ; pub type Param0 = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } pub mod last_add_stake_increase { use super :: runtime_types ; pub type LastAddStakeIncrease = :: core :: primitive :: u64 ; pub type Param0 = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Param1 = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } pub mod stake_delta_since_last_emission_drain { use super :: runtime_types ; pub type StakeDeltaSinceLastEmissionDrain = :: core :: primitive :: i128 ; pub type Param0 = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Param1 = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } pub mod child_keys { use super :: runtime_types ; pub type ChildKeys = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < (:: core :: primitive :: u64 , :: subxt :: ext :: subxt_core :: utils :: AccountId32 ,) > ; pub type Param0 = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Param1 = :: core :: primitive :: u16 ; } pub mod parent_keys { use super :: runtime_types ; pub type ParentKeys = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < (:: core :: primitive :: u64 , :: subxt :: ext :: subxt_core :: utils :: AccountId32 ,) > ; pub type Param0 = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Param1 = :: core :: primitive :: u16 ; } pub mod staking_hotkeys { use super :: runtime_types ; pub type StakingHotkeys = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: subxt :: ext :: subxt_core :: utils :: AccountId32 > ; pub type Param0 = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } pub mod owned_hotkeys { use super :: runtime_types ; pub type OwnedHotkeys = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: subxt :: ext :: subxt_core :: utils :: AccountId32 > ; pub type Param0 = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } pub mod coldkey_swap_scheduled { use super :: runtime_types ; pub type ColdkeySwapScheduled = () ; pub type Param0 = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } pub mod used_work { use super :: runtime_types ; pub type UsedWork = :: core :: primitive :: u64 ; pub type Param0 = [:: core :: primitive :: u8] ; } pub mod max_registrations_per_block { use super :: runtime_types ; pub type MaxRegistrationsPerBlock = :: core :: primitive :: u16 ; pub type Param0 = :: core :: primitive :: u16 ; } pub mod subnet_limit { use super :: runtime_types ; pub type SubnetLimit = :: core :: primitive :: u16 ; } pub mod total_networks { use super :: runtime_types ; pub type TotalNetworks = :: core :: primitive :: u16 ; } pub mod network_immunity_period { use super :: runtime_types ; pub type NetworkImmunityPeriod = :: core :: primitive :: u64 ; } pub mod network_last_registered { use super :: runtime_types ; pub type NetworkLastRegistered = :: core :: primitive :: u64 ; } pub mod network_min_allowed_uids { use super :: runtime_types ; pub type NetworkMinAllowedUids = :: core :: primitive :: u16 ; } pub mod network_min_lock_cost { use super :: runtime_types ; pub type NetworkMinLockCost = :: core :: primitive :: u64 ; } pub mod network_last_lock_cost { use super :: runtime_types ; pub type NetworkLastLockCost = :: core :: primitive :: u64 ; } pub mod network_lock_reduction_interval { use super :: runtime_types ; pub type NetworkLockReductionInterval = :: core :: primitive :: u64 ; } pub mod subnet_owner_cut { use super :: runtime_types ; pub type SubnetOwnerCut = :: core :: primitive :: u16 ; } pub mod network_rate_limit { use super :: runtime_types ; pub type NetworkRateLimit = :: core :: primitive :: u64 ; } pub mod nominator_min_required_stake { use super :: runtime_types ; pub type NominatorMinRequiredStake = :: core :: primitive :: u64 ; } pub mod subnetwork_n { use super :: runtime_types ; pub type SubnetworkN = :: core :: primitive :: u16 ; pub type Param0 = :: core :: primitive :: u16 ; } pub mod network_modality { use super :: runtime_types ; pub type NetworkModality = :: core :: primitive :: u16 ; pub type Param0 = :: core :: primitive :: u16 ; } pub mod networks_added { use super :: runtime_types ; pub type NetworksAdded = :: core :: primitive :: bool ; pub type Param0 = :: core :: primitive :: u16 ; } pub mod is_network_member { use super :: runtime_types ; pub type IsNetworkMember = :: core :: primitive :: bool ; pub type Param0 = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Param1 = :: core :: primitive :: u16 ; } pub mod network_registration_allowed { use super :: runtime_types ; pub type NetworkRegistrationAllowed = :: core :: primitive :: bool ; pub type Param0 = :: core :: primitive :: u16 ; } pub mod network_pow_registration_allowed { use super :: runtime_types ; pub type NetworkPowRegistrationAllowed = :: core :: primitive :: bool ; pub type Param0 = :: core :: primitive :: u16 ; } pub mod network_registered_at { use super :: runtime_types ; pub type NetworkRegisteredAt = :: core :: primitive :: u64 ; pub type Param0 = :: core :: primitive :: u16 ; } pub mod tempo { use super :: runtime_types ; pub type Tempo = :: core :: primitive :: u16 ; pub type Param0 = :: core :: primitive :: u16 ; } pub mod emission_values { use super :: runtime_types ; pub type EmissionValues = :: core :: primitive :: u64 ; pub type Param0 = :: core :: primitive :: u16 ; } pub mod pending_emission { use super :: runtime_types ; pub type PendingEmission = :: core :: primitive :: u64 ; pub type Param0 = :: core :: primitive :: u16 ; } pub mod blocks_since_last_step { use super :: runtime_types ; pub type BlocksSinceLastStep = :: core :: primitive :: u64 ; pub type Param0 = :: core :: primitive :: u16 ; } pub mod last_mechansim_step_block { use super :: runtime_types ; pub type LastMechansimStepBlock = :: core :: primitive :: u64 ; pub type Param0 = :: core :: primitive :: u16 ; } pub mod subnet_owner { use super :: runtime_types ; pub type SubnetOwner = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Param0 = :: core :: primitive :: u16 ; } pub mod subnet_locked { use super :: runtime_types ; pub type SubnetLocked = :: core :: primitive :: u64 ; pub type Param0 = :: core :: primitive :: u16 ; } pub mod serving_rate_limit { use super :: runtime_types ; pub type ServingRateLimit = :: core :: primitive :: u64 ; pub type Param0 = :: core :: primitive :: u16 ; } pub mod rho { use super :: runtime_types ; pub type Rho = :: core :: primitive :: u16 ; pub type Param0 = :: core :: primitive :: u16 ; } pub mod kappa { use super :: runtime_types ; pub type Kappa = :: core :: primitive :: u16 ; pub type Param0 = :: core :: primitive :: u16 ; } pub mod neurons_to_prune_at_next_epoch { use super :: runtime_types ; pub type NeuronsToPruneAtNextEpoch = :: core :: primitive :: u16 ; pub type Param0 = :: core :: primitive :: u16 ; } pub mod registrations_this_interval { use super :: runtime_types ; pub type RegistrationsThisInterval = :: core :: primitive :: u16 ; pub type Param0 = :: core :: primitive :: u16 ; } pub mod pow_registrations_this_interval { use super :: runtime_types ; pub type PowRegistrationsThisInterval = :: core :: primitive :: u16 ; pub type Param0 = :: core :: primitive :: u16 ; } pub mod burn_registrations_this_interval { use super :: runtime_types ; pub type BurnRegistrationsThisInterval = :: core :: primitive :: u16 ; pub type Param0 = :: core :: primitive :: u16 ; } pub mod max_allowed_uids { use super :: runtime_types ; pub type MaxAllowedUids = :: core :: primitive :: u16 ; pub type Param0 = :: core :: primitive :: u16 ; } pub mod immunity_period { use super :: runtime_types ; pub type ImmunityPeriod = :: core :: primitive :: u16 ; pub type Param0 = :: core :: primitive :: u16 ; } pub mod activity_cutoff { use super :: runtime_types ; pub type ActivityCutoff = :: core :: primitive :: u16 ; pub type Param0 = :: core :: primitive :: u16 ; } pub mod max_weights_limit { use super :: runtime_types ; pub type MaxWeightsLimit = :: core :: primitive :: u16 ; pub type Param0 = :: core :: primitive :: u16 ; } pub mod weights_version_key { use super :: runtime_types ; pub type WeightsVersionKey = :: core :: primitive :: u64 ; pub type Param0 = :: core :: primitive :: u16 ; } pub mod min_allowed_weights { use super :: runtime_types ; pub type MinAllowedWeights = :: core :: primitive :: u16 ; pub type Param0 = :: core :: primitive :: u16 ; } pub mod max_allowed_validators { use super :: runtime_types ; pub type MaxAllowedValidators = :: core :: primitive :: u16 ; pub type Param0 = :: core :: primitive :: u16 ; } pub mod adjustment_interval { use super :: runtime_types ; pub type AdjustmentInterval = :: core :: primitive :: u16 ; pub type Param0 = :: core :: primitive :: u16 ; } pub mod bonds_moving_average { use super :: runtime_types ; pub type BondsMovingAverage = :: core :: primitive :: u64 ; pub type Param0 = :: core :: primitive :: u16 ; } pub mod weights_set_rate_limit { use super :: runtime_types ; pub type WeightsSetRateLimit = :: core :: primitive :: u64 ; pub type Param0 = :: core :: primitive :: u16 ; } pub mod validator_prune_len { use super :: runtime_types ; pub type ValidatorPruneLen = :: core :: primitive :: u64 ; pub type Param0 = :: core :: primitive :: u16 ; } pub mod scaling_law_power { use super :: runtime_types ; pub type ScalingLawPower = :: core :: primitive :: u16 ; pub type Param0 = :: core :: primitive :: u16 ; } pub mod target_registrations_per_interval { use super :: runtime_types ; pub type TargetRegistrationsPerInterval = :: core :: primitive :: u16 ; pub type Param0 = :: core :: primitive :: u16 ; } pub mod adjustment_alpha { use super :: runtime_types ; pub type AdjustmentAlpha = :: core :: primitive :: u64 ; pub type Param0 = :: core :: primitive :: u16 ; } pub mod weight_commit_reveal_interval { use super :: runtime_types ; pub type WeightCommitRevealInterval = :: core :: primitive :: u64 ; pub type Param0 = :: core :: primitive :: u16 ; } pub mod commit_reveal_weights_enabled { use super :: runtime_types ; pub type CommitRevealWeightsEnabled = :: core :: primitive :: bool ; pub type Param0 = :: core :: primitive :: u16 ; } pub mod burn { use super :: runtime_types ; pub type Burn = :: core :: primitive :: u64 ; pub type Param0 = :: core :: primitive :: u16 ; } pub mod difficulty { use super :: runtime_types ; pub type Difficulty = :: core :: primitive :: u64 ; pub type Param0 = :: core :: primitive :: u16 ; } pub mod min_burn { use super :: runtime_types ; pub type MinBurn = :: core :: primitive :: u64 ; pub type Param0 = :: core :: primitive :: u16 ; } pub mod max_burn { use super :: runtime_types ; pub type MaxBurn = :: core :: primitive :: u64 ; pub type Param0 = :: core :: primitive :: u16 ; } pub mod min_difficulty { use super :: runtime_types ; pub type MinDifficulty = :: core :: primitive :: u64 ; pub type Param0 = :: core :: primitive :: u16 ; } pub mod max_difficulty { use super :: runtime_types ; pub type MaxDifficulty = :: core :: primitive :: u64 ; pub type Param0 = :: core :: primitive :: u16 ; } pub mod last_adjustment_block { use super :: runtime_types ; pub type LastAdjustmentBlock = :: core :: primitive :: u64 ; pub type Param0 = :: core :: primitive :: u16 ; } pub mod registrations_this_block { use super :: runtime_types ; pub type RegistrationsThisBlock = :: core :: primitive :: u16 ; pub type Param0 = :: core :: primitive :: u16 ; } pub mod rao_recycled_for_registration { use super :: runtime_types ; pub type RaoRecycledForRegistration = :: core :: primitive :: u64 ; pub type Param0 = :: core :: primitive :: u16 ; } pub mod tx_rate_limit { use super :: runtime_types ; pub type TxRateLimit = :: core :: primitive :: u64 ; } pub mod tx_delegate_take_rate_limit { use super :: runtime_types ; pub type TxDelegateTakeRateLimit = :: core :: primitive :: u64 ; } pub mod tx_childkey_take_rate_limit { use super :: runtime_types ; pub type TxChildkeyTakeRateLimit = :: core :: primitive :: u64 ; } pub mod liquid_alpha_on { use super :: runtime_types ; pub type LiquidAlphaOn = :: core :: primitive :: bool ; pub type Param0 = :: core :: primitive :: u16 ; } pub mod alpha_values { use super :: runtime_types ; pub type AlphaValues = (:: core :: primitive :: u16 , :: core :: primitive :: u16 ,) ; pub type Param0 = :: core :: primitive :: u16 ; } pub mod network_max_stake { use super :: runtime_types ; pub type NetworkMaxStake = :: core :: primitive :: u64 ; pub type Param0 = :: core :: primitive :: u16 ; } pub mod stake_weight { use super :: runtime_types ; pub type StakeWeight = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u16 > ; pub type Param0 = :: core :: primitive :: u16 ; } pub mod uids { use super :: runtime_types ; pub type Uids = :: core :: primitive :: u16 ; pub type Param0 = :: core :: primitive :: u16 ; pub type Param1 = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } pub mod keys { use super :: runtime_types ; pub type Keys = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Param0 = :: core :: primitive :: u16 ; pub type Param1 = :: core :: primitive :: u16 ; } pub mod loaded_emission { use super :: runtime_types ; pub type LoadedEmission = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < (:: subxt :: ext :: subxt_core :: utils :: AccountId32 , :: core :: primitive :: u64 , :: core :: primitive :: u64 ,) > ; pub type Param0 = :: core :: primitive :: u16 ; } pub mod active { use super :: runtime_types ; pub type Active = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: bool > ; pub type Param0 = :: core :: primitive :: u16 ; } pub mod rank { use super :: runtime_types ; pub type Rank = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u16 > ; pub type Param0 = :: core :: primitive :: u16 ; } pub mod trust { use super :: runtime_types ; pub type Trust = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u16 > ; pub type Param0 = :: core :: primitive :: u16 ; } pub mod consensus { use super :: runtime_types ; pub type Consensus = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u16 > ; pub type Param0 = :: core :: primitive :: u16 ; } pub mod incentive { use super :: runtime_types ; pub type Incentive = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u16 > ; pub type Param0 = :: core :: primitive :: u16 ; } pub mod dividends { use super :: runtime_types ; pub type Dividends = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u16 > ; pub type Param0 = :: core :: primitive :: u16 ; } pub mod emission { use super :: runtime_types ; pub type Emission = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u64 > ; pub type Param0 = :: core :: primitive :: u16 ; } pub mod last_update { use super :: runtime_types ; pub type LastUpdate = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u64 > ; pub type Param0 = :: core :: primitive :: u16 ; } pub mod validator_trust { use super :: runtime_types ; pub type ValidatorTrust = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u16 > ; pub type Param0 = :: core :: primitive :: u16 ; } pub mod pruning_scores { use super :: runtime_types ; pub type PruningScores = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u16 > ; pub type Param0 = :: core :: primitive :: u16 ; } pub mod validator_permit { use super :: runtime_types ; pub type ValidatorPermit = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: bool > ; pub type Param0 = :: core :: primitive :: u16 ; } pub mod weights { use super :: runtime_types ; pub type Weights = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < (:: core :: primitive :: u16 , :: core :: primitive :: u16 ,) > ; pub type Param0 = :: core :: primitive :: u16 ; pub type Param1 = :: core :: primitive :: u16 ; } pub mod bonds { use super :: runtime_types ; pub type Bonds = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < (:: core :: primitive :: u16 , :: core :: primitive :: u16 ,) > ; pub type Param0 = :: core :: primitive :: u16 ; pub type Param1 = :: core :: primitive :: u16 ; } pub mod block_at_registration { use super :: runtime_types ; pub type BlockAtRegistration = :: core :: primitive :: u64 ; pub type Param0 = :: core :: primitive :: u16 ; pub type Param1 = :: core :: primitive :: u16 ; } pub mod axons { use super :: runtime_types ; pub type Axons = runtime_types :: pallet_subtensor :: pallet :: AxonInfo ; pub type Param0 = :: core :: primitive :: u16 ; pub type Param1 = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } pub mod prometheus { use super :: runtime_types ; pub type Prometheus = runtime_types :: pallet_subtensor :: pallet :: PrometheusInfo ; pub type Param0 = :: core :: primitive :: u16 ; pub type Param1 = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } pub mod identities { use super :: runtime_types ; pub type Identities = runtime_types :: pallet_subtensor :: pallet :: ChainIdentity ; pub type Param0 = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } pub mod subnet_identities { use super :: runtime_types ; pub type SubnetIdentities = runtime_types :: pallet_subtensor :: pallet :: SubnetIdentity ; pub type Param0 = :: core :: primitive :: u16 ; } pub mod transaction_key_last_block { use super :: runtime_types ; pub type TransactionKeyLastBlock = :: core :: primitive :: u64 ; pub type Param0 = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Param1 = :: core :: primitive :: u16 ; pub type Param2 = :: core :: primitive :: u16 ; } pub mod last_tx_block { use super :: runtime_types ; pub type LastTxBlock = :: core :: primitive :: u64 ; pub type Param0 = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } pub mod last_tx_block_child_key_take { use super :: runtime_types ; pub type LastTxBlockChildKeyTake = :: core :: primitive :: u64 ; pub type Param0 = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } pub mod last_tx_block_delegate_take { use super :: runtime_types ; pub type LastTxBlockDelegateTake = :: core :: primitive :: u64 ; pub type Param0 = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } pub mod weights_min_stake { use super :: runtime_types ; pub type WeightsMinStake = :: core :: primitive :: u64 ; } pub mod weight_commits { use super :: runtime_types ; pub type WeightCommits = (:: subxt :: ext :: subxt_core :: utils :: H256 , :: core :: primitive :: u64 ,) ; pub type Param0 = :: core :: primitive :: u16 ; pub type Param1 = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } pub mod has_migration_run { use super :: runtime_types ; pub type HasMigrationRun = :: core :: primitive :: bool ; pub type Param0 = [:: core :: primitive :: u8] ; } } pub struct StorageApi ; impl StorageApi { pub fn coldkey_swap_schedule_duration (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: coldkey_swap_schedule_duration :: ColdkeySwapScheduleDuration , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "ColdkeySwapScheduleDuration" , () , [135u8 , 38u8 , 13u8 , 187u8 , 124u8 , 153u8 , 35u8 , 200u8 , 169u8 , 106u8 , 128u8 , 162u8 , 134u8 , 165u8 , 63u8 , 169u8 , 96u8 , 65u8 , 222u8 , 42u8 , 31u8 , 9u8 , 12u8 , 42u8 , 84u8 , 13u8 , 24u8 , 221u8 , 186u8 , 245u8 , 126u8 , 4u8 ,]) } pub fn dissolve_network_schedule_duration (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: dissolve_network_schedule_duration :: DissolveNetworkScheduleDuration , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "DissolveNetworkScheduleDuration" , () , [211u8 , 28u8 , 73u8 , 53u8 , 21u8 , 221u8 , 68u8 , 103u8 , 73u8 , 81u8 , 235u8 , 185u8 , 185u8 , 120u8 , 64u8 , 149u8 , 189u8 , 49u8 , 250u8 , 173u8 , 74u8 , 31u8 , 228u8 , 139u8 , 187u8 , 6u8 , 77u8 , 242u8 , 15u8 , 41u8 , 184u8 , 27u8 ,]) } pub fn senate_required_stake_percentage (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: senate_required_stake_percentage :: SenateRequiredStakePercentage , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "SenateRequiredStakePercentage" , () , [113u8 , 251u8 , 37u8 , 5u8 , 78u8 , 161u8 , 44u8 , 216u8 , 5u8 , 216u8 , 141u8 , 243u8 , 254u8 , 116u8 , 149u8 , 171u8 , 168u8 , 21u8 , 79u8 , 43u8 , 40u8 , 14u8 , 30u8 , 89u8 , 216u8 , 35u8 , 80u8 , 85u8 , 17u8 , 69u8 , 252u8 , 232u8 ,]) } # [doc = " ============================"] # [doc = " ==== Staking Variables ===="] # [doc = " ============================"] # [doc = " The Subtensor [`TotalIssuance`] represents the total issuance of tokens on the Bittensor network."] # [doc = ""] # [doc = " It is comprised of three parts:"] # [doc = " - The total amount of issued tokens, tracked in the TotalIssuance of the Balances pallet"] # [doc = " - The total amount of tokens staked in the system, tracked in [`TotalStake`]"] # [doc = " - The total amount of tokens locked up for subnet reg, tracked in [`TotalSubnetLocked`] attained by iterating over subnet lock."] # [doc = ""] # [doc = " Eventually, Bittensor should migrate to using Holds afterwhich time we will not require this"] # [doc = " separate accounting."] pub fn total_issuance (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: total_issuance :: TotalIssuance , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "TotalIssuance" , () , [157u8 , 166u8 , 49u8 , 95u8 , 245u8 , 38u8 , 96u8 , 83u8 , 23u8 , 203u8 , 246u8 , 208u8 , 251u8 , 175u8 , 40u8 , 92u8 , 163u8 , 112u8 , 43u8 , 190u8 , 14u8 , 128u8 , 45u8 , 22u8 , 157u8 , 205u8 , 181u8 , 84u8 , 79u8 , 132u8 , 160u8 , 149u8 ,]) } pub fn total_stake (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: total_stake :: TotalStake , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "TotalStake" , () , [179u8 , 22u8 , 207u8 , 201u8 , 118u8 , 12u8 , 198u8 , 201u8 , 2u8 , 169u8 , 161u8 , 226u8 , 10u8 , 93u8 , 135u8 , 70u8 , 46u8 , 220u8 , 50u8 , 228u8 , 18u8 , 135u8 , 64u8 , 233u8 , 77u8 , 95u8 , 159u8 , 199u8 , 8u8 , 47u8 , 0u8 , 60u8 ,]) } pub fn max_delegate_take (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: max_delegate_take :: MaxDelegateTake , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "MaxDelegateTake" , () , [140u8 , 164u8 , 254u8 , 107u8 , 142u8 , 50u8 , 152u8 , 230u8 , 173u8 , 9u8 , 98u8 , 65u8 , 238u8 , 216u8 , 232u8 , 162u8 , 68u8 , 74u8 , 9u8 , 88u8 , 99u8 , 40u8 , 69u8 , 238u8 , 60u8 , 137u8 , 184u8 , 169u8 , 173u8 , 29u8 , 203u8 , 190u8 ,]) } pub fn min_delegate_take (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: min_delegate_take :: MinDelegateTake , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "MinDelegateTake" , () , [253u8 , 210u8 , 73u8 , 231u8 , 97u8 , 29u8 , 51u8 , 11u8 , 3u8 , 233u8 , 117u8 , 175u8 , 223u8 , 31u8 , 81u8 , 246u8 , 186u8 , 58u8 , 255u8 , 62u8 , 65u8 , 236u8 , 204u8 , 200u8 , 42u8 , 125u8 , 127u8 , 209u8 , 113u8 , 241u8 , 165u8 , 234u8 ,]) } pub fn max_childkey_take (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: max_childkey_take :: MaxChildkeyTake , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "MaxChildkeyTake" , () , [232u8 , 205u8 , 201u8 , 56u8 , 228u8 , 129u8 , 26u8 , 148u8 , 26u8 , 152u8 , 98u8 , 38u8 , 249u8 , 185u8 , 100u8 , 185u8 , 221u8 , 16u8 , 150u8 , 192u8 , 48u8 , 103u8 , 29u8 , 183u8 , 241u8 , 152u8 , 234u8 , 210u8 , 179u8 , 100u8 , 213u8 , 108u8 ,]) } pub fn min_childkey_take (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: min_childkey_take :: MinChildkeyTake , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "MinChildkeyTake" , () , [34u8 , 107u8 , 136u8 , 127u8 , 157u8 , 247u8 , 199u8 , 54u8 , 84u8 , 226u8 , 206u8 , 246u8 , 19u8 , 95u8 , 3u8 , 152u8 , 190u8 , 207u8 , 171u8 , 143u8 , 224u8 , 125u8 , 113u8 , 50u8 , 201u8 , 229u8 , 144u8 , 172u8 , 64u8 , 182u8 , 228u8 , 107u8 ,]) } pub fn block_emission (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: block_emission :: BlockEmission , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "BlockEmission" , () , [223u8 , 151u8 , 249u8 , 123u8 , 202u8 , 93u8 , 99u8 , 232u8 , 117u8 , 221u8 , 57u8 , 50u8 , 104u8 , 65u8 , 167u8 , 199u8 , 188u8 , 167u8 , 146u8 , 32u8 , 97u8 , 156u8 , 192u8 , 88u8 , 82u8 , 228u8 , 88u8 , 171u8 , 139u8 , 207u8 , 28u8 , 183u8 ,]) } pub fn target_stakes_per_interval (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: target_stakes_per_interval :: TargetStakesPerInterval , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "TargetStakesPerInterval" , () , [217u8 , 169u8 , 34u8 , 244u8 , 169u8 , 67u8 , 255u8 , 56u8 , 25u8 , 235u8 , 125u8 , 150u8 , 91u8 , 229u8 , 170u8 , 0u8 , 233u8 , 39u8 , 155u8 , 230u8 , 61u8 , 142u8 , 150u8 , 68u8 , 154u8 , 26u8 , 27u8 , 231u8 , 221u8 , 15u8 , 172u8 , 139u8 ,]) } pub fn stake_interval (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: stake_interval :: StakeInterval , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "StakeInterval" , () , [26u8 , 127u8 , 250u8 , 202u8 , 142u8 , 226u8 , 247u8 , 4u8 , 88u8 , 13u8 , 142u8 , 28u8 , 58u8 , 220u8 , 226u8 , 122u8 , 232u8 , 29u8 , 106u8 , 125u8 , 220u8 , 46u8 , 51u8 , 112u8 , 54u8 , 28u8 , 106u8 , 21u8 , 212u8 , 221u8 , 134u8 , 92u8 ,]) } pub fn total_hotkey_stake_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: total_hotkey_stake :: TotalHotkeyStake , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "TotalHotkeyStake" , () , [228u8 , 18u8 , 98u8 , 62u8 , 42u8 , 215u8 , 120u8 , 221u8 , 182u8 , 254u8 , 114u8 , 37u8 , 18u8 , 65u8 , 20u8 , 226u8 , 143u8 , 83u8 , 151u8 , 191u8 , 171u8 , 176u8 , 49u8 , 110u8 , 32u8 , 123u8 , 206u8 , 102u8 , 233u8 , 96u8 , 148u8 , 52u8 ,]) } pub fn total_hotkey_stake (& self , _0 : impl :: core :: borrow :: Borrow < types :: total_hotkey_stake :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: total_hotkey_stake :: Param0 > , types :: total_hotkey_stake :: TotalHotkeyStake , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "TotalHotkeyStake" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [228u8 , 18u8 , 98u8 , 62u8 , 42u8 , 215u8 , 120u8 , 221u8 , 182u8 , 254u8 , 114u8 , 37u8 , 18u8 , 65u8 , 20u8 , 226u8 , 143u8 , 83u8 , 151u8 , 191u8 , 171u8 , 176u8 , 49u8 , 110u8 , 32u8 , 123u8 , 206u8 , 102u8 , 233u8 , 96u8 , 148u8 , 52u8 ,]) } pub fn total_coldkey_stake_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: total_coldkey_stake :: TotalColdkeyStake , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "TotalColdkeyStake" , () , [99u8 , 229u8 , 249u8 , 40u8 , 223u8 , 180u8 , 85u8 , 199u8 , 250u8 , 243u8 , 142u8 , 94u8 , 126u8 , 202u8 , 149u8 , 111u8 , 155u8 , 197u8 , 243u8 , 225u8 , 210u8 , 27u8 , 166u8 , 210u8 , 11u8 , 87u8 , 179u8 , 133u8 , 25u8 , 50u8 , 68u8 , 149u8 ,]) } pub fn total_coldkey_stake (& self , _0 : impl :: core :: borrow :: Borrow < types :: total_coldkey_stake :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: total_coldkey_stake :: Param0 > , types :: total_coldkey_stake :: TotalColdkeyStake , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "TotalColdkeyStake" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [99u8 , 229u8 , 249u8 , 40u8 , 223u8 , 180u8 , 85u8 , 199u8 , 250u8 , 243u8 , 142u8 , 94u8 , 126u8 , 202u8 , 149u8 , 111u8 , 155u8 , 197u8 , 243u8 , 225u8 , 210u8 , 27u8 , 166u8 , 210u8 , 11u8 , 87u8 , 179u8 , 133u8 , 25u8 , 50u8 , 68u8 , 149u8 ,]) } # [doc = " MAP (hot, cold) --> stake | Returns a tuple (u64: stakes, u64: block_number)"] pub fn total_hotkey_coldkey_stakes_this_interval_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: total_hotkey_coldkey_stakes_this_interval :: TotalHotkeyColdkeyStakesThisInterval , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "TotalHotkeyColdkeyStakesThisInterval" , () , [253u8 , 52u8 , 153u8 , 75u8 , 246u8 , 136u8 , 240u8 , 204u8 , 79u8 , 88u8 , 234u8 , 75u8 , 118u8 , 175u8 , 224u8 , 163u8 , 45u8 , 204u8 , 73u8 , 45u8 , 147u8 , 222u8 , 103u8 , 162u8 , 147u8 , 46u8 , 72u8 , 65u8 , 151u8 , 154u8 , 88u8 , 132u8 ,]) } # [doc = " MAP (hot, cold) --> stake | Returns a tuple (u64: stakes, u64: block_number)"] pub fn total_hotkey_coldkey_stakes_this_interval_iter1 (& self , _0 : impl :: core :: borrow :: Borrow < types :: total_hotkey_coldkey_stakes_this_interval :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: total_hotkey_coldkey_stakes_this_interval :: Param0 > , types :: total_hotkey_coldkey_stakes_this_interval :: TotalHotkeyColdkeyStakesThisInterval , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "TotalHotkeyColdkeyStakesThisInterval" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [253u8 , 52u8 , 153u8 , 75u8 , 246u8 , 136u8 , 240u8 , 204u8 , 79u8 , 88u8 , 234u8 , 75u8 , 118u8 , 175u8 , 224u8 , 163u8 , 45u8 , 204u8 , 73u8 , 45u8 , 147u8 , 222u8 , 103u8 , 162u8 , 147u8 , 46u8 , 72u8 , 65u8 , 151u8 , 154u8 , 88u8 , 132u8 ,]) } # [doc = " MAP (hot, cold) --> stake | Returns a tuple (u64: stakes, u64: block_number)"] pub fn total_hotkey_coldkey_stakes_this_interval (& self , _0 : impl :: core :: borrow :: Borrow < types :: total_hotkey_coldkey_stakes_this_interval :: Param0 > , _1 : impl :: core :: borrow :: Borrow < types :: total_hotkey_coldkey_stakes_this_interval :: Param1 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < (:: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: total_hotkey_coldkey_stakes_this_interval :: Param0 > , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: total_hotkey_coldkey_stakes_this_interval :: Param1 > ,) , types :: total_hotkey_coldkey_stakes_this_interval :: TotalHotkeyColdkeyStakesThisInterval , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "TotalHotkeyColdkeyStakesThisInterval" , (:: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_1 . borrow ()) ,) , [253u8 , 52u8 , 153u8 , 75u8 , 246u8 , 136u8 , 240u8 , 204u8 , 79u8 , 88u8 , 234u8 , 75u8 , 118u8 , 175u8 , 224u8 , 163u8 , 45u8 , 204u8 , 73u8 , 45u8 , 147u8 , 222u8 , 103u8 , 162u8 , 147u8 , 46u8 , 72u8 , 65u8 , 151u8 , 154u8 , 88u8 , 132u8 ,]) } # [doc = " MAP ( hot ) --> cold | Returns the controlling coldkey for a hotkey."] pub fn owner_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: owner :: Owner , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "Owner" , () , [42u8 , 187u8 , 183u8 , 236u8 , 168u8 , 211u8 , 164u8 , 206u8 , 104u8 , 89u8 , 156u8 , 12u8 , 1u8 , 65u8 , 130u8 , 16u8 , 104u8 , 229u8 , 168u8 , 245u8 , 123u8 , 31u8 , 228u8 , 72u8 , 122u8 , 14u8 , 38u8 , 188u8 , 45u8 , 35u8 , 16u8 , 132u8 ,]) } # [doc = " MAP ( hot ) --> cold | Returns the controlling coldkey for a hotkey."] pub fn owner (& self , _0 : impl :: core :: borrow :: Borrow < types :: owner :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: owner :: Param0 > , types :: owner :: Owner , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "Owner" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [42u8 , 187u8 , 183u8 , 236u8 , 168u8 , 211u8 , 164u8 , 206u8 , 104u8 , 89u8 , 156u8 , 12u8 , 1u8 , 65u8 , 130u8 , 16u8 , 104u8 , 229u8 , 168u8 , 245u8 , 123u8 , 31u8 , 228u8 , 72u8 , 122u8 , 14u8 , 38u8 , 188u8 , 45u8 , 35u8 , 16u8 , 132u8 ,]) } # [doc = " MAP ( hot ) --> take | Returns the hotkey delegation take. And signals that this key is open for delegation."] pub fn delegates_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: delegates :: Delegates , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "Delegates" , () , [44u8 , 10u8 , 104u8 , 255u8 , 105u8 , 110u8 , 131u8 , 174u8 , 247u8 , 100u8 , 165u8 , 220u8 , 198u8 , 71u8 , 212u8 , 83u8 , 238u8 , 109u8 , 61u8 , 53u8 , 175u8 , 29u8 , 233u8 , 38u8 , 56u8 , 76u8 , 41u8 , 207u8 , 169u8 , 70u8 , 141u8 , 251u8 ,]) } # [doc = " MAP ( hot ) --> take | Returns the hotkey delegation take. And signals that this key is open for delegation."] pub fn delegates (& self , _0 : impl :: core :: borrow :: Borrow < types :: delegates :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: delegates :: Param0 > , types :: delegates :: Delegates , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "Delegates" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [44u8 , 10u8 , 104u8 , 255u8 , 105u8 , 110u8 , 131u8 , 174u8 , 247u8 , 100u8 , 165u8 , 220u8 , 198u8 , 71u8 , 212u8 , 83u8 , 238u8 , 109u8 , 61u8 , 53u8 , 175u8 , 29u8 , 233u8 , 38u8 , 56u8 , 76u8 , 41u8 , 207u8 , 169u8 , 70u8 , 141u8 , 251u8 ,]) } # [doc = " DMAP ( hot, netuid ) --> take | Returns the hotkey childkey take for a specific subnet"] pub fn childkey_take_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: childkey_take :: ChildkeyTake , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "ChildkeyTake" , () , [130u8 , 71u8 , 111u8 , 167u8 , 104u8 , 2u8 , 244u8 , 86u8 , 145u8 , 164u8 , 235u8 , 205u8 , 163u8 , 63u8 , 188u8 , 204u8 , 147u8 , 179u8 , 72u8 , 153u8 , 247u8 , 116u8 , 17u8 , 228u8 , 121u8 , 77u8 , 172u8 , 133u8 , 164u8 , 248u8 , 158u8 , 54u8 ,]) } # [doc = " DMAP ( hot, netuid ) --> take | Returns the hotkey childkey take for a specific subnet"] pub fn childkey_take_iter1 (& self , _0 : impl :: core :: borrow :: Borrow < types :: childkey_take :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: childkey_take :: Param0 > , types :: childkey_take :: ChildkeyTake , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "ChildkeyTake" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [130u8 , 71u8 , 111u8 , 167u8 , 104u8 , 2u8 , 244u8 , 86u8 , 145u8 , 164u8 , 235u8 , 205u8 , 163u8 , 63u8 , 188u8 , 204u8 , 147u8 , 179u8 , 72u8 , 153u8 , 247u8 , 116u8 , 17u8 , 228u8 , 121u8 , 77u8 , 172u8 , 133u8 , 164u8 , 248u8 , 158u8 , 54u8 ,]) } # [doc = " DMAP ( hot, netuid ) --> take | Returns the hotkey childkey take for a specific subnet"] pub fn childkey_take (& self , _0 : impl :: core :: borrow :: Borrow < types :: childkey_take :: Param0 > , _1 : impl :: core :: borrow :: Borrow < types :: childkey_take :: Param1 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < (:: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: childkey_take :: Param0 > , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: childkey_take :: Param1 > ,) , types :: childkey_take :: ChildkeyTake , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "ChildkeyTake" , (:: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_1 . borrow ()) ,) , [130u8 , 71u8 , 111u8 , 167u8 , 104u8 , 2u8 , 244u8 , 86u8 , 145u8 , 164u8 , 235u8 , 205u8 , 163u8 , 63u8 , 188u8 , 204u8 , 147u8 , 179u8 , 72u8 , 153u8 , 247u8 , 116u8 , 17u8 , 228u8 , 121u8 , 77u8 , 172u8 , 133u8 , 164u8 , 248u8 , 158u8 , 54u8 ,]) } # [doc = " DMAP ( hot, cold ) --> stake | Returns the stake under a coldkey prefixed by hotkey."] pub fn stake_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: stake :: Stake , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "Stake" , () , [28u8 , 30u8 , 204u8 , 218u8 , 103u8 , 20u8 , 5u8 , 28u8 , 97u8 , 212u8 , 142u8 , 210u8 , 32u8 , 44u8 , 179u8 , 22u8 , 141u8 , 86u8 , 53u8 , 97u8 , 169u8 , 50u8 , 157u8 , 66u8 , 180u8 , 240u8 , 142u8 , 198u8 , 252u8 , 13u8 , 25u8 , 60u8 ,]) } # [doc = " DMAP ( hot, cold ) --> stake | Returns the stake under a coldkey prefixed by hotkey."] pub fn stake_iter1 (& self , _0 : impl :: core :: borrow :: Borrow < types :: stake :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: stake :: Param0 > , types :: stake :: Stake , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "Stake" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [28u8 , 30u8 , 204u8 , 218u8 , 103u8 , 20u8 , 5u8 , 28u8 , 97u8 , 212u8 , 142u8 , 210u8 , 32u8 , 44u8 , 179u8 , 22u8 , 141u8 , 86u8 , 53u8 , 97u8 , 169u8 , 50u8 , 157u8 , 66u8 , 180u8 , 240u8 , 142u8 , 198u8 , 252u8 , 13u8 , 25u8 , 60u8 ,]) } # [doc = " DMAP ( hot, cold ) --> stake | Returns the stake under a coldkey prefixed by hotkey."] pub fn stake (& self , _0 : impl :: core :: borrow :: Borrow < types :: stake :: Param0 > , _1 : impl :: core :: borrow :: Borrow < types :: stake :: Param1 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < (:: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: stake :: Param0 > , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: stake :: Param1 > ,) , types :: stake :: Stake , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "Stake" , (:: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_1 . borrow ()) ,) , [28u8 , 30u8 , 204u8 , 218u8 , 103u8 , 20u8 , 5u8 , 28u8 , 97u8 , 212u8 , 142u8 , 210u8 , 32u8 , 44u8 , 179u8 , 22u8 , 141u8 , 86u8 , 53u8 , 97u8 , 169u8 , 50u8 , 157u8 , 66u8 , 180u8 , 240u8 , 142u8 , 198u8 , 252u8 , 13u8 , 25u8 , 60u8 ,]) } # [doc = " Map ( hot ) --> last_hotkey_emission_drain | Last block we drained this hotkey's emission."] pub fn last_hotkey_emission_drain_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: last_hotkey_emission_drain :: LastHotkeyEmissionDrain , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "LastHotkeyEmissionDrain" , () , [115u8 , 225u8 , 129u8 , 244u8 , 225u8 , 103u8 , 163u8 , 92u8 , 103u8 , 52u8 , 101u8 , 147u8 , 206u8 , 28u8 , 143u8 , 186u8 , 163u8 , 194u8 , 87u8 , 104u8 , 140u8 , 222u8 , 133u8 , 182u8 , 183u8 , 211u8 , 198u8 , 116u8 , 229u8 , 86u8 , 101u8 , 232u8 ,]) } # [doc = " Map ( hot ) --> last_hotkey_emission_drain | Last block we drained this hotkey's emission."] pub fn last_hotkey_emission_drain (& self , _0 : impl :: core :: borrow :: Borrow < types :: last_hotkey_emission_drain :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: last_hotkey_emission_drain :: Param0 > , types :: last_hotkey_emission_drain :: LastHotkeyEmissionDrain , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "LastHotkeyEmissionDrain" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [115u8 , 225u8 , 129u8 , 244u8 , 225u8 , 103u8 , 163u8 , 92u8 , 103u8 , 52u8 , 101u8 , 147u8 , 206u8 , 28u8 , 143u8 , 186u8 , 163u8 , 194u8 , 87u8 , 104u8 , 140u8 , 222u8 , 133u8 , 182u8 , 183u8 , 211u8 , 198u8 , 116u8 , 229u8 , 86u8 , 101u8 , 232u8 ,]) } # [doc = " ITEM ( hotkey_emission_tempo )"] pub fn hotkey_emission_tempo (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: hotkey_emission_tempo :: HotkeyEmissionTempo , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "HotkeyEmissionTempo" , () , [170u8 , 237u8 , 13u8 , 9u8 , 97u8 , 208u8 , 235u8 , 51u8 , 60u8 , 191u8 , 36u8 , 129u8 , 18u8 , 18u8 , 90u8 , 86u8 , 113u8 , 113u8 , 198u8 , 88u8 , 246u8 , 208u8 , 30u8 , 189u8 , 253u8 , 23u8 , 244u8 , 225u8 , 138u8 , 190u8 , 94u8 , 25u8 ,]) } # [doc = " Map ( hot ) --> emission | Accumulated hotkey emission."] pub fn pendingd_hotkey_emission_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: pendingd_hotkey_emission :: PendingdHotkeyEmission , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "PendingdHotkeyEmission" , () , [246u8 , 17u8 , 63u8 , 156u8 , 105u8 , 181u8 , 37u8 , 163u8 , 192u8 , 185u8 , 30u8 , 83u8 , 20u8 , 229u8 , 173u8 , 215u8 , 112u8 , 253u8 , 149u8 , 68u8 , 252u8 , 129u8 , 48u8 , 214u8 , 175u8 , 136u8 , 115u8 , 75u8 , 230u8 , 66u8 , 160u8 , 144u8 ,]) } # [doc = " Map ( hot ) --> emission | Accumulated hotkey emission."] pub fn pendingd_hotkey_emission (& self , _0 : impl :: core :: borrow :: Borrow < types :: pendingd_hotkey_emission :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: pendingd_hotkey_emission :: Param0 > , types :: pendingd_hotkey_emission :: PendingdHotkeyEmission , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "PendingdHotkeyEmission" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [246u8 , 17u8 , 63u8 , 156u8 , 105u8 , 181u8 , 37u8 , 163u8 , 192u8 , 185u8 , 30u8 , 83u8 , 20u8 , 229u8 , 173u8 , 215u8 , 112u8 , 253u8 , 149u8 , 68u8 , 252u8 , 129u8 , 48u8 , 214u8 , 175u8 , 136u8 , 115u8 , 75u8 , 230u8 , 66u8 , 160u8 , 144u8 ,]) } # [doc = " Map ( hot, cold ) --> block_number | Last add stake increase."] pub fn last_add_stake_increase_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: last_add_stake_increase :: LastAddStakeIncrease , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "LastAddStakeIncrease" , () , [96u8 , 205u8 , 98u8 , 64u8 , 65u8 , 174u8 , 100u8 , 39u8 , 180u8 , 191u8 , 130u8 , 160u8 , 40u8 , 103u8 , 155u8 , 163u8 , 3u8 , 158u8 , 92u8 , 36u8 , 234u8 , 208u8 , 124u8 , 200u8 , 67u8 , 154u8 , 20u8 , 3u8 , 78u8 , 26u8 , 86u8 , 133u8 ,]) } # [doc = " Map ( hot, cold ) --> block_number | Last add stake increase."] pub fn last_add_stake_increase_iter1 (& self , _0 : impl :: core :: borrow :: Borrow < types :: last_add_stake_increase :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: last_add_stake_increase :: Param0 > , types :: last_add_stake_increase :: LastAddStakeIncrease , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "LastAddStakeIncrease" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [96u8 , 205u8 , 98u8 , 64u8 , 65u8 , 174u8 , 100u8 , 39u8 , 180u8 , 191u8 , 130u8 , 160u8 , 40u8 , 103u8 , 155u8 , 163u8 , 3u8 , 158u8 , 92u8 , 36u8 , 234u8 , 208u8 , 124u8 , 200u8 , 67u8 , 154u8 , 20u8 , 3u8 , 78u8 , 26u8 , 86u8 , 133u8 ,]) } # [doc = " Map ( hot, cold ) --> block_number | Last add stake increase."] pub fn last_add_stake_increase (& self , _0 : impl :: core :: borrow :: Borrow < types :: last_add_stake_increase :: Param0 > , _1 : impl :: core :: borrow :: Borrow < types :: last_add_stake_increase :: Param1 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < (:: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: last_add_stake_increase :: Param0 > , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: last_add_stake_increase :: Param1 > ,) , types :: last_add_stake_increase :: LastAddStakeIncrease , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "LastAddStakeIncrease" , (:: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_1 . borrow ()) ,) , [96u8 , 205u8 , 98u8 , 64u8 , 65u8 , 174u8 , 100u8 , 39u8 , 180u8 , 191u8 , 130u8 , 160u8 , 40u8 , 103u8 , 155u8 , 163u8 , 3u8 , 158u8 , 92u8 , 36u8 , 234u8 , 208u8 , 124u8 , 200u8 , 67u8 , 154u8 , 20u8 , 3u8 , 78u8 , 26u8 , 86u8 , 133u8 ,]) } # [doc = " Map ( hot, cold ) --> stake: i128 | Stake added/removed since last emission drain."] pub fn stake_delta_since_last_emission_drain_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: stake_delta_since_last_emission_drain :: StakeDeltaSinceLastEmissionDrain , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "StakeDeltaSinceLastEmissionDrain" , () , [248u8 , 234u8 , 3u8 , 67u8 , 214u8 , 20u8 , 131u8 , 138u8 , 58u8 , 71u8 , 2u8 , 72u8 , 240u8 , 42u8 , 229u8 , 144u8 , 127u8 , 59u8 , 11u8 , 237u8 , 161u8 , 185u8 , 73u8 , 30u8 , 53u8 , 30u8 , 240u8 , 69u8 , 194u8 , 205u8 , 197u8 , 187u8 ,]) } # [doc = " Map ( hot, cold ) --> stake: i128 | Stake added/removed since last emission drain."] pub fn stake_delta_since_last_emission_drain_iter1 (& self , _0 : impl :: core :: borrow :: Borrow < types :: stake_delta_since_last_emission_drain :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: stake_delta_since_last_emission_drain :: Param0 > , types :: stake_delta_since_last_emission_drain :: StakeDeltaSinceLastEmissionDrain , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "StakeDeltaSinceLastEmissionDrain" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [248u8 , 234u8 , 3u8 , 67u8 , 214u8 , 20u8 , 131u8 , 138u8 , 58u8 , 71u8 , 2u8 , 72u8 , 240u8 , 42u8 , 229u8 , 144u8 , 127u8 , 59u8 , 11u8 , 237u8 , 161u8 , 185u8 , 73u8 , 30u8 , 53u8 , 30u8 , 240u8 , 69u8 , 194u8 , 205u8 , 197u8 , 187u8 ,]) } # [doc = " Map ( hot, cold ) --> stake: i128 | Stake added/removed since last emission drain."] pub fn stake_delta_since_last_emission_drain (& self , _0 : impl :: core :: borrow :: Borrow < types :: stake_delta_since_last_emission_drain :: Param0 > , _1 : impl :: core :: borrow :: Borrow < types :: stake_delta_since_last_emission_drain :: Param1 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < (:: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: stake_delta_since_last_emission_drain :: Param0 > , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: stake_delta_since_last_emission_drain :: Param1 > ,) , types :: stake_delta_since_last_emission_drain :: StakeDeltaSinceLastEmissionDrain , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "StakeDeltaSinceLastEmissionDrain" , (:: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_1 . borrow ()) ,) , [248u8 , 234u8 , 3u8 , 67u8 , 214u8 , 20u8 , 131u8 , 138u8 , 58u8 , 71u8 , 2u8 , 72u8 , 240u8 , 42u8 , 229u8 , 144u8 , 127u8 , 59u8 , 11u8 , 237u8 , 161u8 , 185u8 , 73u8 , 30u8 , 53u8 , 30u8 , 240u8 , 69u8 , 194u8 , 205u8 , 197u8 , 187u8 ,]) } # [doc = " DMAP ( parent, netuid ) --> Vec<(proportion,child)>"] pub fn child_keys_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: child_keys :: ChildKeys , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "ChildKeys" , () , [249u8 , 196u8 , 42u8 , 188u8 , 225u8 , 115u8 , 85u8 , 228u8 , 212u8 , 248u8 , 101u8 , 244u8 , 223u8 , 151u8 , 219u8 , 128u8 , 204u8 , 176u8 , 52u8 , 61u8 , 59u8 , 213u8 , 97u8 , 8u8 , 237u8 , 228u8 , 39u8 , 11u8 , 109u8 , 141u8 , 67u8 , 46u8 ,]) } # [doc = " DMAP ( parent, netuid ) --> Vec<(proportion,child)>"] pub fn child_keys_iter1 (& self , _0 : impl :: core :: borrow :: Borrow < types :: child_keys :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: child_keys :: Param0 > , types :: child_keys :: ChildKeys , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "ChildKeys" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [249u8 , 196u8 , 42u8 , 188u8 , 225u8 , 115u8 , 85u8 , 228u8 , 212u8 , 248u8 , 101u8 , 244u8 , 223u8 , 151u8 , 219u8 , 128u8 , 204u8 , 176u8 , 52u8 , 61u8 , 59u8 , 213u8 , 97u8 , 8u8 , 237u8 , 228u8 , 39u8 , 11u8 , 109u8 , 141u8 , 67u8 , 46u8 ,]) } # [doc = " DMAP ( parent, netuid ) --> Vec<(proportion,child)>"] pub fn child_keys (& self , _0 : impl :: core :: borrow :: Borrow < types :: child_keys :: Param0 > , _1 : impl :: core :: borrow :: Borrow < types :: child_keys :: Param1 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < (:: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: child_keys :: Param0 > , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: child_keys :: Param1 > ,) , types :: child_keys :: ChildKeys , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "ChildKeys" , (:: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_1 . borrow ()) ,) , [249u8 , 196u8 , 42u8 , 188u8 , 225u8 , 115u8 , 85u8 , 228u8 , 212u8 , 248u8 , 101u8 , 244u8 , 223u8 , 151u8 , 219u8 , 128u8 , 204u8 , 176u8 , 52u8 , 61u8 , 59u8 , 213u8 , 97u8 , 8u8 , 237u8 , 228u8 , 39u8 , 11u8 , 109u8 , 141u8 , 67u8 , 46u8 ,]) } # [doc = " DMAP ( child, netuid ) --> Vec<(proportion,parent)>"] pub fn parent_keys_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: parent_keys :: ParentKeys , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "ParentKeys" , () , [37u8 , 132u8 , 47u8 , 160u8 , 174u8 , 62u8 , 94u8 , 18u8 , 202u8 , 134u8 , 247u8 , 75u8 , 69u8 , 168u8 , 234u8 , 174u8 , 184u8 , 81u8 , 240u8 , 141u8 , 155u8 , 158u8 , 120u8 , 153u8 , 121u8 , 49u8 , 217u8 , 208u8 , 136u8 , 15u8 , 98u8 , 246u8 ,]) } # [doc = " DMAP ( child, netuid ) --> Vec<(proportion,parent)>"] pub fn parent_keys_iter1 (& self , _0 : impl :: core :: borrow :: Borrow < types :: parent_keys :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: parent_keys :: Param0 > , types :: parent_keys :: ParentKeys , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "ParentKeys" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [37u8 , 132u8 , 47u8 , 160u8 , 174u8 , 62u8 , 94u8 , 18u8 , 202u8 , 134u8 , 247u8 , 75u8 , 69u8 , 168u8 , 234u8 , 174u8 , 184u8 , 81u8 , 240u8 , 141u8 , 155u8 , 158u8 , 120u8 , 153u8 , 121u8 , 49u8 , 217u8 , 208u8 , 136u8 , 15u8 , 98u8 , 246u8 ,]) } # [doc = " DMAP ( child, netuid ) --> Vec<(proportion,parent)>"] pub fn parent_keys (& self , _0 : impl :: core :: borrow :: Borrow < types :: parent_keys :: Param0 > , _1 : impl :: core :: borrow :: Borrow < types :: parent_keys :: Param1 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < (:: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: parent_keys :: Param0 > , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: parent_keys :: Param1 > ,) , types :: parent_keys :: ParentKeys , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "ParentKeys" , (:: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_1 . borrow ()) ,) , [37u8 , 132u8 , 47u8 , 160u8 , 174u8 , 62u8 , 94u8 , 18u8 , 202u8 , 134u8 , 247u8 , 75u8 , 69u8 , 168u8 , 234u8 , 174u8 , 184u8 , 81u8 , 240u8 , 141u8 , 155u8 , 158u8 , 120u8 , 153u8 , 121u8 , 49u8 , 217u8 , 208u8 , 136u8 , 15u8 , 98u8 , 246u8 ,]) } pub fn staking_hotkeys_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: staking_hotkeys :: StakingHotkeys , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "StakingHotkeys" , () , [152u8 , 192u8 , 98u8 , 183u8 , 211u8 , 153u8 , 63u8 , 135u8 , 238u8 , 232u8 , 90u8 , 75u8 , 210u8 , 127u8 , 124u8 , 190u8 , 145u8 , 153u8 , 73u8 , 14u8 , 55u8 , 205u8 , 149u8 , 247u8 , 92u8 , 100u8 , 128u8 , 165u8 , 252u8 , 96u8 , 124u8 , 189u8 ,]) } pub fn staking_hotkeys (& self , _0 : impl :: core :: borrow :: Borrow < types :: staking_hotkeys :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: staking_hotkeys :: Param0 > , types :: staking_hotkeys :: StakingHotkeys , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "StakingHotkeys" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [152u8 , 192u8 , 98u8 , 183u8 , 211u8 , 153u8 , 63u8 , 135u8 , 238u8 , 232u8 , 90u8 , 75u8 , 210u8 , 127u8 , 124u8 , 190u8 , 145u8 , 153u8 , 73u8 , 14u8 , 55u8 , 205u8 , 149u8 , 247u8 , 92u8 , 100u8 , 128u8 , 165u8 , 252u8 , 96u8 , 124u8 , 189u8 ,]) } pub fn owned_hotkeys_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: owned_hotkeys :: OwnedHotkeys , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "OwnedHotkeys" , () , [89u8 , 221u8 , 46u8 , 67u8 , 65u8 , 21u8 , 26u8 , 100u8 , 85u8 , 109u8 , 130u8 , 186u8 , 231u8 , 63u8 , 34u8 , 179u8 , 145u8 , 67u8 , 97u8 , 151u8 , 75u8 , 1u8 , 165u8 , 115u8 , 45u8 , 102u8 , 170u8 , 57u8 , 205u8 , 96u8 , 17u8 , 210u8 ,]) } pub fn owned_hotkeys (& self , _0 : impl :: core :: borrow :: Borrow < types :: owned_hotkeys :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: owned_hotkeys :: Param0 > , types :: owned_hotkeys :: OwnedHotkeys , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "OwnedHotkeys" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [89u8 , 221u8 , 46u8 , 67u8 , 65u8 , 21u8 , 26u8 , 100u8 , 85u8 , 109u8 , 130u8 , 186u8 , 231u8 , 63u8 , 34u8 , 179u8 , 145u8 , 67u8 , 97u8 , 151u8 , 75u8 , 1u8 , 165u8 , 115u8 , 45u8 , 102u8 , 170u8 , 57u8 , 205u8 , 96u8 , 17u8 , 210u8 ,]) } pub fn coldkey_swap_scheduled_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: coldkey_swap_scheduled :: ColdkeySwapScheduled , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "ColdkeySwapScheduled" , () , [235u8 , 172u8 , 169u8 , 167u8 , 242u8 , 120u8 , 197u8 , 114u8 , 203u8 , 17u8 , 196u8 , 12u8 , 53u8 , 61u8 , 107u8 , 196u8 , 199u8 , 21u8 , 91u8 , 70u8 , 120u8 , 207u8 , 84u8 , 101u8 , 31u8 , 245u8 , 14u8 , 191u8 , 229u8 , 108u8 , 122u8 , 179u8 ,]) } pub fn coldkey_swap_scheduled (& self , _0 : impl :: core :: borrow :: Borrow < types :: coldkey_swap_scheduled :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: coldkey_swap_scheduled :: Param0 > , types :: coldkey_swap_scheduled :: ColdkeySwapScheduled , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "ColdkeySwapScheduled" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [235u8 , 172u8 , 169u8 , 167u8 , 242u8 , 120u8 , 197u8 , 114u8 , 203u8 , 17u8 , 196u8 , 12u8 , 53u8 , 61u8 , 107u8 , 196u8 , 199u8 , 21u8 , 91u8 , 70u8 , 120u8 , 207u8 , 84u8 , 101u8 , 31u8 , 245u8 , 14u8 , 191u8 , 229u8 , 108u8 , 122u8 , 179u8 ,]) } # [doc = " ============================"] # [doc = " ==== Global Parameters ====="] # [doc = " ============================"] # [doc = " --- StorageItem Global Used Work."] pub fn used_work_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: used_work :: UsedWork , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "UsedWork" , () , [59u8 , 93u8 , 120u8 , 178u8 , 19u8 , 194u8 , 54u8 , 240u8 , 132u8 , 243u8 , 106u8 , 24u8 , 176u8 , 106u8 , 59u8 , 130u8 , 174u8 , 127u8 , 79u8 , 107u8 , 253u8 , 172u8 , 238u8 , 193u8 , 180u8 , 221u8 , 154u8 , 66u8 , 179u8 , 190u8 , 192u8 , 202u8 ,]) } # [doc = " ============================"] # [doc = " ==== Global Parameters ====="] # [doc = " ============================"] # [doc = " --- StorageItem Global Used Work."] pub fn used_work (& self , _0 : impl :: core :: borrow :: Borrow < types :: used_work :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: used_work :: Param0 > , types :: used_work :: UsedWork , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "UsedWork" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [59u8 , 93u8 , 120u8 , 178u8 , 19u8 , 194u8 , 54u8 , 240u8 , 132u8 , 243u8 , 106u8 , 24u8 , 176u8 , 106u8 , 59u8 , 130u8 , 174u8 , 127u8 , 79u8 , 107u8 , 253u8 , 172u8 , 238u8 , 193u8 , 180u8 , 221u8 , 154u8 , 66u8 , 179u8 , 190u8 , 192u8 , 202u8 ,]) } # [doc = " --- ITEM( global_max_registrations_per_block )"] pub fn max_registrations_per_block_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: max_registrations_per_block :: MaxRegistrationsPerBlock , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "MaxRegistrationsPerBlock" , () , [191u8 , 117u8 , 55u8 , 65u8 , 37u8 , 248u8 , 122u8 , 37u8 , 164u8 , 225u8 , 117u8 , 242u8 , 26u8 , 106u8 , 69u8 , 2u8 , 99u8 , 9u8 , 32u8 , 125u8 , 131u8 , 215u8 , 127u8 , 37u8 , 113u8 , 234u8 , 214u8 , 107u8 , 1u8 , 20u8 , 172u8 , 209u8 ,]) } # [doc = " --- ITEM( global_max_registrations_per_block )"] pub fn max_registrations_per_block (& self , _0 : impl :: core :: borrow :: Borrow < types :: max_registrations_per_block :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: max_registrations_per_block :: Param0 > , types :: max_registrations_per_block :: MaxRegistrationsPerBlock , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "MaxRegistrationsPerBlock" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [191u8 , 117u8 , 55u8 , 65u8 , 37u8 , 248u8 , 122u8 , 37u8 , 164u8 , 225u8 , 117u8 , 242u8 , 26u8 , 106u8 , 69u8 , 2u8 , 99u8 , 9u8 , 32u8 , 125u8 , 131u8 , 215u8 , 127u8 , 37u8 , 113u8 , 234u8 , 214u8 , 107u8 , 1u8 , 20u8 , 172u8 , 209u8 ,]) } # [doc = " --- ITEM( maximum_number_of_networks )"] pub fn subnet_limit (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: subnet_limit :: SubnetLimit , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "SubnetLimit" , () , [181u8 , 187u8 , 24u8 , 149u8 , 55u8 , 209u8 , 106u8 , 70u8 , 29u8 , 5u8 , 76u8 , 171u8 , 16u8 , 95u8 , 169u8 , 228u8 , 181u8 , 150u8 , 158u8 , 138u8 , 131u8 , 87u8 , 93u8 , 12u8 , 9u8 , 221u8 , 175u8 , 5u8 , 201u8 , 195u8 , 110u8 , 89u8 ,]) } # [doc = " --- ITEM( total_number_of_existing_networks )"] pub fn total_networks (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: total_networks :: TotalNetworks , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "TotalNetworks" , () , [132u8 , 105u8 , 133u8 , 1u8 , 223u8 , 1u8 , 229u8 , 233u8 , 214u8 , 218u8 , 161u8 , 147u8 , 170u8 , 200u8 , 141u8 , 203u8 , 140u8 , 190u8 , 33u8 , 201u8 , 135u8 , 127u8 , 85u8 , 28u8 , 145u8 , 113u8 , 61u8 , 75u8 , 51u8 , 225u8 , 47u8 , 107u8 ,]) } # [doc = " ITEM( network_immunity_period )"] pub fn network_immunity_period (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: network_immunity_period :: NetworkImmunityPeriod , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "NetworkImmunityPeriod" , () , [165u8 , 72u8 , 132u8 , 22u8 , 239u8 , 25u8 , 191u8 , 35u8 , 164u8 , 140u8 , 171u8 , 36u8 , 81u8 , 166u8 , 171u8 , 238u8 , 127u8 , 143u8 , 162u8 , 92u8 , 36u8 , 203u8 , 229u8 , 10u8 , 162u8 , 91u8 , 121u8 , 97u8 , 13u8 , 105u8 , 18u8 , 91u8 ,]) } # [doc = " ITEM( network_last_registered_block )"] pub fn network_last_registered (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: network_last_registered :: NetworkLastRegistered , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "NetworkLastRegistered" , () , [111u8 , 106u8 , 0u8 , 115u8 , 27u8 , 161u8 , 40u8 , 182u8 , 197u8 , 217u8 , 167u8 , 183u8 , 43u8 , 157u8 , 42u8 , 107u8 , 108u8 , 100u8 , 42u8 , 67u8 , 174u8 , 138u8 , 109u8 , 98u8 , 242u8 , 15u8 , 54u8 , 32u8 , 201u8 , 169u8 , 39u8 , 40u8 ,]) } # [doc = " ITEM( network_min_allowed_uids )"] pub fn network_min_allowed_uids (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: network_min_allowed_uids :: NetworkMinAllowedUids , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "NetworkMinAllowedUids" , () , [192u8 , 136u8 , 52u8 , 54u8 , 8u8 , 30u8 , 50u8 , 185u8 , 178u8 , 182u8 , 121u8 , 72u8 , 97u8 , 21u8 , 8u8 , 97u8 , 74u8 , 54u8 , 226u8 , 177u8 , 148u8 , 111u8 , 212u8 , 117u8 , 23u8 , 187u8 , 57u8 , 149u8 , 30u8 , 35u8 , 147u8 , 87u8 ,]) } # [doc = " ITEM( min_network_lock_cost )"] pub fn network_min_lock_cost (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: network_min_lock_cost :: NetworkMinLockCost , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "NetworkMinLockCost" , () , [121u8 , 246u8 , 74u8 , 53u8 , 75u8 , 35u8 , 107u8 , 91u8 , 134u8 , 130u8 , 132u8 , 220u8 , 219u8 , 99u8 , 121u8 , 198u8 , 164u8 , 152u8 , 88u8 , 82u8 , 228u8 , 197u8 , 89u8 , 145u8 , 100u8 , 28u8 , 123u8 , 54u8 , 14u8 , 238u8 , 90u8 , 123u8 ,]) } # [doc = " ITEM( last_network_lock_cost )"] pub fn network_last_lock_cost (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: network_last_lock_cost :: NetworkLastLockCost , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "NetworkLastLockCost" , () , [204u8 , 201u8 , 165u8 , 119u8 , 228u8 , 146u8 , 239u8 , 232u8 , 251u8 , 98u8 , 7u8 , 78u8 , 57u8 , 16u8 , 50u8 , 12u8 , 121u8 , 144u8 , 185u8 , 4u8 , 1u8 , 5u8 , 172u8 , 48u8 , 128u8 , 154u8 , 198u8 , 55u8 , 81u8 , 154u8 , 96u8 , 140u8 ,]) } # [doc = " ITEM( network_lock_reduction_interval )"] pub fn network_lock_reduction_interval (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: network_lock_reduction_interval :: NetworkLockReductionInterval , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "NetworkLockReductionInterval" , () , [152u8 , 66u8 , 107u8 , 209u8 , 243u8 , 1u8 , 28u8 , 95u8 , 254u8 , 78u8 , 47u8 , 219u8 , 35u8 , 112u8 , 73u8 , 86u8 , 210u8 , 24u8 , 196u8 , 124u8 , 28u8 , 223u8 , 82u8 , 34u8 , 84u8 , 70u8 , 76u8 , 182u8 , 38u8 , 196u8 , 199u8 , 244u8 ,]) } # [doc = " ITEM( subnet_owner_cut )"] pub fn subnet_owner_cut (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: subnet_owner_cut :: SubnetOwnerCut , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "SubnetOwnerCut" , () , [121u8 , 122u8 , 222u8 , 69u8 , 52u8 , 72u8 , 210u8 , 26u8 , 120u8 , 3u8 , 126u8 , 203u8 , 87u8 , 116u8 , 72u8 , 25u8 , 142u8 , 231u8 , 36u8 , 26u8 , 121u8 , 174u8 , 151u8 , 102u8 , 2u8 , 104u8 , 178u8 , 168u8 , 76u8 , 255u8 , 139u8 , 3u8 ,]) } # [doc = " ITEM( network_rate_limit )"] pub fn network_rate_limit (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: network_rate_limit :: NetworkRateLimit , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "NetworkRateLimit" , () , [61u8 , 107u8 , 0u8 , 71u8 , 139u8 , 133u8 , 10u8 , 238u8 , 249u8 , 102u8 , 121u8 , 59u8 , 74u8 , 155u8 , 129u8 , 16u8 , 44u8 , 90u8 , 163u8 , 19u8 , 15u8 , 22u8 , 6u8 , 44u8 , 254u8 , 120u8 , 15u8 , 117u8 , 73u8 , 85u8 , 73u8 , 74u8 ,]) } # [doc = " ITEM( nominator_min_required_stake )"] pub fn nominator_min_required_stake (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: nominator_min_required_stake :: NominatorMinRequiredStake , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "NominatorMinRequiredStake" , () , [25u8 , 60u8 , 15u8 , 61u8 , 202u8 , 65u8 , 157u8 , 188u8 , 225u8 , 173u8 , 91u8 , 204u8 , 252u8 , 105u8 , 243u8 , 30u8 , 194u8 , 185u8 , 127u8 , 230u8 , 12u8 , 7u8 , 76u8 , 185u8 , 44u8 , 154u8 , 150u8 , 192u8 , 114u8 , 2u8 , 162u8 , 86u8 ,]) } # [doc = " ============================"] # [doc = " ==== Subnet Parameters ====="] # [doc = " ============================"] # [doc = " --- MAP ( netuid ) --> subnetwork_n (Number of UIDs in the network)."] pub fn subnetwork_n_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: subnetwork_n :: SubnetworkN , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "SubnetworkN" , () , [14u8 , 190u8 , 185u8 , 215u8 , 93u8 , 134u8 , 150u8 , 83u8 , 248u8 , 254u8 , 184u8 , 105u8 , 213u8 , 65u8 , 205u8 , 128u8 , 46u8 , 234u8 , 231u8 , 176u8 , 195u8 , 175u8 , 97u8 , 75u8 , 33u8 , 209u8 , 155u8 , 55u8 , 158u8 , 0u8 , 159u8 , 140u8 ,]) } # [doc = " ============================"] # [doc = " ==== Subnet Parameters ====="] # [doc = " ============================"] # [doc = " --- MAP ( netuid ) --> subnetwork_n (Number of UIDs in the network)."] pub fn subnetwork_n (& self , _0 : impl :: core :: borrow :: Borrow < types :: subnetwork_n :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: subnetwork_n :: Param0 > , types :: subnetwork_n :: SubnetworkN , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "SubnetworkN" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [14u8 , 190u8 , 185u8 , 215u8 , 93u8 , 134u8 , 150u8 , 83u8 , 248u8 , 254u8 , 184u8 , 105u8 , 213u8 , 65u8 , 205u8 , 128u8 , 46u8 , 234u8 , 231u8 , 176u8 , 195u8 , 175u8 , 97u8 , 75u8 , 33u8 , 209u8 , 155u8 , 55u8 , 158u8 , 0u8 , 159u8 , 140u8 ,]) } # [doc = " --- MAP ( netuid ) --> modality   TEXT: 0, IMAGE: 1, TENSOR: 2"] pub fn network_modality_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: network_modality :: NetworkModality , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "NetworkModality" , () , [18u8 , 56u8 , 222u8 , 196u8 , 139u8 , 52u8 , 181u8 , 222u8 , 180u8 , 3u8 , 236u8 , 9u8 , 175u8 , 221u8 , 244u8 , 75u8 , 245u8 , 170u8 , 5u8 , 44u8 , 36u8 , 185u8 , 83u8 , 81u8 , 117u8 , 164u8 , 90u8 , 195u8 , 229u8 , 128u8 , 90u8 , 3u8 ,]) } # [doc = " --- MAP ( netuid ) --> modality   TEXT: 0, IMAGE: 1, TENSOR: 2"] pub fn network_modality (& self , _0 : impl :: core :: borrow :: Borrow < types :: network_modality :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: network_modality :: Param0 > , types :: network_modality :: NetworkModality , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "NetworkModality" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [18u8 , 56u8 , 222u8 , 196u8 , 139u8 , 52u8 , 181u8 , 222u8 , 180u8 , 3u8 , 236u8 , 9u8 , 175u8 , 221u8 , 244u8 , 75u8 , 245u8 , 170u8 , 5u8 , 44u8 , 36u8 , 185u8 , 83u8 , 81u8 , 117u8 , 164u8 , 90u8 , 195u8 , 229u8 , 128u8 , 90u8 , 3u8 ,]) } # [doc = " --- MAP ( netuid ) --> network_is_added"] pub fn networks_added_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: networks_added :: NetworksAdded , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "NetworksAdded" , () , [246u8 , 161u8 , 17u8 , 237u8 , 203u8 , 101u8 , 133u8 , 177u8 , 241u8 , 246u8 , 131u8 , 72u8 , 167u8 , 117u8 , 117u8 , 183u8 , 50u8 , 185u8 , 129u8 , 136u8 , 132u8 , 158u8 , 194u8 , 134u8 , 208u8 , 34u8 , 38u8 , 91u8 , 47u8 , 89u8 , 4u8 , 53u8 ,]) } # [doc = " --- MAP ( netuid ) --> network_is_added"] pub fn networks_added (& self , _0 : impl :: core :: borrow :: Borrow < types :: networks_added :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: networks_added :: Param0 > , types :: networks_added :: NetworksAdded , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "NetworksAdded" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [246u8 , 161u8 , 17u8 , 237u8 , 203u8 , 101u8 , 133u8 , 177u8 , 241u8 , 246u8 , 131u8 , 72u8 , 167u8 , 117u8 , 117u8 , 183u8 , 50u8 , 185u8 , 129u8 , 136u8 , 132u8 , 158u8 , 194u8 , 134u8 , 208u8 , 34u8 , 38u8 , 91u8 , 47u8 , 89u8 , 4u8 , 53u8 ,]) } # [doc = " --- DMAP ( hotkey, netuid ) --> bool"] pub fn is_network_member_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: is_network_member :: IsNetworkMember , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "IsNetworkMember" , () , [173u8 , 44u8 , 159u8 , 45u8 , 191u8 , 17u8 , 225u8 , 54u8 , 118u8 , 238u8 , 172u8 , 202u8 , 215u8 , 188u8 , 112u8 , 230u8 , 77u8 , 134u8 , 91u8 , 35u8 , 26u8 , 107u8 , 129u8 , 153u8 , 206u8 , 3u8 , 119u8 , 130u8 , 70u8 , 20u8 , 14u8 , 112u8 ,]) } # [doc = " --- DMAP ( hotkey, netuid ) --> bool"] pub fn is_network_member_iter1 (& self , _0 : impl :: core :: borrow :: Borrow < types :: is_network_member :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: is_network_member :: Param0 > , types :: is_network_member :: IsNetworkMember , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "IsNetworkMember" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [173u8 , 44u8 , 159u8 , 45u8 , 191u8 , 17u8 , 225u8 , 54u8 , 118u8 , 238u8 , 172u8 , 202u8 , 215u8 , 188u8 , 112u8 , 230u8 , 77u8 , 134u8 , 91u8 , 35u8 , 26u8 , 107u8 , 129u8 , 153u8 , 206u8 , 3u8 , 119u8 , 130u8 , 70u8 , 20u8 , 14u8 , 112u8 ,]) } # [doc = " --- DMAP ( hotkey, netuid ) --> bool"] pub fn is_network_member (& self , _0 : impl :: core :: borrow :: Borrow < types :: is_network_member :: Param0 > , _1 : impl :: core :: borrow :: Borrow < types :: is_network_member :: Param1 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < (:: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: is_network_member :: Param0 > , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: is_network_member :: Param1 > ,) , types :: is_network_member :: IsNetworkMember , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "IsNetworkMember" , (:: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_1 . borrow ()) ,) , [173u8 , 44u8 , 159u8 , 45u8 , 191u8 , 17u8 , 225u8 , 54u8 , 118u8 , 238u8 , 172u8 , 202u8 , 215u8 , 188u8 , 112u8 , 230u8 , 77u8 , 134u8 , 91u8 , 35u8 , 26u8 , 107u8 , 129u8 , 153u8 , 206u8 , 3u8 , 119u8 , 130u8 , 70u8 , 20u8 , 14u8 , 112u8 ,]) } # [doc = " --- MAP ( netuid ) --> network_registration_allowed"] pub fn network_registration_allowed_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: network_registration_allowed :: NetworkRegistrationAllowed , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "NetworkRegistrationAllowed" , () , [42u8 , 61u8 , 247u8 , 161u8 , 77u8 , 218u8 , 186u8 , 247u8 , 253u8 , 75u8 , 228u8 , 175u8 , 18u8 , 122u8 , 150u8 , 110u8 , 10u8 , 166u8 , 209u8 , 232u8 , 74u8 , 8u8 , 85u8 , 234u8 , 69u8 , 92u8 , 14u8 , 101u8 , 212u8 , 207u8 , 47u8 , 235u8 ,]) } # [doc = " --- MAP ( netuid ) --> network_registration_allowed"] pub fn network_registration_allowed (& self , _0 : impl :: core :: borrow :: Borrow < types :: network_registration_allowed :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: network_registration_allowed :: Param0 > , types :: network_registration_allowed :: NetworkRegistrationAllowed , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "NetworkRegistrationAllowed" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [42u8 , 61u8 , 247u8 , 161u8 , 77u8 , 218u8 , 186u8 , 247u8 , 253u8 , 75u8 , 228u8 , 175u8 , 18u8 , 122u8 , 150u8 , 110u8 , 10u8 , 166u8 , 209u8 , 232u8 , 74u8 , 8u8 , 85u8 , 234u8 , 69u8 , 92u8 , 14u8 , 101u8 , 212u8 , 207u8 , 47u8 , 235u8 ,]) } # [doc = " --- MAP ( netuid ) --> network_pow_allowed"] pub fn network_pow_registration_allowed_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: network_pow_registration_allowed :: NetworkPowRegistrationAllowed , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "NetworkPowRegistrationAllowed" , () , [206u8 , 57u8 , 101u8 , 211u8 , 195u8 , 185u8 , 134u8 , 48u8 , 225u8 , 124u8 , 27u8 , 217u8 , 135u8 , 116u8 , 15u8 , 223u8 , 193u8 , 45u8 , 39u8 , 232u8 , 103u8 , 182u8 , 251u8 , 0u8 , 179u8 , 9u8 , 1u8 , 35u8 , 186u8 , 90u8 , 221u8 , 217u8 ,]) } # [doc = " --- MAP ( netuid ) --> network_pow_allowed"] pub fn network_pow_registration_allowed (& self , _0 : impl :: core :: borrow :: Borrow < types :: network_pow_registration_allowed :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: network_pow_registration_allowed :: Param0 > , types :: network_pow_registration_allowed :: NetworkPowRegistrationAllowed , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "NetworkPowRegistrationAllowed" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [206u8 , 57u8 , 101u8 , 211u8 , 195u8 , 185u8 , 134u8 , 48u8 , 225u8 , 124u8 , 27u8 , 217u8 , 135u8 , 116u8 , 15u8 , 223u8 , 193u8 , 45u8 , 39u8 , 232u8 , 103u8 , 182u8 , 251u8 , 0u8 , 179u8 , 9u8 , 1u8 , 35u8 , 186u8 , 90u8 , 221u8 , 217u8 ,]) } # [doc = " --- MAP ( netuid ) --> block_created"] pub fn network_registered_at_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: network_registered_at :: NetworkRegisteredAt , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "NetworkRegisteredAt" , () , [123u8 , 234u8 , 64u8 , 248u8 , 32u8 , 119u8 , 192u8 , 176u8 , 98u8 , 201u8 , 74u8 , 210u8 , 34u8 , 148u8 , 254u8 , 127u8 , 10u8 , 31u8 , 205u8 , 17u8 , 43u8 , 177u8 , 159u8 , 189u8 , 199u8 , 72u8 , 1u8 , 246u8 , 96u8 , 73u8 , 12u8 , 34u8 ,]) } # [doc = " --- MAP ( netuid ) --> block_created"] pub fn network_registered_at (& self , _0 : impl :: core :: borrow :: Borrow < types :: network_registered_at :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: network_registered_at :: Param0 > , types :: network_registered_at :: NetworkRegisteredAt , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "NetworkRegisteredAt" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [123u8 , 234u8 , 64u8 , 248u8 , 32u8 , 119u8 , 192u8 , 176u8 , 98u8 , 201u8 , 74u8 , 210u8 , 34u8 , 148u8 , 254u8 , 127u8 , 10u8 , 31u8 , 205u8 , 17u8 , 43u8 , 177u8 , 159u8 , 189u8 , 199u8 , 72u8 , 1u8 , 246u8 , 96u8 , 73u8 , 12u8 , 34u8 ,]) } # [doc = " --- MAP ( netuid ) --> tempo"] pub fn tempo_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: tempo :: Tempo , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "Tempo" , () , [233u8 , 84u8 , 20u8 , 72u8 , 111u8 , 149u8 , 177u8 , 55u8 , 228u8 , 101u8 , 215u8 , 149u8 , 241u8 , 101u8 , 136u8 , 32u8 , 205u8 , 10u8 , 216u8 , 211u8 , 47u8 , 37u8 , 196u8 , 207u8 , 125u8 , 194u8 , 240u8 , 162u8 , 253u8 , 229u8 , 174u8 , 201u8 ,]) } # [doc = " --- MAP ( netuid ) --> tempo"] pub fn tempo (& self , _0 : impl :: core :: borrow :: Borrow < types :: tempo :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: tempo :: Param0 > , types :: tempo :: Tempo , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "Tempo" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [233u8 , 84u8 , 20u8 , 72u8 , 111u8 , 149u8 , 177u8 , 55u8 , 228u8 , 101u8 , 215u8 , 149u8 , 241u8 , 101u8 , 136u8 , 32u8 , 205u8 , 10u8 , 216u8 , 211u8 , 47u8 , 37u8 , 196u8 , 207u8 , 125u8 , 194u8 , 240u8 , 162u8 , 253u8 , 229u8 , 174u8 , 201u8 ,]) } # [doc = " --- MAP ( netuid ) --> emission_values"] pub fn emission_values_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: emission_values :: EmissionValues , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "EmissionValues" , () , [227u8 , 105u8 , 162u8 , 157u8 , 17u8 , 19u8 , 156u8 , 92u8 , 44u8 , 112u8 , 53u8 , 136u8 , 250u8 , 110u8 , 116u8 , 130u8 , 90u8 , 214u8 , 139u8 , 167u8 , 109u8 , 180u8 , 234u8 , 133u8 , 135u8 , 166u8 , 76u8 , 210u8 , 213u8 , 149u8 , 114u8 , 12u8 ,]) } # [doc = " --- MAP ( netuid ) --> emission_values"] pub fn emission_values (& self , _0 : impl :: core :: borrow :: Borrow < types :: emission_values :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: emission_values :: Param0 > , types :: emission_values :: EmissionValues , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "EmissionValues" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [227u8 , 105u8 , 162u8 , 157u8 , 17u8 , 19u8 , 156u8 , 92u8 , 44u8 , 112u8 , 53u8 , 136u8 , 250u8 , 110u8 , 116u8 , 130u8 , 90u8 , 214u8 , 139u8 , 167u8 , 109u8 , 180u8 , 234u8 , 133u8 , 135u8 , 166u8 , 76u8 , 210u8 , 213u8 , 149u8 , 114u8 , 12u8 ,]) } # [doc = " --- MAP ( netuid ) --> pending_emission"] pub fn pending_emission_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: pending_emission :: PendingEmission , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "PendingEmission" , () , [32u8 , 200u8 , 249u8 , 248u8 , 77u8 , 171u8 , 166u8 , 138u8 , 93u8 , 142u8 , 0u8 , 38u8 , 195u8 , 61u8 , 42u8 , 150u8 , 198u8 , 116u8 , 135u8 , 127u8 , 91u8 , 129u8 , 142u8 , 60u8 , 52u8 , 148u8 , 201u8 , 71u8 , 185u8 , 219u8 , 185u8 , 249u8 ,]) } # [doc = " --- MAP ( netuid ) --> pending_emission"] pub fn pending_emission (& self , _0 : impl :: core :: borrow :: Borrow < types :: pending_emission :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: pending_emission :: Param0 > , types :: pending_emission :: PendingEmission , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "PendingEmission" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [32u8 , 200u8 , 249u8 , 248u8 , 77u8 , 171u8 , 166u8 , 138u8 , 93u8 , 142u8 , 0u8 , 38u8 , 195u8 , 61u8 , 42u8 , 150u8 , 198u8 , 116u8 , 135u8 , 127u8 , 91u8 , 129u8 , 142u8 , 60u8 , 52u8 , 148u8 , 201u8 , 71u8 , 185u8 , 219u8 , 185u8 , 249u8 ,]) } # [doc = " --- MAP ( netuid ) --> blocks_since_last_step"] pub fn blocks_since_last_step_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: blocks_since_last_step :: BlocksSinceLastStep , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "BlocksSinceLastStep" , () , [109u8 , 129u8 , 181u8 , 218u8 , 224u8 , 135u8 , 137u8 , 119u8 , 202u8 , 22u8 , 243u8 , 181u8 , 118u8 , 30u8 , 154u8 , 247u8 , 188u8 , 140u8 , 187u8 , 62u8 , 30u8 , 224u8 , 126u8 , 253u8 , 47u8 , 63u8 , 4u8 , 55u8 , 74u8 , 41u8 , 156u8 , 126u8 ,]) } # [doc = " --- MAP ( netuid ) --> blocks_since_last_step"] pub fn blocks_since_last_step (& self , _0 : impl :: core :: borrow :: Borrow < types :: blocks_since_last_step :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: blocks_since_last_step :: Param0 > , types :: blocks_since_last_step :: BlocksSinceLastStep , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "BlocksSinceLastStep" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [109u8 , 129u8 , 181u8 , 218u8 , 224u8 , 135u8 , 137u8 , 119u8 , 202u8 , 22u8 , 243u8 , 181u8 , 118u8 , 30u8 , 154u8 , 247u8 , 188u8 , 140u8 , 187u8 , 62u8 , 30u8 , 224u8 , 126u8 , 253u8 , 47u8 , 63u8 , 4u8 , 55u8 , 74u8 , 41u8 , 156u8 , 126u8 ,]) } # [doc = " --- MAP ( netuid ) --> last_mechanism_step_block"] pub fn last_mechansim_step_block_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: last_mechansim_step_block :: LastMechansimStepBlock , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "LastMechansimStepBlock" , () , [1u8 , 255u8 , 178u8 , 25u8 , 130u8 , 241u8 , 246u8 , 122u8 , 11u8 , 55u8 , 138u8 , 125u8 , 4u8 , 119u8 , 247u8 , 144u8 , 254u8 , 76u8 , 169u8 , 106u8 , 202u8 , 192u8 , 222u8 , 51u8 , 90u8 , 157u8 , 155u8 , 160u8 , 85u8 , 248u8 , 250u8 , 11u8 ,]) } # [doc = " --- MAP ( netuid ) --> last_mechanism_step_block"] pub fn last_mechansim_step_block (& self , _0 : impl :: core :: borrow :: Borrow < types :: last_mechansim_step_block :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: last_mechansim_step_block :: Param0 > , types :: last_mechansim_step_block :: LastMechansimStepBlock , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "LastMechansimStepBlock" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [1u8 , 255u8 , 178u8 , 25u8 , 130u8 , 241u8 , 246u8 , 122u8 , 11u8 , 55u8 , 138u8 , 125u8 , 4u8 , 119u8 , 247u8 , 144u8 , 254u8 , 76u8 , 169u8 , 106u8 , 202u8 , 192u8 , 222u8 , 51u8 , 90u8 , 157u8 , 155u8 , 160u8 , 85u8 , 248u8 , 250u8 , 11u8 ,]) } # [doc = " --- MAP ( netuid ) --> subnet_owner"] pub fn subnet_owner_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: subnet_owner :: SubnetOwner , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "SubnetOwner" , () , [17u8 , 66u8 , 162u8 , 10u8 , 172u8 , 179u8 , 149u8 , 54u8 , 233u8 , 98u8 , 237u8 , 13u8 , 148u8 , 126u8 , 66u8 , 29u8 , 242u8 , 85u8 , 112u8 , 201u8 , 76u8 , 90u8 , 68u8 , 156u8 , 207u8 , 190u8 , 242u8 , 175u8 , 178u8 , 137u8 , 82u8 , 137u8 ,]) } # [doc = " --- MAP ( netuid ) --> subnet_owner"] pub fn subnet_owner (& self , _0 : impl :: core :: borrow :: Borrow < types :: subnet_owner :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: subnet_owner :: Param0 > , types :: subnet_owner :: SubnetOwner , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "SubnetOwner" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [17u8 , 66u8 , 162u8 , 10u8 , 172u8 , 179u8 , 149u8 , 54u8 , 233u8 , 98u8 , 237u8 , 13u8 , 148u8 , 126u8 , 66u8 , 29u8 , 242u8 , 85u8 , 112u8 , 201u8 , 76u8 , 90u8 , 68u8 , 156u8 , 207u8 , 190u8 , 242u8 , 175u8 , 178u8 , 137u8 , 82u8 , 137u8 ,]) } # [doc = " --- MAP ( netuid ) --> subnet_locked"] pub fn subnet_locked_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: subnet_locked :: SubnetLocked , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "SubnetLocked" , () , [30u8 , 43u8 , 18u8 , 122u8 , 32u8 , 192u8 , 68u8 , 191u8 , 178u8 , 157u8 , 100u8 , 155u8 , 254u8 , 246u8 , 87u8 , 39u8 , 252u8 , 73u8 , 76u8 , 199u8 , 255u8 , 50u8 , 203u8 , 168u8 , 207u8 , 203u8 , 7u8 , 177u8 , 160u8 , 108u8 , 188u8 , 98u8 ,]) } # [doc = " --- MAP ( netuid ) --> subnet_locked"] pub fn subnet_locked (& self , _0 : impl :: core :: borrow :: Borrow < types :: subnet_locked :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: subnet_locked :: Param0 > , types :: subnet_locked :: SubnetLocked , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "SubnetLocked" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [30u8 , 43u8 , 18u8 , 122u8 , 32u8 , 192u8 , 68u8 , 191u8 , 178u8 , 157u8 , 100u8 , 155u8 , 254u8 , 246u8 , 87u8 , 39u8 , 252u8 , 73u8 , 76u8 , 199u8 , 255u8 , 50u8 , 203u8 , 168u8 , 207u8 , 203u8 , 7u8 , 177u8 , 160u8 , 108u8 , 188u8 , 98u8 ,]) } # [doc = " --- MAP ( netuid ) --> serving_rate_limit"] pub fn serving_rate_limit_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: serving_rate_limit :: ServingRateLimit , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "ServingRateLimit" , () , [237u8 , 16u8 , 229u8 , 115u8 , 91u8 , 1u8 , 62u8 , 29u8 , 4u8 , 1u8 , 117u8 , 76u8 , 9u8 , 40u8 , 108u8 , 16u8 , 177u8 , 117u8 , 19u8 , 171u8 , 215u8 , 145u8 , 34u8 , 143u8 , 63u8 , 177u8 , 159u8 , 19u8 , 107u8 , 175u8 , 98u8 , 29u8 ,]) } # [doc = " --- MAP ( netuid ) --> serving_rate_limit"] pub fn serving_rate_limit (& self , _0 : impl :: core :: borrow :: Borrow < types :: serving_rate_limit :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: serving_rate_limit :: Param0 > , types :: serving_rate_limit :: ServingRateLimit , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "ServingRateLimit" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [237u8 , 16u8 , 229u8 , 115u8 , 91u8 , 1u8 , 62u8 , 29u8 , 4u8 , 1u8 , 117u8 , 76u8 , 9u8 , 40u8 , 108u8 , 16u8 , 177u8 , 117u8 , 19u8 , 171u8 , 215u8 , 145u8 , 34u8 , 143u8 , 63u8 , 177u8 , 159u8 , 19u8 , 107u8 , 175u8 , 98u8 , 29u8 ,]) } # [doc = " --- MAP ( netuid ) --> Rho"] pub fn rho_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: rho :: Rho , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "Rho" , () , [217u8 , 113u8 , 127u8 , 214u8 , 58u8 , 210u8 , 84u8 , 189u8 , 225u8 , 55u8 , 9u8 , 215u8 , 246u8 , 72u8 , 225u8 , 55u8 , 137u8 , 158u8 , 141u8 , 57u8 , 246u8 , 8u8 , 16u8 , 81u8 , 75u8 , 66u8 , 211u8 , 158u8 , 83u8 , 49u8 , 130u8 , 6u8 ,]) } # [doc = " --- MAP ( netuid ) --> Rho"] pub fn rho (& self , _0 : impl :: core :: borrow :: Borrow < types :: rho :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: rho :: Param0 > , types :: rho :: Rho , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "Rho" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [217u8 , 113u8 , 127u8 , 214u8 , 58u8 , 210u8 , 84u8 , 189u8 , 225u8 , 55u8 , 9u8 , 215u8 , 246u8 , 72u8 , 225u8 , 55u8 , 137u8 , 158u8 , 141u8 , 57u8 , 246u8 , 8u8 , 16u8 , 81u8 , 75u8 , 66u8 , 211u8 , 158u8 , 83u8 , 49u8 , 130u8 , 6u8 ,]) } # [doc = " --- MAP ( netuid ) --> Kappa"] pub fn kappa_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: kappa :: Kappa , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "Kappa" , () , [183u8 , 63u8 , 137u8 , 235u8 , 82u8 , 130u8 , 93u8 , 189u8 , 231u8 , 143u8 , 7u8 , 148u8 , 193u8 , 80u8 , 232u8 , 62u8 , 164u8 , 161u8 , 238u8 , 79u8 , 23u8 , 36u8 , 205u8 , 44u8 , 6u8 , 74u8 , 188u8 , 254u8 , 74u8 , 177u8 , 6u8 , 147u8 ,]) } # [doc = " --- MAP ( netuid ) --> Kappa"] pub fn kappa (& self , _0 : impl :: core :: borrow :: Borrow < types :: kappa :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: kappa :: Param0 > , types :: kappa :: Kappa , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "Kappa" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [183u8 , 63u8 , 137u8 , 235u8 , 82u8 , 130u8 , 93u8 , 189u8 , 231u8 , 143u8 , 7u8 , 148u8 , 193u8 , 80u8 , 232u8 , 62u8 , 164u8 , 161u8 , 238u8 , 79u8 , 23u8 , 36u8 , 205u8 , 44u8 , 6u8 , 74u8 , 188u8 , 254u8 , 74u8 , 177u8 , 6u8 , 147u8 ,]) } # [doc = " --- MAP ( netuid ) --> uid, we use to record uids to prune at next epoch."] pub fn neurons_to_prune_at_next_epoch_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: neurons_to_prune_at_next_epoch :: NeuronsToPruneAtNextEpoch , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "NeuronsToPruneAtNextEpoch" , () , [200u8 , 16u8 , 1u8 , 175u8 , 87u8 , 2u8 , 149u8 , 188u8 , 43u8 , 81u8 , 93u8 , 66u8 , 254u8 , 61u8 , 38u8 , 4u8 , 111u8 , 29u8 , 147u8 , 6u8 , 112u8 , 34u8 , 103u8 , 25u8 , 128u8 , 31u8 , 207u8 , 249u8 , 64u8 , 49u8 , 14u8 , 88u8 ,]) } # [doc = " --- MAP ( netuid ) --> uid, we use to record uids to prune at next epoch."] pub fn neurons_to_prune_at_next_epoch (& self , _0 : impl :: core :: borrow :: Borrow < types :: neurons_to_prune_at_next_epoch :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: neurons_to_prune_at_next_epoch :: Param0 > , types :: neurons_to_prune_at_next_epoch :: NeuronsToPruneAtNextEpoch , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "NeuronsToPruneAtNextEpoch" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [200u8 , 16u8 , 1u8 , 175u8 , 87u8 , 2u8 , 149u8 , 188u8 , 43u8 , 81u8 , 93u8 , 66u8 , 254u8 , 61u8 , 38u8 , 4u8 , 111u8 , 29u8 , 147u8 , 6u8 , 112u8 , 34u8 , 103u8 , 25u8 , 128u8 , 31u8 , 207u8 , 249u8 , 64u8 , 49u8 , 14u8 , 88u8 ,]) } # [doc = " --- MAP ( netuid ) --> registrations_this_interval"] pub fn registrations_this_interval_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: registrations_this_interval :: RegistrationsThisInterval , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "RegistrationsThisInterval" , () , [82u8 , 150u8 , 225u8 , 120u8 , 61u8 , 53u8 , 156u8 , 229u8 , 196u8 , 47u8 , 209u8 , 243u8 , 207u8 , 64u8 , 233u8 , 193u8 , 130u8 , 205u8 , 58u8 , 64u8 , 184u8 , 57u8 , 219u8 , 254u8 , 164u8 , 101u8 , 168u8 , 4u8 , 225u8 , 12u8 , 116u8 , 55u8 ,]) } # [doc = " --- MAP ( netuid ) --> registrations_this_interval"] pub fn registrations_this_interval (& self , _0 : impl :: core :: borrow :: Borrow < types :: registrations_this_interval :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: registrations_this_interval :: Param0 > , types :: registrations_this_interval :: RegistrationsThisInterval , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "RegistrationsThisInterval" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [82u8 , 150u8 , 225u8 , 120u8 , 61u8 , 53u8 , 156u8 , 229u8 , 196u8 , 47u8 , 209u8 , 243u8 , 207u8 , 64u8 , 233u8 , 193u8 , 130u8 , 205u8 , 58u8 , 64u8 , 184u8 , 57u8 , 219u8 , 254u8 , 164u8 , 101u8 , 168u8 , 4u8 , 225u8 , 12u8 , 116u8 , 55u8 ,]) } # [doc = " --- MAP ( netuid ) --> pow_registrations_this_interval"] pub fn pow_registrations_this_interval_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: pow_registrations_this_interval :: PowRegistrationsThisInterval , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "POWRegistrationsThisInterval" , () , [137u8 , 0u8 , 128u8 , 92u8 , 62u8 , 201u8 , 248u8 , 253u8 , 92u8 , 50u8 , 81u8 , 86u8 , 59u8 , 216u8 , 49u8 , 61u8 , 120u8 , 197u8 , 237u8 , 172u8 , 97u8 , 101u8 , 249u8 , 122u8 , 169u8 , 246u8 , 23u8 , 69u8 , 98u8 , 74u8 , 108u8 , 183u8 ,]) } # [doc = " --- MAP ( netuid ) --> pow_registrations_this_interval"] pub fn pow_registrations_this_interval (& self , _0 : impl :: core :: borrow :: Borrow < types :: pow_registrations_this_interval :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: pow_registrations_this_interval :: Param0 > , types :: pow_registrations_this_interval :: PowRegistrationsThisInterval , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "POWRegistrationsThisInterval" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [137u8 , 0u8 , 128u8 , 92u8 , 62u8 , 201u8 , 248u8 , 253u8 , 92u8 , 50u8 , 81u8 , 86u8 , 59u8 , 216u8 , 49u8 , 61u8 , 120u8 , 197u8 , 237u8 , 172u8 , 97u8 , 101u8 , 249u8 , 122u8 , 169u8 , 246u8 , 23u8 , 69u8 , 98u8 , 74u8 , 108u8 , 183u8 ,]) } # [doc = " --- MAP ( netuid ) --> burn_registrations_this_interval"] pub fn burn_registrations_this_interval_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: burn_registrations_this_interval :: BurnRegistrationsThisInterval , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "BurnRegistrationsThisInterval" , () , [41u8 , 170u8 , 250u8 , 166u8 , 41u8 , 18u8 , 190u8 , 42u8 , 45u8 , 103u8 , 105u8 , 137u8 , 86u8 , 241u8 , 101u8 , 43u8 , 205u8 , 174u8 , 251u8 , 227u8 , 82u8 , 119u8 , 19u8 , 94u8 , 41u8 , 10u8 , 132u8 , 0u8 , 171u8 , 248u8 , 147u8 , 114u8 ,]) } # [doc = " --- MAP ( netuid ) --> burn_registrations_this_interval"] pub fn burn_registrations_this_interval (& self , _0 : impl :: core :: borrow :: Borrow < types :: burn_registrations_this_interval :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: burn_registrations_this_interval :: Param0 > , types :: burn_registrations_this_interval :: BurnRegistrationsThisInterval , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "BurnRegistrationsThisInterval" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [41u8 , 170u8 , 250u8 , 166u8 , 41u8 , 18u8 , 190u8 , 42u8 , 45u8 , 103u8 , 105u8 , 137u8 , 86u8 , 241u8 , 101u8 , 43u8 , 205u8 , 174u8 , 251u8 , 227u8 , 82u8 , 119u8 , 19u8 , 94u8 , 41u8 , 10u8 , 132u8 , 0u8 , 171u8 , 248u8 , 147u8 , 114u8 ,]) } # [doc = " --- MAP ( netuid ) --> max_allowed_uids"] pub fn max_allowed_uids_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: max_allowed_uids :: MaxAllowedUids , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "MaxAllowedUids" , () , [103u8 , 194u8 , 4u8 , 173u8 , 182u8 , 163u8 , 163u8 , 1u8 , 186u8 , 185u8 , 66u8 , 126u8 , 65u8 , 255u8 , 56u8 , 124u8 , 32u8 , 146u8 , 248u8 , 172u8 , 106u8 , 230u8 , 16u8 , 17u8 , 58u8 , 105u8 , 32u8 , 199u8 , 104u8 , 148u8 , 89u8 , 220u8 ,]) } # [doc = " --- MAP ( netuid ) --> max_allowed_uids"] pub fn max_allowed_uids (& self , _0 : impl :: core :: borrow :: Borrow < types :: max_allowed_uids :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: max_allowed_uids :: Param0 > , types :: max_allowed_uids :: MaxAllowedUids , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "MaxAllowedUids" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [103u8 , 194u8 , 4u8 , 173u8 , 182u8 , 163u8 , 163u8 , 1u8 , 186u8 , 185u8 , 66u8 , 126u8 , 65u8 , 255u8 , 56u8 , 124u8 , 32u8 , 146u8 , 248u8 , 172u8 , 106u8 , 230u8 , 16u8 , 17u8 , 58u8 , 105u8 , 32u8 , 199u8 , 104u8 , 148u8 , 89u8 , 220u8 ,]) } # [doc = " --- MAP ( netuid ) --> immunity_period"] pub fn immunity_period_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: immunity_period :: ImmunityPeriod , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "ImmunityPeriod" , () , [70u8 , 128u8 , 190u8 , 139u8 , 24u8 , 7u8 , 169u8 , 148u8 , 152u8 , 190u8 , 182u8 , 15u8 , 153u8 , 243u8 , 173u8 , 164u8 , 90u8 , 126u8 , 88u8 , 147u8 , 204u8 , 184u8 , 113u8 , 40u8 , 239u8 , 243u8 , 172u8 , 127u8 , 255u8 , 98u8 , 163u8 , 185u8 ,]) } # [doc = " --- MAP ( netuid ) --> immunity_period"] pub fn immunity_period (& self , _0 : impl :: core :: borrow :: Borrow < types :: immunity_period :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: immunity_period :: Param0 > , types :: immunity_period :: ImmunityPeriod , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "ImmunityPeriod" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [70u8 , 128u8 , 190u8 , 139u8 , 24u8 , 7u8 , 169u8 , 148u8 , 152u8 , 190u8 , 182u8 , 15u8 , 153u8 , 243u8 , 173u8 , 164u8 , 90u8 , 126u8 , 88u8 , 147u8 , 204u8 , 184u8 , 113u8 , 40u8 , 239u8 , 243u8 , 172u8 , 127u8 , 255u8 , 98u8 , 163u8 , 185u8 ,]) } # [doc = " --- MAP ( netuid ) --> activity_cutoff"] pub fn activity_cutoff_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: activity_cutoff :: ActivityCutoff , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "ActivityCutoff" , () , [89u8 , 224u8 , 144u8 , 219u8 , 103u8 , 178u8 , 43u8 , 161u8 , 8u8 , 116u8 , 75u8 , 181u8 , 177u8 , 97u8 , 38u8 , 12u8 , 230u8 , 202u8 , 240u8 , 40u8 , 163u8 , 225u8 , 236u8 , 151u8 , 197u8 , 24u8 , 193u8 , 70u8 , 47u8 , 214u8 , 240u8 , 83u8 ,]) } # [doc = " --- MAP ( netuid ) --> activity_cutoff"] pub fn activity_cutoff (& self , _0 : impl :: core :: borrow :: Borrow < types :: activity_cutoff :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: activity_cutoff :: Param0 > , types :: activity_cutoff :: ActivityCutoff , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "ActivityCutoff" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [89u8 , 224u8 , 144u8 , 219u8 , 103u8 , 178u8 , 43u8 , 161u8 , 8u8 , 116u8 , 75u8 , 181u8 , 177u8 , 97u8 , 38u8 , 12u8 , 230u8 , 202u8 , 240u8 , 40u8 , 163u8 , 225u8 , 236u8 , 151u8 , 197u8 , 24u8 , 193u8 , 70u8 , 47u8 , 214u8 , 240u8 , 83u8 ,]) } # [doc = " --- MAP ( netuid ) --> max_weight_limit"] pub fn max_weights_limit_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: max_weights_limit :: MaxWeightsLimit , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "MaxWeightsLimit" , () , [198u8 , 221u8 , 166u8 , 90u8 , 109u8 , 226u8 , 24u8 , 172u8 , 8u8 , 92u8 , 3u8 , 179u8 , 61u8 , 108u8 , 46u8 , 173u8 , 79u8 , 176u8 , 231u8 , 164u8 , 178u8 , 33u8 , 159u8 , 184u8 , 204u8 , 159u8 , 129u8 , 227u8 , 62u8 , 79u8 , 147u8 , 179u8 ,]) } # [doc = " --- MAP ( netuid ) --> max_weight_limit"] pub fn max_weights_limit (& self , _0 : impl :: core :: borrow :: Borrow < types :: max_weights_limit :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: max_weights_limit :: Param0 > , types :: max_weights_limit :: MaxWeightsLimit , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "MaxWeightsLimit" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [198u8 , 221u8 , 166u8 , 90u8 , 109u8 , 226u8 , 24u8 , 172u8 , 8u8 , 92u8 , 3u8 , 179u8 , 61u8 , 108u8 , 46u8 , 173u8 , 79u8 , 176u8 , 231u8 , 164u8 , 178u8 , 33u8 , 159u8 , 184u8 , 204u8 , 159u8 , 129u8 , 227u8 , 62u8 , 79u8 , 147u8 , 179u8 ,]) } # [doc = " --- MAP ( netuid ) --> weights_version_key"] pub fn weights_version_key_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: weights_version_key :: WeightsVersionKey , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "WeightsVersionKey" , () , [21u8 , 190u8 , 212u8 , 229u8 , 10u8 , 128u8 , 146u8 , 53u8 , 14u8 , 95u8 , 216u8 , 17u8 , 0u8 , 196u8 , 96u8 , 121u8 , 100u8 , 183u8 , 80u8 , 81u8 , 116u8 , 83u8 , 3u8 , 105u8 , 49u8 , 82u8 , 37u8 , 43u8 , 15u8 , 225u8 , 181u8 , 13u8 ,]) } # [doc = " --- MAP ( netuid ) --> weights_version_key"] pub fn weights_version_key (& self , _0 : impl :: core :: borrow :: Borrow < types :: weights_version_key :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: weights_version_key :: Param0 > , types :: weights_version_key :: WeightsVersionKey , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "WeightsVersionKey" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [21u8 , 190u8 , 212u8 , 229u8 , 10u8 , 128u8 , 146u8 , 53u8 , 14u8 , 95u8 , 216u8 , 17u8 , 0u8 , 196u8 , 96u8 , 121u8 , 100u8 , 183u8 , 80u8 , 81u8 , 116u8 , 83u8 , 3u8 , 105u8 , 49u8 , 82u8 , 37u8 , 43u8 , 15u8 , 225u8 , 181u8 , 13u8 ,]) } # [doc = " --- MAP ( netuid ) --> min_allowed_weights"] pub fn min_allowed_weights_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: min_allowed_weights :: MinAllowedWeights , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "MinAllowedWeights" , () , [113u8 , 188u8 , 139u8 , 178u8 , 162u8 , 34u8 , 89u8 , 245u8 , 248u8 , 78u8 , 152u8 , 110u8 , 240u8 , 138u8 , 117u8 , 226u8 , 247u8 , 84u8 , 43u8 , 89u8 , 219u8 , 75u8 , 228u8 , 50u8 , 212u8 , 17u8 , 128u8 , 228u8 , 4u8 , 247u8 , 173u8 , 138u8 ,]) } # [doc = " --- MAP ( netuid ) --> min_allowed_weights"] pub fn min_allowed_weights (& self , _0 : impl :: core :: borrow :: Borrow < types :: min_allowed_weights :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: min_allowed_weights :: Param0 > , types :: min_allowed_weights :: MinAllowedWeights , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "MinAllowedWeights" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [113u8 , 188u8 , 139u8 , 178u8 , 162u8 , 34u8 , 89u8 , 245u8 , 248u8 , 78u8 , 152u8 , 110u8 , 240u8 , 138u8 , 117u8 , 226u8 , 247u8 , 84u8 , 43u8 , 89u8 , 219u8 , 75u8 , 228u8 , 50u8 , 212u8 , 17u8 , 128u8 , 228u8 , 4u8 , 247u8 , 173u8 , 138u8 ,]) } # [doc = " --- MAP ( netuid ) --> max_allowed_validators"] pub fn max_allowed_validators_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: max_allowed_validators :: MaxAllowedValidators , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "MaxAllowedValidators" , () , [94u8 , 68u8 , 128u8 , 243u8 , 87u8 , 104u8 , 50u8 , 96u8 , 190u8 , 109u8 , 70u8 , 25u8 , 40u8 , 54u8 , 181u8 , 68u8 , 187u8 , 79u8 , 42u8 , 131u8 , 132u8 , 52u8 , 209u8 , 7u8 , 93u8 , 235u8 , 162u8 , 168u8 , 32u8 , 170u8 , 214u8 , 211u8 ,]) } # [doc = " --- MAP ( netuid ) --> max_allowed_validators"] pub fn max_allowed_validators (& self , _0 : impl :: core :: borrow :: Borrow < types :: max_allowed_validators :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: max_allowed_validators :: Param0 > , types :: max_allowed_validators :: MaxAllowedValidators , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "MaxAllowedValidators" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [94u8 , 68u8 , 128u8 , 243u8 , 87u8 , 104u8 , 50u8 , 96u8 , 190u8 , 109u8 , 70u8 , 25u8 , 40u8 , 54u8 , 181u8 , 68u8 , 187u8 , 79u8 , 42u8 , 131u8 , 132u8 , 52u8 , 209u8 , 7u8 , 93u8 , 235u8 , 162u8 , 168u8 , 32u8 , 170u8 , 214u8 , 211u8 ,]) } # [doc = " --- MAP ( netuid ) --> adjustment_interval"] pub fn adjustment_interval_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: adjustment_interval :: AdjustmentInterval , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "AdjustmentInterval" , () , [15u8 , 129u8 , 107u8 , 246u8 , 81u8 , 165u8 , 110u8 , 41u8 , 213u8 , 47u8 , 234u8 , 166u8 , 249u8 , 35u8 , 197u8 , 152u8 , 31u8 , 7u8 , 189u8 , 120u8 , 17u8 , 254u8 , 156u8 , 91u8 , 135u8 , 51u8 , 166u8 , 229u8 , 115u8 , 41u8 , 33u8 , 7u8 ,]) } # [doc = " --- MAP ( netuid ) --> adjustment_interval"] pub fn adjustment_interval (& self , _0 : impl :: core :: borrow :: Borrow < types :: adjustment_interval :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: adjustment_interval :: Param0 > , types :: adjustment_interval :: AdjustmentInterval , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "AdjustmentInterval" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [15u8 , 129u8 , 107u8 , 246u8 , 81u8 , 165u8 , 110u8 , 41u8 , 213u8 , 47u8 , 234u8 , 166u8 , 249u8 , 35u8 , 197u8 , 152u8 , 31u8 , 7u8 , 189u8 , 120u8 , 17u8 , 254u8 , 156u8 , 91u8 , 135u8 , 51u8 , 166u8 , 229u8 , 115u8 , 41u8 , 33u8 , 7u8 ,]) } # [doc = " --- MAP ( netuid ) --> bonds_moving_average"] pub fn bonds_moving_average_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: bonds_moving_average :: BondsMovingAverage , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "BondsMovingAverage" , () , [180u8 , 93u8 , 149u8 , 65u8 , 179u8 , 150u8 , 79u8 , 96u8 , 198u8 , 26u8 , 139u8 , 204u8 , 144u8 , 76u8 , 179u8 , 99u8 , 57u8 , 231u8 , 43u8 , 202u8 , 40u8 , 230u8 , 192u8 , 248u8 , 53u8 , 225u8 , 201u8 , 143u8 , 48u8 , 161u8 , 90u8 , 111u8 ,]) } # [doc = " --- MAP ( netuid ) --> bonds_moving_average"] pub fn bonds_moving_average (& self , _0 : impl :: core :: borrow :: Borrow < types :: bonds_moving_average :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: bonds_moving_average :: Param0 > , types :: bonds_moving_average :: BondsMovingAverage , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "BondsMovingAverage" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [180u8 , 93u8 , 149u8 , 65u8 , 179u8 , 150u8 , 79u8 , 96u8 , 198u8 , 26u8 , 139u8 , 204u8 , 144u8 , 76u8 , 179u8 , 99u8 , 57u8 , 231u8 , 43u8 , 202u8 , 40u8 , 230u8 , 192u8 , 248u8 , 53u8 , 225u8 , 201u8 , 143u8 , 48u8 , 161u8 , 90u8 , 111u8 ,]) } # [doc = " --- MAP ( netuid ) --> weights_set_rate_limit"] pub fn weights_set_rate_limit_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: weights_set_rate_limit :: WeightsSetRateLimit , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "WeightsSetRateLimit" , () , [70u8 , 81u8 , 142u8 , 75u8 , 162u8 , 207u8 , 75u8 , 24u8 , 120u8 , 233u8 , 253u8 , 71u8 , 249u8 , 9u8 , 62u8 , 169u8 , 119u8 , 124u8 , 45u8 , 113u8 , 77u8 , 186u8 , 55u8 , 4u8 , 5u8 , 91u8 , 166u8 , 171u8 , 41u8 , 215u8 , 57u8 , 132u8 ,]) } # [doc = " --- MAP ( netuid ) --> weights_set_rate_limit"] pub fn weights_set_rate_limit (& self , _0 : impl :: core :: borrow :: Borrow < types :: weights_set_rate_limit :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: weights_set_rate_limit :: Param0 > , types :: weights_set_rate_limit :: WeightsSetRateLimit , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "WeightsSetRateLimit" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [70u8 , 81u8 , 142u8 , 75u8 , 162u8 , 207u8 , 75u8 , 24u8 , 120u8 , 233u8 , 253u8 , 71u8 , 249u8 , 9u8 , 62u8 , 169u8 , 119u8 , 124u8 , 45u8 , 113u8 , 77u8 , 186u8 , 55u8 , 4u8 , 5u8 , 91u8 , 166u8 , 171u8 , 41u8 , 215u8 , 57u8 , 132u8 ,]) } # [doc = " --- MAP ( netuid ) --> validator_prune_len"] pub fn validator_prune_len_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: validator_prune_len :: ValidatorPruneLen , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "ValidatorPruneLen" , () , [225u8 , 241u8 , 182u8 , 243u8 , 247u8 , 144u8 , 187u8 , 64u8 , 15u8 , 223u8 , 8u8 , 214u8 , 171u8 , 122u8 , 162u8 , 33u8 , 163u8 , 216u8 , 48u8 , 146u8 , 253u8 , 230u8 , 250u8 , 22u8 , 22u8 , 110u8 , 204u8 , 70u8 , 126u8 , 246u8 , 100u8 , 69u8 ,]) } # [doc = " --- MAP ( netuid ) --> validator_prune_len"] pub fn validator_prune_len (& self , _0 : impl :: core :: borrow :: Borrow < types :: validator_prune_len :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: validator_prune_len :: Param0 > , types :: validator_prune_len :: ValidatorPruneLen , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "ValidatorPruneLen" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [225u8 , 241u8 , 182u8 , 243u8 , 247u8 , 144u8 , 187u8 , 64u8 , 15u8 , 223u8 , 8u8 , 214u8 , 171u8 , 122u8 , 162u8 , 33u8 , 163u8 , 216u8 , 48u8 , 146u8 , 253u8 , 230u8 , 250u8 , 22u8 , 22u8 , 110u8 , 204u8 , 70u8 , 126u8 , 246u8 , 100u8 , 69u8 ,]) } # [doc = " --- MAP ( netuid ) --> scaling_law_power"] pub fn scaling_law_power_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: scaling_law_power :: ScalingLawPower , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "ScalingLawPower" , () , [195u8 , 171u8 , 225u8 , 2u8 , 211u8 , 254u8 , 87u8 , 76u8 , 255u8 , 7u8 , 175u8 , 101u8 , 123u8 , 92u8 , 44u8 , 26u8 , 124u8 , 92u8 , 9u8 , 207u8 , 82u8 , 30u8 , 243u8 , 26u8 , 52u8 , 12u8 , 200u8 , 149u8 , 93u8 , 23u8 , 204u8 , 141u8 ,]) } # [doc = " --- MAP ( netuid ) --> scaling_law_power"] pub fn scaling_law_power (& self , _0 : impl :: core :: borrow :: Borrow < types :: scaling_law_power :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: scaling_law_power :: Param0 > , types :: scaling_law_power :: ScalingLawPower , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "ScalingLawPower" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [195u8 , 171u8 , 225u8 , 2u8 , 211u8 , 254u8 , 87u8 , 76u8 , 255u8 , 7u8 , 175u8 , 101u8 , 123u8 , 92u8 , 44u8 , 26u8 , 124u8 , 92u8 , 9u8 , 207u8 , 82u8 , 30u8 , 243u8 , 26u8 , 52u8 , 12u8 , 200u8 , 149u8 , 93u8 , 23u8 , 204u8 , 141u8 ,]) } # [doc = " --- MAP ( netuid ) --> target_registrations_this_interval"] pub fn target_registrations_per_interval_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: target_registrations_per_interval :: TargetRegistrationsPerInterval , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "TargetRegistrationsPerInterval" , () , [247u8 , 135u8 , 194u8 , 5u8 , 122u8 , 104u8 , 128u8 , 94u8 , 82u8 , 135u8 , 63u8 , 72u8 , 251u8 , 3u8 , 214u8 , 85u8 , 135u8 , 197u8 , 37u8 , 148u8 , 25u8 , 94u8 , 245u8 , 248u8 , 154u8 , 200u8 , 14u8 , 171u8 , 123u8 , 45u8 , 120u8 , 169u8 ,]) } # [doc = " --- MAP ( netuid ) --> target_registrations_this_interval"] pub fn target_registrations_per_interval (& self , _0 : impl :: core :: borrow :: Borrow < types :: target_registrations_per_interval :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: target_registrations_per_interval :: Param0 > , types :: target_registrations_per_interval :: TargetRegistrationsPerInterval , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "TargetRegistrationsPerInterval" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [247u8 , 135u8 , 194u8 , 5u8 , 122u8 , 104u8 , 128u8 , 94u8 , 82u8 , 135u8 , 63u8 , 72u8 , 251u8 , 3u8 , 214u8 , 85u8 , 135u8 , 197u8 , 37u8 , 148u8 , 25u8 , 94u8 , 245u8 , 248u8 , 154u8 , 200u8 , 14u8 , 171u8 , 123u8 , 45u8 , 120u8 , 169u8 ,]) } # [doc = " --- MAP ( netuid ) --> adjustment_alpha"] pub fn adjustment_alpha_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: adjustment_alpha :: AdjustmentAlpha , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "AdjustmentAlpha" , () , [196u8 , 142u8 , 243u8 , 223u8 , 191u8 , 243u8 , 62u8 , 46u8 , 192u8 , 200u8 , 86u8 , 147u8 , 223u8 , 1u8 , 114u8 , 131u8 , 243u8 , 132u8 , 109u8 , 102u8 , 227u8 , 126u8 , 100u8 , 135u8 , 200u8 , 31u8 , 16u8 , 3u8 , 232u8 , 169u8 , 50u8 , 202u8 ,]) } # [doc = " --- MAP ( netuid ) --> adjustment_alpha"] pub fn adjustment_alpha (& self , _0 : impl :: core :: borrow :: Borrow < types :: adjustment_alpha :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: adjustment_alpha :: Param0 > , types :: adjustment_alpha :: AdjustmentAlpha , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "AdjustmentAlpha" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [196u8 , 142u8 , 243u8 , 223u8 , 191u8 , 243u8 , 62u8 , 46u8 , 192u8 , 200u8 , 86u8 , 147u8 , 223u8 , 1u8 , 114u8 , 131u8 , 243u8 , 132u8 , 109u8 , 102u8 , 227u8 , 126u8 , 100u8 , 135u8 , 200u8 , 31u8 , 16u8 , 3u8 , 232u8 , 169u8 , 50u8 , 202u8 ,]) } # [doc = " --- MAP ( netuid ) --> interval"] pub fn weight_commit_reveal_interval_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: weight_commit_reveal_interval :: WeightCommitRevealInterval , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "WeightCommitRevealInterval" , () , [184u8 , 226u8 , 91u8 , 179u8 , 42u8 , 149u8 , 252u8 , 61u8 , 95u8 , 56u8 , 53u8 , 119u8 , 126u8 , 3u8 , 226u8 , 16u8 , 150u8 , 27u8 , 42u8 , 251u8 , 77u8 , 29u8 , 221u8 , 185u8 , 162u8 , 176u8 , 35u8 , 231u8 , 98u8 , 0u8 , 65u8 , 110u8 ,]) } # [doc = " --- MAP ( netuid ) --> interval"] pub fn weight_commit_reveal_interval (& self , _0 : impl :: core :: borrow :: Borrow < types :: weight_commit_reveal_interval :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: weight_commit_reveal_interval :: Param0 > , types :: weight_commit_reveal_interval :: WeightCommitRevealInterval , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "WeightCommitRevealInterval" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [184u8 , 226u8 , 91u8 , 179u8 , 42u8 , 149u8 , 252u8 , 61u8 , 95u8 , 56u8 , 53u8 , 119u8 , 126u8 , 3u8 , 226u8 , 16u8 , 150u8 , 27u8 , 42u8 , 251u8 , 77u8 , 29u8 , 221u8 , 185u8 , 162u8 , 176u8 , 35u8 , 231u8 , 98u8 , 0u8 , 65u8 , 110u8 ,]) } # [doc = " --- MAP ( netuid ) --> interval"] pub fn commit_reveal_weights_enabled_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: commit_reveal_weights_enabled :: CommitRevealWeightsEnabled , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "CommitRevealWeightsEnabled" , () , [216u8 , 167u8 , 84u8 , 74u8 , 22u8 , 47u8 , 162u8 , 28u8 , 190u8 , 63u8 , 128u8 , 98u8 , 46u8 , 14u8 , 16u8 , 23u8 , 87u8 , 105u8 , 39u8 , 26u8 , 193u8 , 133u8 , 104u8 , 14u8 , 236u8 , 4u8 , 99u8 , 48u8 , 147u8 , 217u8 , 122u8 , 12u8 ,]) } # [doc = " --- MAP ( netuid ) --> interval"] pub fn commit_reveal_weights_enabled (& self , _0 : impl :: core :: borrow :: Borrow < types :: commit_reveal_weights_enabled :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: commit_reveal_weights_enabled :: Param0 > , types :: commit_reveal_weights_enabled :: CommitRevealWeightsEnabled , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "CommitRevealWeightsEnabled" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [216u8 , 167u8 , 84u8 , 74u8 , 22u8 , 47u8 , 162u8 , 28u8 , 190u8 , 63u8 , 128u8 , 98u8 , 46u8 , 14u8 , 16u8 , 23u8 , 87u8 , 105u8 , 39u8 , 26u8 , 193u8 , 133u8 , 104u8 , 14u8 , 236u8 , 4u8 , 99u8 , 48u8 , 147u8 , 217u8 , 122u8 , 12u8 ,]) } # [doc = " --- MAP ( netuid ) --> Burn"] pub fn burn_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: burn :: Burn , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "Burn" , () , [134u8 , 249u8 , 72u8 , 227u8 , 164u8 , 150u8 , 29u8 , 202u8 , 167u8 , 78u8 , 169u8 , 202u8 , 117u8 , 18u8 , 74u8 , 177u8 , 170u8 , 54u8 , 189u8 , 3u8 , 191u8 , 118u8 , 230u8 , 152u8 , 143u8 , 64u8 , 28u8 , 220u8 , 17u8 , 188u8 , 95u8 , 85u8 ,]) } # [doc = " --- MAP ( netuid ) --> Burn"] pub fn burn (& self , _0 : impl :: core :: borrow :: Borrow < types :: burn :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: burn :: Param0 > , types :: burn :: Burn , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "Burn" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [134u8 , 249u8 , 72u8 , 227u8 , 164u8 , 150u8 , 29u8 , 202u8 , 167u8 , 78u8 , 169u8 , 202u8 , 117u8 , 18u8 , 74u8 , 177u8 , 170u8 , 54u8 , 189u8 , 3u8 , 191u8 , 118u8 , 230u8 , 152u8 , 143u8 , 64u8 , 28u8 , 220u8 , 17u8 , 188u8 , 95u8 , 85u8 ,]) } # [doc = " --- MAP ( netuid ) --> Difficulty"] pub fn difficulty_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: difficulty :: Difficulty , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "Difficulty" , () , [251u8 , 34u8 , 39u8 , 171u8 , 188u8 , 29u8 , 213u8 , 224u8 , 58u8 , 140u8 , 159u8 , 80u8 , 99u8 , 174u8 , 82u8 , 230u8 , 30u8 , 53u8 , 104u8 , 185u8 , 51u8 , 144u8 , 121u8 , 225u8 , 20u8 , 128u8 , 197u8 , 237u8 , 179u8 , 243u8 , 169u8 , 16u8 ,]) } # [doc = " --- MAP ( netuid ) --> Difficulty"] pub fn difficulty (& self , _0 : impl :: core :: borrow :: Borrow < types :: difficulty :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: difficulty :: Param0 > , types :: difficulty :: Difficulty , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "Difficulty" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [251u8 , 34u8 , 39u8 , 171u8 , 188u8 , 29u8 , 213u8 , 224u8 , 58u8 , 140u8 , 159u8 , 80u8 , 99u8 , 174u8 , 82u8 , 230u8 , 30u8 , 53u8 , 104u8 , 185u8 , 51u8 , 144u8 , 121u8 , 225u8 , 20u8 , 128u8 , 197u8 , 237u8 , 179u8 , 243u8 , 169u8 , 16u8 ,]) } # [doc = " --- MAP ( netuid ) --> MinBurn"] pub fn min_burn_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: min_burn :: MinBurn , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "MinBurn" , () , [19u8 , 248u8 , 152u8 , 23u8 , 215u8 , 212u8 , 154u8 , 20u8 , 192u8 , 175u8 , 155u8 , 103u8 , 211u8 , 111u8 , 68u8 , 95u8 , 178u8 , 178u8 , 69u8 , 101u8 , 40u8 , 57u8 , 114u8 , 12u8 , 177u8 , 156u8 , 18u8 , 151u8 , 11u8 , 231u8 , 22u8 , 126u8 ,]) } # [doc = " --- MAP ( netuid ) --> MinBurn"] pub fn min_burn (& self , _0 : impl :: core :: borrow :: Borrow < types :: min_burn :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: min_burn :: Param0 > , types :: min_burn :: MinBurn , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "MinBurn" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [19u8 , 248u8 , 152u8 , 23u8 , 215u8 , 212u8 , 154u8 , 20u8 , 192u8 , 175u8 , 155u8 , 103u8 , 211u8 , 111u8 , 68u8 , 95u8 , 178u8 , 178u8 , 69u8 , 101u8 , 40u8 , 57u8 , 114u8 , 12u8 , 177u8 , 156u8 , 18u8 , 151u8 , 11u8 , 231u8 , 22u8 , 126u8 ,]) } # [doc = " --- MAP ( netuid ) --> MaxBurn"] pub fn max_burn_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: max_burn :: MaxBurn , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "MaxBurn" , () , [0u8 , 195u8 , 55u8 , 83u8 , 46u8 , 216u8 , 74u8 , 42u8 , 213u8 , 195u8 , 52u8 , 6u8 , 8u8 , 168u8 , 21u8 , 78u8 , 78u8 , 188u8 , 54u8 , 6u8 , 254u8 , 140u8 , 3u8 , 0u8 , 184u8 , 108u8 , 1u8 , 150u8 , 42u8 , 245u8 , 125u8 , 144u8 ,]) } # [doc = " --- MAP ( netuid ) --> MaxBurn"] pub fn max_burn (& self , _0 : impl :: core :: borrow :: Borrow < types :: max_burn :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: max_burn :: Param0 > , types :: max_burn :: MaxBurn , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "MaxBurn" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [0u8 , 195u8 , 55u8 , 83u8 , 46u8 , 216u8 , 74u8 , 42u8 , 213u8 , 195u8 , 52u8 , 6u8 , 8u8 , 168u8 , 21u8 , 78u8 , 78u8 , 188u8 , 54u8 , 6u8 , 254u8 , 140u8 , 3u8 , 0u8 , 184u8 , 108u8 , 1u8 , 150u8 , 42u8 , 245u8 , 125u8 , 144u8 ,]) } # [doc = " --- MAP ( netuid ) --> MinDifficulty"] pub fn min_difficulty_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: min_difficulty :: MinDifficulty , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "MinDifficulty" , () , [186u8 , 124u8 , 59u8 , 202u8 , 23u8 , 68u8 , 43u8 , 124u8 , 166u8 , 157u8 , 228u8 , 253u8 , 99u8 , 174u8 , 95u8 , 37u8 , 178u8 , 38u8 , 240u8 , 168u8 , 139u8 , 123u8 , 81u8 , 66u8 , 146u8 , 179u8 , 179u8 , 217u8 , 45u8 , 203u8 , 135u8 , 12u8 ,]) } # [doc = " --- MAP ( netuid ) --> MinDifficulty"] pub fn min_difficulty (& self , _0 : impl :: core :: borrow :: Borrow < types :: min_difficulty :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: min_difficulty :: Param0 > , types :: min_difficulty :: MinDifficulty , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "MinDifficulty" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [186u8 , 124u8 , 59u8 , 202u8 , 23u8 , 68u8 , 43u8 , 124u8 , 166u8 , 157u8 , 228u8 , 253u8 , 99u8 , 174u8 , 95u8 , 37u8 , 178u8 , 38u8 , 240u8 , 168u8 , 139u8 , 123u8 , 81u8 , 66u8 , 146u8 , 179u8 , 179u8 , 217u8 , 45u8 , 203u8 , 135u8 , 12u8 ,]) } # [doc = " --- MAP ( netuid ) --> MaxDifficulty"] pub fn max_difficulty_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: max_difficulty :: MaxDifficulty , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "MaxDifficulty" , () , [46u8 , 129u8 , 147u8 , 99u8 , 203u8 , 64u8 , 250u8 , 115u8 , 78u8 , 126u8 , 86u8 , 90u8 , 91u8 , 101u8 , 252u8 , 190u8 , 89u8 , 98u8 , 95u8 , 209u8 , 168u8 , 144u8 , 206u8 , 209u8 , 230u8 , 119u8 , 170u8 , 174u8 , 84u8 , 75u8 , 213u8 , 222u8 ,]) } # [doc = " --- MAP ( netuid ) --> MaxDifficulty"] pub fn max_difficulty (& self , _0 : impl :: core :: borrow :: Borrow < types :: max_difficulty :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: max_difficulty :: Param0 > , types :: max_difficulty :: MaxDifficulty , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "MaxDifficulty" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [46u8 , 129u8 , 147u8 , 99u8 , 203u8 , 64u8 , 250u8 , 115u8 , 78u8 , 126u8 , 86u8 , 90u8 , 91u8 , 101u8 , 252u8 , 190u8 , 89u8 , 98u8 , 95u8 , 209u8 , 168u8 , 144u8 , 206u8 , 209u8 , 230u8 , 119u8 , 170u8 , 174u8 , 84u8 , 75u8 , 213u8 , 222u8 ,]) } # [doc = " --- MAP ( netuid ) -->  Block at last adjustment."] pub fn last_adjustment_block_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: last_adjustment_block :: LastAdjustmentBlock , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "LastAdjustmentBlock" , () , [144u8 , 153u8 , 243u8 , 4u8 , 76u8 , 97u8 , 87u8 , 84u8 , 16u8 , 101u8 , 8u8 , 162u8 , 236u8 , 213u8 , 60u8 , 161u8 , 131u8 , 22u8 , 249u8 , 109u8 , 242u8 , 70u8 , 138u8 , 19u8 , 19u8 , 224u8 , 199u8 , 163u8 , 240u8 , 219u8 , 187u8 , 201u8 ,]) } # [doc = " --- MAP ( netuid ) -->  Block at last adjustment."] pub fn last_adjustment_block (& self , _0 : impl :: core :: borrow :: Borrow < types :: last_adjustment_block :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: last_adjustment_block :: Param0 > , types :: last_adjustment_block :: LastAdjustmentBlock , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "LastAdjustmentBlock" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [144u8 , 153u8 , 243u8 , 4u8 , 76u8 , 97u8 , 87u8 , 84u8 , 16u8 , 101u8 , 8u8 , 162u8 , 236u8 , 213u8 , 60u8 , 161u8 , 131u8 , 22u8 , 249u8 , 109u8 , 242u8 , 70u8 , 138u8 , 19u8 , 19u8 , 224u8 , 199u8 , 163u8 , 240u8 , 219u8 , 187u8 , 201u8 ,]) } # [doc = " --- MAP ( netuid ) --> Registrations of this Block."] pub fn registrations_this_block_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: registrations_this_block :: RegistrationsThisBlock , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "RegistrationsThisBlock" , () , [198u8 , 109u8 , 86u8 , 170u8 , 84u8 , 243u8 , 34u8 , 155u8 , 134u8 , 251u8 , 21u8 , 201u8 , 98u8 , 132u8 , 34u8 , 187u8 , 239u8 , 182u8 , 72u8 , 144u8 , 4u8 , 47u8 , 32u8 , 207u8 , 5u8 , 54u8 , 210u8 , 249u8 , 58u8 , 211u8 , 113u8 , 113u8 ,]) } # [doc = " --- MAP ( netuid ) --> Registrations of this Block."] pub fn registrations_this_block (& self , _0 : impl :: core :: borrow :: Borrow < types :: registrations_this_block :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: registrations_this_block :: Param0 > , types :: registrations_this_block :: RegistrationsThisBlock , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "RegistrationsThisBlock" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [198u8 , 109u8 , 86u8 , 170u8 , 84u8 , 243u8 , 34u8 , 155u8 , 134u8 , 251u8 , 21u8 , 201u8 , 98u8 , 132u8 , 34u8 , 187u8 , 239u8 , 182u8 , 72u8 , 144u8 , 4u8 , 47u8 , 32u8 , 207u8 , 5u8 , 54u8 , 210u8 , 249u8 , 58u8 , 211u8 , 113u8 , 113u8 ,]) } # [doc = " --- MAP ( netuid ) --> global_RAO_recycled_for_registration"] pub fn rao_recycled_for_registration_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: rao_recycled_for_registration :: RaoRecycledForRegistration , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "RAORecycledForRegistration" , () , [124u8 , 58u8 , 21u8 , 4u8 , 81u8 , 158u8 , 21u8 , 117u8 , 241u8 , 67u8 , 244u8 , 109u8 , 179u8 , 60u8 , 157u8 , 209u8 , 46u8 , 76u8 , 232u8 , 89u8 , 152u8 , 61u8 , 230u8 , 85u8 , 32u8 , 213u8 , 63u8 , 161u8 , 129u8 , 143u8 , 234u8 , 250u8 ,]) } # [doc = " --- MAP ( netuid ) --> global_RAO_recycled_for_registration"] pub fn rao_recycled_for_registration (& self , _0 : impl :: core :: borrow :: Borrow < types :: rao_recycled_for_registration :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: rao_recycled_for_registration :: Param0 > , types :: rao_recycled_for_registration :: RaoRecycledForRegistration , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "RAORecycledForRegistration" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [124u8 , 58u8 , 21u8 , 4u8 , 81u8 , 158u8 , 21u8 , 117u8 , 241u8 , 67u8 , 244u8 , 109u8 , 179u8 , 60u8 , 157u8 , 209u8 , 46u8 , 76u8 , 232u8 , 89u8 , 152u8 , 61u8 , 230u8 , 85u8 , 32u8 , 213u8 , 63u8 , 161u8 , 129u8 , 143u8 , 234u8 , 250u8 ,]) } # [doc = " --- ITEM ( tx_rate_limit )"] pub fn tx_rate_limit (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: tx_rate_limit :: TxRateLimit , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "TxRateLimit" , () , [149u8 , 107u8 , 236u8 , 201u8 , 45u8 , 84u8 , 26u8 , 52u8 , 215u8 , 61u8 , 215u8 , 137u8 , 2u8 , 193u8 , 11u8 , 177u8 , 44u8 , 107u8 , 241u8 , 14u8 , 146u8 , 150u8 , 140u8 , 87u8 , 166u8 , 91u8 , 106u8 , 55u8 , 54u8 , 38u8 , 144u8 , 135u8 ,]) } # [doc = " --- ITEM ( tx_delegate_take_rate_limit )"] pub fn tx_delegate_take_rate_limit (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: tx_delegate_take_rate_limit :: TxDelegateTakeRateLimit , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "TxDelegateTakeRateLimit" , () , [35u8 , 50u8 , 47u8 , 168u8 , 70u8 , 43u8 , 231u8 , 96u8 , 101u8 , 158u8 , 34u8 , 209u8 , 65u8 , 244u8 , 40u8 , 13u8 , 247u8 , 24u8 , 44u8 , 249u8 , 223u8 , 235u8 , 131u8 , 169u8 , 40u8 , 145u8 , 67u8 , 204u8 , 158u8 , 187u8 , 232u8 , 12u8 ,]) } # [doc = " --- ITEM ( tx_childkey_take_rate_limit )"] pub fn tx_childkey_take_rate_limit (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: tx_childkey_take_rate_limit :: TxChildkeyTakeRateLimit , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "TxChildkeyTakeRateLimit" , () , [188u8 , 114u8 , 147u8 , 189u8 , 187u8 , 221u8 , 224u8 , 253u8 , 34u8 , 109u8 , 225u8 , 43u8 , 82u8 , 71u8 , 184u8 , 132u8 , 51u8 , 219u8 , 237u8 , 255u8 , 85u8 , 23u8 , 215u8 , 128u8 , 81u8 , 57u8 , 11u8 , 188u8 , 40u8 , 53u8 , 163u8 , 5u8 ,]) } # [doc = " --- MAP ( netuid ) --> Whether or not Liquid Alpha is enabled"] pub fn liquid_alpha_on_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: liquid_alpha_on :: LiquidAlphaOn , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "LiquidAlphaOn" , () , [163u8 , 44u8 , 143u8 , 121u8 , 172u8 , 79u8 , 198u8 , 64u8 , 45u8 , 150u8 , 212u8 , 4u8 , 77u8 , 48u8 , 41u8 , 44u8 , 26u8 , 120u8 , 241u8 , 133u8 , 10u8 , 166u8 , 41u8 , 158u8 , 78u8 , 25u8 , 47u8 , 239u8 , 113u8 , 220u8 , 109u8 , 194u8 ,]) } # [doc = " --- MAP ( netuid ) --> Whether or not Liquid Alpha is enabled"] pub fn liquid_alpha_on (& self , _0 : impl :: core :: borrow :: Borrow < types :: liquid_alpha_on :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: liquid_alpha_on :: Param0 > , types :: liquid_alpha_on :: LiquidAlphaOn , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "LiquidAlphaOn" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [163u8 , 44u8 , 143u8 , 121u8 , 172u8 , 79u8 , 198u8 , 64u8 , 45u8 , 150u8 , 212u8 , 4u8 , 77u8 , 48u8 , 41u8 , 44u8 , 26u8 , 120u8 , 241u8 , 133u8 , 10u8 , 166u8 , 41u8 , 158u8 , 78u8 , 25u8 , 47u8 , 239u8 , 113u8 , 220u8 , 109u8 , 194u8 ,]) } # [doc = "  MAP ( netuid ) --> (alpha_low, alpha_high)"] pub fn alpha_values_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: alpha_values :: AlphaValues , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "AlphaValues" , () , [172u8 , 118u8 , 42u8 , 110u8 , 137u8 , 250u8 , 125u8 , 146u8 , 214u8 , 245u8 , 167u8 , 25u8 , 67u8 , 46u8 , 246u8 , 87u8 , 156u8 , 158u8 , 138u8 , 90u8 , 78u8 , 155u8 , 107u8 , 107u8 , 231u8 , 197u8 , 212u8 , 170u8 , 182u8 , 86u8 , 106u8 , 190u8 ,]) } # [doc = "  MAP ( netuid ) --> (alpha_low, alpha_high)"] pub fn alpha_values (& self , _0 : impl :: core :: borrow :: Borrow < types :: alpha_values :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: alpha_values :: Param0 > , types :: alpha_values :: AlphaValues , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "AlphaValues" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [172u8 , 118u8 , 42u8 , 110u8 , 137u8 , 250u8 , 125u8 , 146u8 , 214u8 , 245u8 , 167u8 , 25u8 , 67u8 , 46u8 , 246u8 , 87u8 , 156u8 , 158u8 , 138u8 , 90u8 , 78u8 , 155u8 , 107u8 , 107u8 , 231u8 , 197u8 , 212u8 , 170u8 , 182u8 , 86u8 , 106u8 , 190u8 ,]) } # [doc = " MAP ( netuid ) --> max stake allowed on a subnet."] pub fn network_max_stake_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: network_max_stake :: NetworkMaxStake , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "NetworkMaxStake" , () , [24u8 , 242u8 , 229u8 , 179u8 , 250u8 , 249u8 , 112u8 , 113u8 , 189u8 , 13u8 , 176u8 , 222u8 , 52u8 , 135u8 , 76u8 , 82u8 , 188u8 , 182u8 , 139u8 , 212u8 , 235u8 , 53u8 , 154u8 , 13u8 , 239u8 , 185u8 , 48u8 , 91u8 , 73u8 , 54u8 , 32u8 , 75u8 ,]) } # [doc = " MAP ( netuid ) --> max stake allowed on a subnet."] pub fn network_max_stake (& self , _0 : impl :: core :: borrow :: Borrow < types :: network_max_stake :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: network_max_stake :: Param0 > , types :: network_max_stake :: NetworkMaxStake , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "NetworkMaxStake" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [24u8 , 242u8 , 229u8 , 179u8 , 250u8 , 249u8 , 112u8 , 113u8 , 189u8 , 13u8 , 176u8 , 222u8 , 52u8 , 135u8 , 76u8 , 82u8 , 188u8 , 182u8 , 139u8 , 212u8 , 235u8 , 53u8 , 154u8 , 13u8 , 239u8 , 185u8 , 48u8 , 91u8 , 73u8 , 54u8 , 32u8 , 75u8 ,]) } # [doc = " ======================================="] # [doc = " ==== Subnetwork Consensus Storage  ===="] # [doc = " ======================================="] pub fn stake_weight_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: stake_weight :: StakeWeight , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "StakeWeight" , () , [178u8 , 127u8 , 170u8 , 149u8 , 176u8 , 186u8 , 237u8 , 26u8 , 104u8 , 166u8 , 238u8 , 62u8 , 112u8 , 111u8 , 136u8 , 18u8 , 231u8 , 36u8 , 229u8 , 77u8 , 253u8 , 88u8 , 161u8 , 209u8 , 148u8 , 176u8 , 210u8 , 122u8 , 9u8 , 132u8 , 192u8 , 63u8 ,]) } # [doc = " ======================================="] # [doc = " ==== Subnetwork Consensus Storage  ===="] # [doc = " ======================================="] pub fn stake_weight (& self , _0 : impl :: core :: borrow :: Borrow < types :: stake_weight :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: stake_weight :: Param0 > , types :: stake_weight :: StakeWeight , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "StakeWeight" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [178u8 , 127u8 , 170u8 , 149u8 , 176u8 , 186u8 , 237u8 , 26u8 , 104u8 , 166u8 , 238u8 , 62u8 , 112u8 , 111u8 , 136u8 , 18u8 , 231u8 , 36u8 , 229u8 , 77u8 , 253u8 , 88u8 , 161u8 , 209u8 , 148u8 , 176u8 , 210u8 , 122u8 , 9u8 , 132u8 , 192u8 , 63u8 ,]) } # [doc = " --- DMAP ( netuid, hotkey ) --> uid"] pub fn uids_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: uids :: Uids , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "Uids" , () , [33u8 , 64u8 , 48u8 , 239u8 , 201u8 , 205u8 , 31u8 , 252u8 , 134u8 , 235u8 , 58u8 , 176u8 , 244u8 , 181u8 , 9u8 , 16u8 , 21u8 , 92u8 , 2u8 , 171u8 , 13u8 , 215u8 , 67u8 , 212u8 , 139u8 , 193u8 , 145u8 , 164u8 , 186u8 , 86u8 , 163u8 , 44u8 ,]) } # [doc = " --- DMAP ( netuid, hotkey ) --> uid"] pub fn uids_iter1 (& self , _0 : impl :: core :: borrow :: Borrow < types :: uids :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: uids :: Param0 > , types :: uids :: Uids , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "Uids" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [33u8 , 64u8 , 48u8 , 239u8 , 201u8 , 205u8 , 31u8 , 252u8 , 134u8 , 235u8 , 58u8 , 176u8 , 244u8 , 181u8 , 9u8 , 16u8 , 21u8 , 92u8 , 2u8 , 171u8 , 13u8 , 215u8 , 67u8 , 212u8 , 139u8 , 193u8 , 145u8 , 164u8 , 186u8 , 86u8 , 163u8 , 44u8 ,]) } # [doc = " --- DMAP ( netuid, hotkey ) --> uid"] pub fn uids (& self , _0 : impl :: core :: borrow :: Borrow < types :: uids :: Param0 > , _1 : impl :: core :: borrow :: Borrow < types :: uids :: Param1 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < (:: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: uids :: Param0 > , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: uids :: Param1 > ,) , types :: uids :: Uids , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "Uids" , (:: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_1 . borrow ()) ,) , [33u8 , 64u8 , 48u8 , 239u8 , 201u8 , 205u8 , 31u8 , 252u8 , 134u8 , 235u8 , 58u8 , 176u8 , 244u8 , 181u8 , 9u8 , 16u8 , 21u8 , 92u8 , 2u8 , 171u8 , 13u8 , 215u8 , 67u8 , 212u8 , 139u8 , 193u8 , 145u8 , 164u8 , 186u8 , 86u8 , 163u8 , 44u8 ,]) } # [doc = " --- DMAP ( netuid, uid ) --> hotkey"] pub fn keys_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: keys :: Keys , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "Keys" , () , [110u8 , 251u8 , 14u8 , 35u8 , 199u8 , 87u8 , 231u8 , 16u8 , 178u8 , 193u8 , 240u8 , 20u8 , 184u8 , 57u8 , 187u8 , 227u8 , 67u8 , 80u8 , 120u8 , 148u8 , 51u8 , 239u8 , 130u8 , 12u8 , 35u8 , 84u8 , 213u8 , 233u8 , 239u8 , 79u8 , 153u8 , 141u8 ,]) } # [doc = " --- DMAP ( netuid, uid ) --> hotkey"] pub fn keys_iter1 (& self , _0 : impl :: core :: borrow :: Borrow < types :: keys :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: keys :: Param0 > , types :: keys :: Keys , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "Keys" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [110u8 , 251u8 , 14u8 , 35u8 , 199u8 , 87u8 , 231u8 , 16u8 , 178u8 , 193u8 , 240u8 , 20u8 , 184u8 , 57u8 , 187u8 , 227u8 , 67u8 , 80u8 , 120u8 , 148u8 , 51u8 , 239u8 , 130u8 , 12u8 , 35u8 , 84u8 , 213u8 , 233u8 , 239u8 , 79u8 , 153u8 , 141u8 ,]) } # [doc = " --- DMAP ( netuid, uid ) --> hotkey"] pub fn keys (& self , _0 : impl :: core :: borrow :: Borrow < types :: keys :: Param0 > , _1 : impl :: core :: borrow :: Borrow < types :: keys :: Param1 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < (:: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: keys :: Param0 > , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: keys :: Param1 > ,) , types :: keys :: Keys , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "Keys" , (:: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_1 . borrow ()) ,) , [110u8 , 251u8 , 14u8 , 35u8 , 199u8 , 87u8 , 231u8 , 16u8 , 178u8 , 193u8 , 240u8 , 20u8 , 184u8 , 57u8 , 187u8 , 227u8 , 67u8 , 80u8 , 120u8 , 148u8 , 51u8 , 239u8 , 130u8 , 12u8 , 35u8 , 84u8 , 213u8 , 233u8 , 239u8 , 79u8 , 153u8 , 141u8 ,]) } # [doc = " --- DMAP ( netuid ) --> (hotkey, se, ve)"] pub fn loaded_emission_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: loaded_emission :: LoadedEmission , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "LoadedEmission" , () , [99u8 , 238u8 , 26u8 , 122u8 , 183u8 , 3u8 , 163u8 , 126u8 , 63u8 , 141u8 , 224u8 , 228u8 , 59u8 , 73u8 , 241u8 , 12u8 , 25u8 , 95u8 , 185u8 , 31u8 , 35u8 , 168u8 , 166u8 , 104u8 , 233u8 , 10u8 , 246u8 , 80u8 , 62u8 , 8u8 , 187u8 , 16u8 ,]) } # [doc = " --- DMAP ( netuid ) --> (hotkey, se, ve)"] pub fn loaded_emission (& self , _0 : impl :: core :: borrow :: Borrow < types :: loaded_emission :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: loaded_emission :: Param0 > , types :: loaded_emission :: LoadedEmission , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "LoadedEmission" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [99u8 , 238u8 , 26u8 , 122u8 , 183u8 , 3u8 , 163u8 , 126u8 , 63u8 , 141u8 , 224u8 , 228u8 , 59u8 , 73u8 , 241u8 , 12u8 , 25u8 , 95u8 , 185u8 , 31u8 , 35u8 , 168u8 , 166u8 , 104u8 , 233u8 , 10u8 , 246u8 , 80u8 , 62u8 , 8u8 , 187u8 , 16u8 ,]) } # [doc = " --- DMAP ( netuid ) --> active"] pub fn active_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: active :: Active , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "Active" , () , [109u8 , 164u8 , 208u8 , 202u8 , 150u8 , 33u8 , 250u8 , 59u8 , 200u8 , 234u8 , 174u8 , 246u8 , 204u8 , 164u8 , 219u8 , 4u8 , 30u8 , 216u8 , 35u8 , 171u8 , 114u8 , 26u8 , 160u8 , 36u8 , 0u8 , 44u8 , 242u8 , 135u8 , 105u8 , 101u8 , 94u8 , 193u8 ,]) } # [doc = " --- DMAP ( netuid ) --> active"] pub fn active (& self , _0 : impl :: core :: borrow :: Borrow < types :: active :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: active :: Param0 > , types :: active :: Active , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "Active" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [109u8 , 164u8 , 208u8 , 202u8 , 150u8 , 33u8 , 250u8 , 59u8 , 200u8 , 234u8 , 174u8 , 246u8 , 204u8 , 164u8 , 219u8 , 4u8 , 30u8 , 216u8 , 35u8 , 171u8 , 114u8 , 26u8 , 160u8 , 36u8 , 0u8 , 44u8 , 242u8 , 135u8 , 105u8 , 101u8 , 94u8 , 193u8 ,]) } # [doc = " --- DMAP ( netuid ) --> rank"] pub fn rank_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: rank :: Rank , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "Rank" , () , [33u8 , 31u8 , 249u8 , 241u8 , 86u8 , 164u8 , 206u8 , 129u8 , 237u8 , 230u8 , 157u8 , 154u8 , 167u8 , 190u8 , 153u8 , 34u8 , 68u8 , 77u8 , 205u8 , 51u8 , 187u8 , 123u8 , 177u8 , 19u8 , 59u8 , 235u8 , 249u8 , 108u8 , 91u8 , 120u8 , 138u8 , 50u8 ,]) } # [doc = " --- DMAP ( netuid ) --> rank"] pub fn rank (& self , _0 : impl :: core :: borrow :: Borrow < types :: rank :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: rank :: Param0 > , types :: rank :: Rank , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "Rank" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [33u8 , 31u8 , 249u8 , 241u8 , 86u8 , 164u8 , 206u8 , 129u8 , 237u8 , 230u8 , 157u8 , 154u8 , 167u8 , 190u8 , 153u8 , 34u8 , 68u8 , 77u8 , 205u8 , 51u8 , 187u8 , 123u8 , 177u8 , 19u8 , 59u8 , 235u8 , 249u8 , 108u8 , 91u8 , 120u8 , 138u8 , 50u8 ,]) } # [doc = " --- DMAP ( netuid ) --> trust"] pub fn trust_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: trust :: Trust , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "Trust" , () , [124u8 , 193u8 , 206u8 , 175u8 , 93u8 , 13u8 , 212u8 , 40u8 , 57u8 , 119u8 , 182u8 , 240u8 , 115u8 , 122u8 , 158u8 , 206u8 , 213u8 , 0u8 , 131u8 , 182u8 , 129u8 , 81u8 , 116u8 , 120u8 , 79u8 , 234u8 , 216u8 , 157u8 , 32u8 , 10u8 , 190u8 , 76u8 ,]) } # [doc = " --- DMAP ( netuid ) --> trust"] pub fn trust (& self , _0 : impl :: core :: borrow :: Borrow < types :: trust :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: trust :: Param0 > , types :: trust :: Trust , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "Trust" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [124u8 , 193u8 , 206u8 , 175u8 , 93u8 , 13u8 , 212u8 , 40u8 , 57u8 , 119u8 , 182u8 , 240u8 , 115u8 , 122u8 , 158u8 , 206u8 , 213u8 , 0u8 , 131u8 , 182u8 , 129u8 , 81u8 , 116u8 , 120u8 , 79u8 , 234u8 , 216u8 , 157u8 , 32u8 , 10u8 , 190u8 , 76u8 ,]) } # [doc = " --- DMAP ( netuid ) --> consensus"] pub fn consensus_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: consensus :: Consensus , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "Consensus" , () , [93u8 , 54u8 , 160u8 , 28u8 , 186u8 , 64u8 , 70u8 , 52u8 , 248u8 , 65u8 , 214u8 , 233u8 , 206u8 , 104u8 , 178u8 , 232u8 , 241u8 , 242u8 , 206u8 , 207u8 , 247u8 , 43u8 , 4u8 , 120u8 , 97u8 , 48u8 , 148u8 , 9u8 , 223u8 , 240u8 , 172u8 , 147u8 ,]) } # [doc = " --- DMAP ( netuid ) --> consensus"] pub fn consensus (& self , _0 : impl :: core :: borrow :: Borrow < types :: consensus :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: consensus :: Param0 > , types :: consensus :: Consensus , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "Consensus" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [93u8 , 54u8 , 160u8 , 28u8 , 186u8 , 64u8 , 70u8 , 52u8 , 248u8 , 65u8 , 214u8 , 233u8 , 206u8 , 104u8 , 178u8 , 232u8 , 241u8 , 242u8 , 206u8 , 207u8 , 247u8 , 43u8 , 4u8 , 120u8 , 97u8 , 48u8 , 148u8 , 9u8 , 223u8 , 240u8 , 172u8 , 147u8 ,]) } # [doc = " --- DMAP ( netuid ) --> incentive"] pub fn incentive_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: incentive :: Incentive , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "Incentive" , () , [24u8 , 160u8 , 83u8 , 255u8 , 196u8 , 69u8 , 170u8 , 68u8 , 16u8 , 239u8 , 220u8 , 198u8 , 137u8 , 89u8 , 222u8 , 247u8 , 198u8 , 16u8 , 120u8 , 147u8 , 63u8 , 186u8 , 113u8 , 137u8 , 106u8 , 143u8 , 254u8 , 211u8 , 205u8 , 217u8 , 232u8 , 64u8 ,]) } # [doc = " --- DMAP ( netuid ) --> incentive"] pub fn incentive (& self , _0 : impl :: core :: borrow :: Borrow < types :: incentive :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: incentive :: Param0 > , types :: incentive :: Incentive , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "Incentive" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [24u8 , 160u8 , 83u8 , 255u8 , 196u8 , 69u8 , 170u8 , 68u8 , 16u8 , 239u8 , 220u8 , 198u8 , 137u8 , 89u8 , 222u8 , 247u8 , 198u8 , 16u8 , 120u8 , 147u8 , 63u8 , 186u8 , 113u8 , 137u8 , 106u8 , 143u8 , 254u8 , 211u8 , 205u8 , 217u8 , 232u8 , 64u8 ,]) } # [doc = " --- DMAP ( netuid ) --> dividends"] pub fn dividends_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: dividends :: Dividends , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "Dividends" , () , [192u8 , 174u8 , 115u8 , 10u8 , 78u8 , 219u8 , 26u8 , 255u8 , 247u8 , 93u8 , 212u8 , 176u8 , 96u8 , 104u8 , 218u8 , 130u8 , 200u8 , 16u8 , 119u8 , 7u8 , 184u8 , 207u8 , 12u8 , 210u8 , 128u8 , 46u8 , 252u8 , 79u8 , 236u8 , 44u8 , 148u8 , 171u8 ,]) } # [doc = " --- DMAP ( netuid ) --> dividends"] pub fn dividends (& self , _0 : impl :: core :: borrow :: Borrow < types :: dividends :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: dividends :: Param0 > , types :: dividends :: Dividends , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "Dividends" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [192u8 , 174u8 , 115u8 , 10u8 , 78u8 , 219u8 , 26u8 , 255u8 , 247u8 , 93u8 , 212u8 , 176u8 , 96u8 , 104u8 , 218u8 , 130u8 , 200u8 , 16u8 , 119u8 , 7u8 , 184u8 , 207u8 , 12u8 , 210u8 , 128u8 , 46u8 , 252u8 , 79u8 , 236u8 , 44u8 , 148u8 , 171u8 ,]) } # [doc = " --- DMAP ( netuid ) --> emission"] pub fn emission_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: emission :: Emission , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "Emission" , () , [35u8 , 81u8 , 81u8 , 182u8 , 207u8 , 133u8 , 177u8 , 90u8 , 159u8 , 99u8 , 40u8 , 204u8 , 179u8 , 79u8 , 71u8 , 168u8 , 58u8 , 69u8 , 10u8 , 162u8 , 249u8 , 105u8 , 180u8 , 223u8 , 14u8 , 143u8 , 1u8 , 154u8 , 68u8 , 91u8 , 184u8 , 65u8 ,]) } # [doc = " --- DMAP ( netuid ) --> emission"] pub fn emission (& self , _0 : impl :: core :: borrow :: Borrow < types :: emission :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: emission :: Param0 > , types :: emission :: Emission , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "Emission" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [35u8 , 81u8 , 81u8 , 182u8 , 207u8 , 133u8 , 177u8 , 90u8 , 159u8 , 99u8 , 40u8 , 204u8 , 179u8 , 79u8 , 71u8 , 168u8 , 58u8 , 69u8 , 10u8 , 162u8 , 249u8 , 105u8 , 180u8 , 223u8 , 14u8 , 143u8 , 1u8 , 154u8 , 68u8 , 91u8 , 184u8 , 65u8 ,]) } # [doc = " --- DMAP ( netuid ) --> last_update"] pub fn last_update_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: last_update :: LastUpdate , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "LastUpdate" , () , [165u8 , 55u8 , 107u8 , 0u8 , 155u8 , 221u8 , 102u8 , 151u8 , 146u8 , 66u8 , 253u8 , 253u8 , 42u8 , 191u8 , 192u8 , 2u8 , 154u8 , 217u8 , 200u8 , 178u8 , 10u8 , 252u8 , 240u8 , 68u8 , 69u8 , 104u8 , 77u8 , 121u8 , 197u8 , 114u8 , 248u8 , 105u8 ,]) } # [doc = " --- DMAP ( netuid ) --> last_update"] pub fn last_update (& self , _0 : impl :: core :: borrow :: Borrow < types :: last_update :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: last_update :: Param0 > , types :: last_update :: LastUpdate , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "LastUpdate" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [165u8 , 55u8 , 107u8 , 0u8 , 155u8 , 221u8 , 102u8 , 151u8 , 146u8 , 66u8 , 253u8 , 253u8 , 42u8 , 191u8 , 192u8 , 2u8 , 154u8 , 217u8 , 200u8 , 178u8 , 10u8 , 252u8 , 240u8 , 68u8 , 69u8 , 104u8 , 77u8 , 121u8 , 197u8 , 114u8 , 248u8 , 105u8 ,]) } # [doc = " --- DMAP ( netuid ) --> validator_trust"] pub fn validator_trust_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: validator_trust :: ValidatorTrust , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "ValidatorTrust" , () , [23u8 , 132u8 , 192u8 , 102u8 , 41u8 , 24u8 , 238u8 , 124u8 , 6u8 , 70u8 , 199u8 , 26u8 , 245u8 , 193u8 , 241u8 , 24u8 , 142u8 , 77u8 , 82u8 , 153u8 , 16u8 , 221u8 , 221u8 , 164u8 , 159u8 , 225u8 , 144u8 , 129u8 , 159u8 , 116u8 , 203u8 , 125u8 ,]) } # [doc = " --- DMAP ( netuid ) --> validator_trust"] pub fn validator_trust (& self , _0 : impl :: core :: borrow :: Borrow < types :: validator_trust :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: validator_trust :: Param0 > , types :: validator_trust :: ValidatorTrust , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "ValidatorTrust" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [23u8 , 132u8 , 192u8 , 102u8 , 41u8 , 24u8 , 238u8 , 124u8 , 6u8 , 70u8 , 199u8 , 26u8 , 245u8 , 193u8 , 241u8 , 24u8 , 142u8 , 77u8 , 82u8 , 153u8 , 16u8 , 221u8 , 221u8 , 164u8 , 159u8 , 225u8 , 144u8 , 129u8 , 159u8 , 116u8 , 203u8 , 125u8 ,]) } # [doc = " --- DMAP ( netuid ) --> pruning_scores"] pub fn pruning_scores_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: pruning_scores :: PruningScores , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "PruningScores" , () , [141u8 , 17u8 , 95u8 , 238u8 , 81u8 , 29u8 , 210u8 , 253u8 , 112u8 , 15u8 , 35u8 , 185u8 , 226u8 , 155u8 , 189u8 , 250u8 , 28u8 , 115u8 , 254u8 , 177u8 , 11u8 , 86u8 , 212u8 , 176u8 , 154u8 , 193u8 , 5u8 , 120u8 , 163u8 , 172u8 , 97u8 , 173u8 ,]) } # [doc = " --- DMAP ( netuid ) --> pruning_scores"] pub fn pruning_scores (& self , _0 : impl :: core :: borrow :: Borrow < types :: pruning_scores :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: pruning_scores :: Param0 > , types :: pruning_scores :: PruningScores , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "PruningScores" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [141u8 , 17u8 , 95u8 , 238u8 , 81u8 , 29u8 , 210u8 , 253u8 , 112u8 , 15u8 , 35u8 , 185u8 , 226u8 , 155u8 , 189u8 , 250u8 , 28u8 , 115u8 , 254u8 , 177u8 , 11u8 , 86u8 , 212u8 , 176u8 , 154u8 , 193u8 , 5u8 , 120u8 , 163u8 , 172u8 , 97u8 , 173u8 ,]) } # [doc = " --- DMAP ( netuid ) --> validator_permit"] pub fn validator_permit_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: validator_permit :: ValidatorPermit , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "ValidatorPermit" , () , [237u8 , 135u8 , 31u8 , 115u8 , 236u8 , 108u8 , 3u8 , 83u8 , 142u8 , 232u8 , 250u8 , 100u8 , 140u8 , 89u8 , 128u8 , 24u8 , 85u8 , 68u8 , 214u8 , 111u8 , 152u8 , 203u8 , 105u8 , 6u8 , 38u8 , 154u8 , 124u8 , 176u8 , 119u8 , 181u8 , 246u8 , 169u8 ,]) } # [doc = " --- DMAP ( netuid ) --> validator_permit"] pub fn validator_permit (& self , _0 : impl :: core :: borrow :: Borrow < types :: validator_permit :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: validator_permit :: Param0 > , types :: validator_permit :: ValidatorPermit , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "ValidatorPermit" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [237u8 , 135u8 , 31u8 , 115u8 , 236u8 , 108u8 , 3u8 , 83u8 , 142u8 , 232u8 , 250u8 , 100u8 , 140u8 , 89u8 , 128u8 , 24u8 , 85u8 , 68u8 , 214u8 , 111u8 , 152u8 , 203u8 , 105u8 , 6u8 , 38u8 , 154u8 , 124u8 , 176u8 , 119u8 , 181u8 , 246u8 , 169u8 ,]) } # [doc = " --- DMAP ( netuid, uid ) --> weights"] pub fn weights_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: weights :: Weights , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "Weights" , () , [33u8 , 30u8 , 129u8 , 94u8 , 20u8 , 105u8 , 255u8 , 240u8 , 125u8 , 124u8 , 139u8 , 22u8 , 163u8 , 227u8 , 39u8 , 55u8 , 220u8 , 33u8 , 130u8 , 250u8 , 42u8 , 61u8 , 200u8 , 244u8 , 125u8 , 63u8 , 228u8 , 35u8 , 183u8 , 43u8 , 7u8 , 184u8 ,]) } # [doc = " --- DMAP ( netuid, uid ) --> weights"] pub fn weights_iter1 (& self , _0 : impl :: core :: borrow :: Borrow < types :: weights :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: weights :: Param0 > , types :: weights :: Weights , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "Weights" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [33u8 , 30u8 , 129u8 , 94u8 , 20u8 , 105u8 , 255u8 , 240u8 , 125u8 , 124u8 , 139u8 , 22u8 , 163u8 , 227u8 , 39u8 , 55u8 , 220u8 , 33u8 , 130u8 , 250u8 , 42u8 , 61u8 , 200u8 , 244u8 , 125u8 , 63u8 , 228u8 , 35u8 , 183u8 , 43u8 , 7u8 , 184u8 ,]) } # [doc = " --- DMAP ( netuid, uid ) --> weights"] pub fn weights (& self , _0 : impl :: core :: borrow :: Borrow < types :: weights :: Param0 > , _1 : impl :: core :: borrow :: Borrow < types :: weights :: Param1 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < (:: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: weights :: Param0 > , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: weights :: Param1 > ,) , types :: weights :: Weights , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "Weights" , (:: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_1 . borrow ()) ,) , [33u8 , 30u8 , 129u8 , 94u8 , 20u8 , 105u8 , 255u8 , 240u8 , 125u8 , 124u8 , 139u8 , 22u8 , 163u8 , 227u8 , 39u8 , 55u8 , 220u8 , 33u8 , 130u8 , 250u8 , 42u8 , 61u8 , 200u8 , 244u8 , 125u8 , 63u8 , 228u8 , 35u8 , 183u8 , 43u8 , 7u8 , 184u8 ,]) } # [doc = " --- DMAP ( netuid, uid ) --> bonds"] pub fn bonds_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: bonds :: Bonds , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "Bonds" , () , [11u8 , 36u8 , 139u8 , 245u8 , 90u8 , 20u8 , 111u8 , 189u8 , 60u8 , 65u8 , 247u8 , 126u8 , 209u8 , 110u8 , 104u8 , 140u8 , 171u8 , 248u8 , 40u8 , 94u8 , 193u8 , 61u8 , 129u8 , 130u8 , 128u8 , 114u8 , 60u8 , 60u8 , 231u8 , 227u8 , 223u8 , 202u8 ,]) } # [doc = " --- DMAP ( netuid, uid ) --> bonds"] pub fn bonds_iter1 (& self , _0 : impl :: core :: borrow :: Borrow < types :: bonds :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: bonds :: Param0 > , types :: bonds :: Bonds , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "Bonds" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [11u8 , 36u8 , 139u8 , 245u8 , 90u8 , 20u8 , 111u8 , 189u8 , 60u8 , 65u8 , 247u8 , 126u8 , 209u8 , 110u8 , 104u8 , 140u8 , 171u8 , 248u8 , 40u8 , 94u8 , 193u8 , 61u8 , 129u8 , 130u8 , 128u8 , 114u8 , 60u8 , 60u8 , 231u8 , 227u8 , 223u8 , 202u8 ,]) } # [doc = " --- DMAP ( netuid, uid ) --> bonds"] pub fn bonds (& self , _0 : impl :: core :: borrow :: Borrow < types :: bonds :: Param0 > , _1 : impl :: core :: borrow :: Borrow < types :: bonds :: Param1 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < (:: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: bonds :: Param0 > , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: bonds :: Param1 > ,) , types :: bonds :: Bonds , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "Bonds" , (:: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_1 . borrow ()) ,) , [11u8 , 36u8 , 139u8 , 245u8 , 90u8 , 20u8 , 111u8 , 189u8 , 60u8 , 65u8 , 247u8 , 126u8 , 209u8 , 110u8 , 104u8 , 140u8 , 171u8 , 248u8 , 40u8 , 94u8 , 193u8 , 61u8 , 129u8 , 130u8 , 128u8 , 114u8 , 60u8 , 60u8 , 231u8 , 227u8 , 223u8 , 202u8 ,]) } # [doc = " --- DMAP ( netuid, uid ) --> block_at_registration"] pub fn block_at_registration_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: block_at_registration :: BlockAtRegistration , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "BlockAtRegistration" , () , [25u8 , 46u8 , 139u8 , 65u8 , 206u8 , 245u8 , 13u8 , 118u8 , 40u8 , 94u8 , 35u8 , 157u8 , 161u8 , 120u8 , 219u8 , 76u8 , 172u8 , 107u8 , 237u8 , 29u8 , 213u8 , 177u8 , 196u8 , 162u8 , 129u8 , 29u8 , 81u8 , 3u8 , 123u8 , 116u8 , 1u8 , 81u8 ,]) } # [doc = " --- DMAP ( netuid, uid ) --> block_at_registration"] pub fn block_at_registration_iter1 (& self , _0 : impl :: core :: borrow :: Borrow < types :: block_at_registration :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: block_at_registration :: Param0 > , types :: block_at_registration :: BlockAtRegistration , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "BlockAtRegistration" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [25u8 , 46u8 , 139u8 , 65u8 , 206u8 , 245u8 , 13u8 , 118u8 , 40u8 , 94u8 , 35u8 , 157u8 , 161u8 , 120u8 , 219u8 , 76u8 , 172u8 , 107u8 , 237u8 , 29u8 , 213u8 , 177u8 , 196u8 , 162u8 , 129u8 , 29u8 , 81u8 , 3u8 , 123u8 , 116u8 , 1u8 , 81u8 ,]) } # [doc = " --- DMAP ( netuid, uid ) --> block_at_registration"] pub fn block_at_registration (& self , _0 : impl :: core :: borrow :: Borrow < types :: block_at_registration :: Param0 > , _1 : impl :: core :: borrow :: Borrow < types :: block_at_registration :: Param1 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < (:: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: block_at_registration :: Param0 > , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: block_at_registration :: Param1 > ,) , types :: block_at_registration :: BlockAtRegistration , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "BlockAtRegistration" , (:: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_1 . borrow ()) ,) , [25u8 , 46u8 , 139u8 , 65u8 , 206u8 , 245u8 , 13u8 , 118u8 , 40u8 , 94u8 , 35u8 , 157u8 , 161u8 , 120u8 , 219u8 , 76u8 , 172u8 , 107u8 , 237u8 , 29u8 , 213u8 , 177u8 , 196u8 , 162u8 , 129u8 , 29u8 , 81u8 , 3u8 , 123u8 , 116u8 , 1u8 , 81u8 ,]) } # [doc = " --- MAP ( netuid, hotkey ) --> axon_info"] pub fn axons_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: axons :: Axons , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "Axons" , () , [88u8 , 108u8 , 102u8 , 2u8 , 44u8 , 234u8 , 133u8 , 231u8 , 190u8 , 19u8 , 185u8 , 26u8 , 74u8 , 162u8 , 11u8 , 232u8 , 85u8 , 75u8 , 180u8 , 178u8 , 220u8 , 211u8 , 60u8 , 22u8 , 66u8 , 5u8 , 78u8 , 68u8 , 70u8 , 126u8 , 125u8 , 227u8 ,]) } # [doc = " --- MAP ( netuid, hotkey ) --> axon_info"] pub fn axons_iter1 (& self , _0 : impl :: core :: borrow :: Borrow < types :: axons :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: axons :: Param0 > , types :: axons :: Axons , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "Axons" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [88u8 , 108u8 , 102u8 , 2u8 , 44u8 , 234u8 , 133u8 , 231u8 , 190u8 , 19u8 , 185u8 , 26u8 , 74u8 , 162u8 , 11u8 , 232u8 , 85u8 , 75u8 , 180u8 , 178u8 , 220u8 , 211u8 , 60u8 , 22u8 , 66u8 , 5u8 , 78u8 , 68u8 , 70u8 , 126u8 , 125u8 , 227u8 ,]) } # [doc = " --- MAP ( netuid, hotkey ) --> axon_info"] pub fn axons (& self , _0 : impl :: core :: borrow :: Borrow < types :: axons :: Param0 > , _1 : impl :: core :: borrow :: Borrow < types :: axons :: Param1 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < (:: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: axons :: Param0 > , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: axons :: Param1 > ,) , types :: axons :: Axons , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "Axons" , (:: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_1 . borrow ()) ,) , [88u8 , 108u8 , 102u8 , 2u8 , 44u8 , 234u8 , 133u8 , 231u8 , 190u8 , 19u8 , 185u8 , 26u8 , 74u8 , 162u8 , 11u8 , 232u8 , 85u8 , 75u8 , 180u8 , 178u8 , 220u8 , 211u8 , 60u8 , 22u8 , 66u8 , 5u8 , 78u8 , 68u8 , 70u8 , 126u8 , 125u8 , 227u8 ,]) } # [doc = " --- MAP ( netuid, hotkey ) --> prometheus_info"] pub fn prometheus_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: prometheus :: Prometheus , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "Prometheus" , () , [145u8 , 192u8 , 240u8 , 31u8 , 78u8 , 238u8 , 87u8 , 30u8 , 67u8 , 43u8 , 132u8 , 227u8 , 210u8 , 241u8 , 202u8 , 63u8 , 250u8 , 32u8 , 30u8 , 209u8 , 31u8 , 97u8 , 34u8 , 68u8 , 16u8 , 192u8 , 24u8 , 16u8 , 210u8 , 252u8 , 164u8 , 80u8 ,]) } # [doc = " --- MAP ( netuid, hotkey ) --> prometheus_info"] pub fn prometheus_iter1 (& self , _0 : impl :: core :: borrow :: Borrow < types :: prometheus :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: prometheus :: Param0 > , types :: prometheus :: Prometheus , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "Prometheus" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [145u8 , 192u8 , 240u8 , 31u8 , 78u8 , 238u8 , 87u8 , 30u8 , 67u8 , 43u8 , 132u8 , 227u8 , 210u8 , 241u8 , 202u8 , 63u8 , 250u8 , 32u8 , 30u8 , 209u8 , 31u8 , 97u8 , 34u8 , 68u8 , 16u8 , 192u8 , 24u8 , 16u8 , 210u8 , 252u8 , 164u8 , 80u8 ,]) } # [doc = " --- MAP ( netuid, hotkey ) --> prometheus_info"] pub fn prometheus (& self , _0 : impl :: core :: borrow :: Borrow < types :: prometheus :: Param0 > , _1 : impl :: core :: borrow :: Borrow < types :: prometheus :: Param1 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < (:: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: prometheus :: Param0 > , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: prometheus :: Param1 > ,) , types :: prometheus :: Prometheus , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "Prometheus" , (:: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_1 . borrow ()) ,) , [145u8 , 192u8 , 240u8 , 31u8 , 78u8 , 238u8 , 87u8 , 30u8 , 67u8 , 43u8 , 132u8 , 227u8 , 210u8 , 241u8 , 202u8 , 63u8 , 250u8 , 32u8 , 30u8 , 209u8 , 31u8 , 97u8 , 34u8 , 68u8 , 16u8 , 192u8 , 24u8 , 16u8 , 210u8 , 252u8 , 164u8 , 80u8 ,]) } pub fn identities_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: identities :: Identities , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "Identities" , () , [177u8 , 48u8 , 142u8 , 156u8 , 74u8 , 78u8 , 215u8 , 51u8 , 187u8 , 158u8 , 66u8 , 107u8 , 108u8 , 238u8 , 20u8 , 146u8 , 243u8 , 179u8 , 131u8 , 255u8 , 195u8 , 140u8 , 4u8 , 247u8 , 150u8 , 74u8 , 221u8 , 180u8 , 109u8 , 12u8 , 128u8 , 82u8 ,]) } pub fn identities (& self , _0 : impl :: core :: borrow :: Borrow < types :: identities :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: identities :: Param0 > , types :: identities :: Identities , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "Identities" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [177u8 , 48u8 , 142u8 , 156u8 , 74u8 , 78u8 , 215u8 , 51u8 , 187u8 , 158u8 , 66u8 , 107u8 , 108u8 , 238u8 , 20u8 , 146u8 , 243u8 , 179u8 , 131u8 , 255u8 , 195u8 , 140u8 , 4u8 , 247u8 , 150u8 , 74u8 , 221u8 , 180u8 , 109u8 , 12u8 , 128u8 , 82u8 ,]) } pub fn subnet_identities_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: subnet_identities :: SubnetIdentities , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "SubnetIdentities" , () , [195u8 , 46u8 , 245u8 , 31u8 , 108u8 , 115u8 , 160u8 , 116u8 , 184u8 , 102u8 , 86u8 , 184u8 , 37u8 , 40u8 , 53u8 , 247u8 , 185u8 , 59u8 , 235u8 , 228u8 , 184u8 , 79u8 , 167u8 , 239u8 , 183u8 , 234u8 , 84u8 , 40u8 , 86u8 , 10u8 , 91u8 , 247u8 ,]) } pub fn subnet_identities (& self , _0 : impl :: core :: borrow :: Borrow < types :: subnet_identities :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: subnet_identities :: Param0 > , types :: subnet_identities :: SubnetIdentities , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "SubnetIdentities" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [195u8 , 46u8 , 245u8 , 31u8 , 108u8 , 115u8 , 160u8 , 116u8 , 184u8 , 102u8 , 86u8 , 184u8 , 37u8 , 40u8 , 53u8 , 247u8 , 185u8 , 59u8 , 235u8 , 228u8 , 184u8 , 79u8 , 167u8 , 239u8 , 183u8 , 234u8 , 84u8 , 40u8 , 86u8 , 10u8 , 91u8 , 247u8 ,]) } # [doc = " ================================="] # [doc = " ==== Axon / Promo Endpoints ====="] # [doc = " ================================="] pub fn transaction_key_last_block_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: transaction_key_last_block :: TransactionKeyLastBlock , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "TransactionKeyLastBlock" , () , [133u8 , 67u8 , 139u8 , 127u8 , 103u8 , 156u8 , 31u8 , 142u8 , 163u8 , 221u8 , 251u8 , 219u8 , 8u8 , 44u8 , 51u8 , 230u8 , 229u8 , 243u8 , 255u8 , 80u8 , 16u8 , 247u8 , 49u8 , 36u8 , 183u8 , 122u8 , 162u8 , 44u8 , 226u8 , 1u8 , 122u8 , 244u8 ,]) } # [doc = " ================================="] # [doc = " ==== Axon / Promo Endpoints ====="] # [doc = " ================================="] pub fn transaction_key_last_block_iter1 (& self , _0 : impl :: core :: borrow :: Borrow < types :: transaction_key_last_block :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: transaction_key_last_block :: Param0 > , types :: transaction_key_last_block :: TransactionKeyLastBlock , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "TransactionKeyLastBlock" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [133u8 , 67u8 , 139u8 , 127u8 , 103u8 , 156u8 , 31u8 , 142u8 , 163u8 , 221u8 , 251u8 , 219u8 , 8u8 , 44u8 , 51u8 , 230u8 , 229u8 , 243u8 , 255u8 , 80u8 , 16u8 , 247u8 , 49u8 , 36u8 , 183u8 , 122u8 , 162u8 , 44u8 , 226u8 , 1u8 , 122u8 , 244u8 ,]) } # [doc = " ================================="] # [doc = " ==== Axon / Promo Endpoints ====="] # [doc = " ================================="] pub fn transaction_key_last_block_iter2 (& self , _0 : impl :: core :: borrow :: Borrow < types :: transaction_key_last_block :: Param0 > , _1 : impl :: core :: borrow :: Borrow < types :: transaction_key_last_block :: Param1 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < (:: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: transaction_key_last_block :: Param0 > , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: transaction_key_last_block :: Param1 > ,) , types :: transaction_key_last_block :: TransactionKeyLastBlock , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "TransactionKeyLastBlock" , (:: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_1 . borrow ()) ,) , [133u8 , 67u8 , 139u8 , 127u8 , 103u8 , 156u8 , 31u8 , 142u8 , 163u8 , 221u8 , 251u8 , 219u8 , 8u8 , 44u8 , 51u8 , 230u8 , 229u8 , 243u8 , 255u8 , 80u8 , 16u8 , 247u8 , 49u8 , 36u8 , 183u8 , 122u8 , 162u8 , 44u8 , 226u8 , 1u8 , 122u8 , 244u8 ,]) } # [doc = " ================================="] # [doc = " ==== Axon / Promo Endpoints ====="] # [doc = " ================================="] pub fn transaction_key_last_block (& self , _0 : impl :: core :: borrow :: Borrow < types :: transaction_key_last_block :: Param0 > , _1 : impl :: core :: borrow :: Borrow < types :: transaction_key_last_block :: Param1 > , _2 : impl :: core :: borrow :: Borrow < types :: transaction_key_last_block :: Param2 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < (:: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: transaction_key_last_block :: Param0 > , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: transaction_key_last_block :: Param1 > , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: transaction_key_last_block :: Param2 > ,) , types :: transaction_key_last_block :: TransactionKeyLastBlock , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "TransactionKeyLastBlock" , (:: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_1 . borrow ()) , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_2 . borrow ()) ,) , [133u8 , 67u8 , 139u8 , 127u8 , 103u8 , 156u8 , 31u8 , 142u8 , 163u8 , 221u8 , 251u8 , 219u8 , 8u8 , 44u8 , 51u8 , 230u8 , 229u8 , 243u8 , 255u8 , 80u8 , 16u8 , 247u8 , 49u8 , 36u8 , 183u8 , 122u8 , 162u8 , 44u8 , 226u8 , 1u8 , 122u8 , 244u8 ,]) } # [doc = " --- MAP ( key ) --> last_block"] pub fn last_tx_block_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: last_tx_block :: LastTxBlock , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "LastTxBlock" , () , [110u8 , 36u8 , 249u8 , 1u8 , 181u8 , 193u8 , 146u8 , 153u8 , 25u8 , 162u8 , 230u8 , 16u8 , 223u8 , 176u8 , 189u8 , 253u8 , 109u8 , 101u8 , 151u8 , 63u8 , 199u8 , 191u8 , 114u8 , 38u8 , 207u8 , 186u8 , 96u8 , 46u8 , 45u8 , 87u8 , 182u8 , 177u8 ,]) } # [doc = " --- MAP ( key ) --> last_block"] pub fn last_tx_block (& self , _0 : impl :: core :: borrow :: Borrow < types :: last_tx_block :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: last_tx_block :: Param0 > , types :: last_tx_block :: LastTxBlock , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "LastTxBlock" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [110u8 , 36u8 , 249u8 , 1u8 , 181u8 , 193u8 , 146u8 , 153u8 , 25u8 , 162u8 , 230u8 , 16u8 , 223u8 , 176u8 , 189u8 , 253u8 , 109u8 , 101u8 , 151u8 , 63u8 , 199u8 , 191u8 , 114u8 , 38u8 , 207u8 , 186u8 , 96u8 , 46u8 , 45u8 , 87u8 , 182u8 , 177u8 ,]) } # [doc = " --- MAP ( key ) --> last_tx_block_childkey_take"] pub fn last_tx_block_child_key_take_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: last_tx_block_child_key_take :: LastTxBlockChildKeyTake , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "LastTxBlockChildKeyTake" , () , [235u8 , 75u8 , 165u8 , 153u8 , 97u8 , 11u8 , 159u8 , 51u8 , 229u8 , 39u8 , 75u8 , 75u8 , 178u8 , 71u8 , 31u8 , 124u8 , 159u8 , 107u8 , 250u8 , 58u8 , 165u8 , 87u8 , 10u8 , 233u8 , 253u8 , 200u8 , 206u8 , 158u8 , 75u8 , 150u8 , 199u8 , 228u8 ,]) } # [doc = " --- MAP ( key ) --> last_tx_block_childkey_take"] pub fn last_tx_block_child_key_take (& self , _0 : impl :: core :: borrow :: Borrow < types :: last_tx_block_child_key_take :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: last_tx_block_child_key_take :: Param0 > , types :: last_tx_block_child_key_take :: LastTxBlockChildKeyTake , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "LastTxBlockChildKeyTake" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [235u8 , 75u8 , 165u8 , 153u8 , 97u8 , 11u8 , 159u8 , 51u8 , 229u8 , 39u8 , 75u8 , 75u8 , 178u8 , 71u8 , 31u8 , 124u8 , 159u8 , 107u8 , 250u8 , 58u8 , 165u8 , 87u8 , 10u8 , 233u8 , 253u8 , 200u8 , 206u8 , 158u8 , 75u8 , 150u8 , 199u8 , 228u8 ,]) } # [doc = " --- MAP ( key ) --> last_tx_block_delegate_take"] pub fn last_tx_block_delegate_take_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: last_tx_block_delegate_take :: LastTxBlockDelegateTake , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "LastTxBlockDelegateTake" , () , [12u8 , 222u8 , 74u8 , 237u8 , 136u8 , 118u8 , 12u8 , 175u8 , 121u8 , 238u8 , 132u8 , 170u8 , 227u8 , 140u8 , 109u8 , 218u8 , 3u8 , 133u8 , 250u8 , 125u8 , 141u8 , 211u8 , 45u8 , 120u8 , 22u8 , 94u8 , 166u8 , 100u8 , 104u8 , 51u8 , 65u8 , 252u8 ,]) } # [doc = " --- MAP ( key ) --> last_tx_block_delegate_take"] pub fn last_tx_block_delegate_take (& self , _0 : impl :: core :: borrow :: Borrow < types :: last_tx_block_delegate_take :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: last_tx_block_delegate_take :: Param0 > , types :: last_tx_block_delegate_take :: LastTxBlockDelegateTake , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "LastTxBlockDelegateTake" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [12u8 , 222u8 , 74u8 , 237u8 , 136u8 , 118u8 , 12u8 , 175u8 , 121u8 , 238u8 , 132u8 , 170u8 , 227u8 , 140u8 , 109u8 , 218u8 , 3u8 , 133u8 , 250u8 , 125u8 , 141u8 , 211u8 , 45u8 , 120u8 , 22u8 , 94u8 , 166u8 , 100u8 , 104u8 , 51u8 , 65u8 , 252u8 ,]) } # [doc = " ITEM( weights_min_stake )"] pub fn weights_min_stake (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: weights_min_stake :: WeightsMinStake , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "WeightsMinStake" , () , [185u8 , 88u8 , 248u8 , 249u8 , 27u8 , 130u8 , 169u8 , 2u8 , 230u8 , 157u8 , 113u8 , 64u8 , 40u8 , 178u8 , 245u8 , 112u8 , 215u8 , 237u8 , 69u8 , 109u8 , 56u8 , 241u8 , 206u8 , 139u8 , 119u8 , 59u8 , 99u8 , 212u8 , 227u8 , 55u8 , 108u8 , 183u8 ,]) } # [doc = " --- MAP (netuid, who) --> (hash, weight) | Returns the hash and weight committed by an account for a given netuid."] pub fn weight_commits_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: weight_commits :: WeightCommits , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "WeightCommits" , () , [196u8 , 143u8 , 120u8 , 205u8 , 208u8 , 151u8 , 244u8 , 141u8 , 221u8 , 18u8 , 176u8 , 180u8 , 111u8 , 61u8 , 1u8 , 213u8 , 177u8 , 32u8 , 111u8 , 143u8 , 248u8 , 173u8 , 213u8 , 105u8 , 106u8 , 239u8 , 201u8 , 194u8 , 207u8 , 106u8 , 72u8 , 89u8 ,]) } # [doc = " --- MAP (netuid, who) --> (hash, weight) | Returns the hash and weight committed by an account for a given netuid."] pub fn weight_commits_iter1 (& self , _0 : impl :: core :: borrow :: Borrow < types :: weight_commits :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: weight_commits :: Param0 > , types :: weight_commits :: WeightCommits , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "WeightCommits" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [196u8 , 143u8 , 120u8 , 205u8 , 208u8 , 151u8 , 244u8 , 141u8 , 221u8 , 18u8 , 176u8 , 180u8 , 111u8 , 61u8 , 1u8 , 213u8 , 177u8 , 32u8 , 111u8 , 143u8 , 248u8 , 173u8 , 213u8 , 105u8 , 106u8 , 239u8 , 201u8 , 194u8 , 207u8 , 106u8 , 72u8 , 89u8 ,]) } # [doc = " --- MAP (netuid, who) --> (hash, weight) | Returns the hash and weight committed by an account for a given netuid."] pub fn weight_commits (& self , _0 : impl :: core :: borrow :: Borrow < types :: weight_commits :: Param0 > , _1 : impl :: core :: borrow :: Borrow < types :: weight_commits :: Param1 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < (:: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: weight_commits :: Param0 > , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: weight_commits :: Param1 > ,) , types :: weight_commits :: WeightCommits , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "WeightCommits" , (:: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_1 . borrow ()) ,) , [196u8 , 143u8 , 120u8 , 205u8 , 208u8 , 151u8 , 244u8 , 141u8 , 221u8 , 18u8 , 176u8 , 180u8 , 111u8 , 61u8 , 1u8 , 213u8 , 177u8 , 32u8 , 111u8 , 143u8 , 248u8 , 173u8 , 213u8 , 105u8 , 106u8 , 239u8 , 201u8 , 194u8 , 207u8 , 106u8 , 72u8 , 89u8 ,]) } # [doc = " =================="] # [doc = " ==== Genesis ====="] # [doc = " =================="] pub fn has_migration_run_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: has_migration_run :: HasMigrationRun , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "HasMigrationRun" , () , [218u8 , 208u8 , 248u8 , 140u8 , 220u8 , 160u8 , 153u8 , 63u8 , 27u8 , 120u8 , 32u8 , 30u8 , 124u8 , 8u8 , 170u8 , 223u8 , 163u8 , 9u8 , 67u8 , 3u8 , 209u8 , 162u8 , 207u8 , 222u8 , 168u8 , 11u8 , 229u8 , 80u8 , 24u8 , 253u8 , 154u8 , 199u8 ,]) } # [doc = " =================="] # [doc = " ==== Genesis ====="] # [doc = " =================="] pub fn has_migration_run (& self , _0 : impl :: core :: borrow :: Borrow < types :: has_migration_run :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: has_migration_run :: Param0 > , types :: has_migration_run :: HasMigrationRun , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubtensorModule" , "HasMigrationRun" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [218u8 , 208u8 , 248u8 , 140u8 , 220u8 , 160u8 , 153u8 , 63u8 , 27u8 , 120u8 , 32u8 , 30u8 , 124u8 , 8u8 , 170u8 , 223u8 , 163u8 , 9u8 , 67u8 , 3u8 , 209u8 , 162u8 , 207u8 , 222u8 , 168u8 , 11u8 , 229u8 , 80u8 , 24u8 , 253u8 , 154u8 , 199u8 ,]) } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi ; impl ConstantsApi { # [doc = " ================================="] # [doc = " ==== Initial Value Constants ===="] # [doc = " ================================="] # [doc = " Initial currency issuance."] pub fn initial_issuance (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u64 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("SubtensorModule" , "InitialIssuance" , [128u8 , 214u8 , 205u8 , 242u8 , 181u8 , 142u8 , 124u8 , 231u8 , 190u8 , 146u8 , 59u8 , 226u8 , 157u8 , 101u8 , 103u8 , 117u8 , 249u8 , 65u8 , 18u8 , 191u8 , 103u8 , 119u8 , 53u8 , 85u8 , 81u8 , 96u8 , 220u8 , 42u8 , 184u8 , 239u8 , 42u8 , 246u8 ,]) } # [doc = " Initial min allowed weights setting."] pub fn initial_min_allowed_weights (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u16 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("SubtensorModule" , "InitialMinAllowedWeights" , [116u8 , 33u8 , 2u8 , 170u8 , 181u8 , 147u8 , 171u8 , 169u8 , 167u8 , 227u8 , 41u8 , 144u8 , 11u8 , 236u8 , 82u8 , 100u8 , 74u8 , 60u8 , 184u8 , 72u8 , 169u8 , 90u8 , 208u8 , 135u8 , 15u8 , 117u8 , 10u8 , 123u8 , 128u8 , 193u8 , 29u8 , 70u8 ,]) } # [doc = " Initial Emission Ratio."] pub fn initial_emission_value (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u16 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("SubtensorModule" , "InitialEmissionValue" , [116u8 , 33u8 , 2u8 , 170u8 , 181u8 , 147u8 , 171u8 , 169u8 , 167u8 , 227u8 , 41u8 , 144u8 , 11u8 , 236u8 , 82u8 , 100u8 , 74u8 , 60u8 , 184u8 , 72u8 , 169u8 , 90u8 , 208u8 , 135u8 , 15u8 , 117u8 , 10u8 , 123u8 , 128u8 , 193u8 , 29u8 , 70u8 ,]) } # [doc = " Initial max weight limit."] pub fn initial_max_weights_limit (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u16 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("SubtensorModule" , "InitialMaxWeightsLimit" , [116u8 , 33u8 , 2u8 , 170u8 , 181u8 , 147u8 , 171u8 , 169u8 , 167u8 , 227u8 , 41u8 , 144u8 , 11u8 , 236u8 , 82u8 , 100u8 , 74u8 , 60u8 , 184u8 , 72u8 , 169u8 , 90u8 , 208u8 , 135u8 , 15u8 , 117u8 , 10u8 , 123u8 , 128u8 , 193u8 , 29u8 , 70u8 ,]) } # [doc = " Tempo for each network."] pub fn initial_tempo (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u16 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("SubtensorModule" , "InitialTempo" , [116u8 , 33u8 , 2u8 , 170u8 , 181u8 , 147u8 , 171u8 , 169u8 , 167u8 , 227u8 , 41u8 , 144u8 , 11u8 , 236u8 , 82u8 , 100u8 , 74u8 , 60u8 , 184u8 , 72u8 , 169u8 , 90u8 , 208u8 , 135u8 , 15u8 , 117u8 , 10u8 , 123u8 , 128u8 , 193u8 , 29u8 , 70u8 ,]) } # [doc = " Initial Difficulty."] pub fn initial_difficulty (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u64 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("SubtensorModule" , "InitialDifficulty" , [128u8 , 214u8 , 205u8 , 242u8 , 181u8 , 142u8 , 124u8 , 231u8 , 190u8 , 146u8 , 59u8 , 226u8 , 157u8 , 101u8 , 103u8 , 117u8 , 249u8 , 65u8 , 18u8 , 191u8 , 103u8 , 119u8 , 53u8 , 85u8 , 81u8 , 96u8 , 220u8 , 42u8 , 184u8 , 239u8 , 42u8 , 246u8 ,]) } # [doc = " Initial Max Difficulty."] pub fn initial_max_difficulty (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u64 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("SubtensorModule" , "InitialMaxDifficulty" , [128u8 , 214u8 , 205u8 , 242u8 , 181u8 , 142u8 , 124u8 , 231u8 , 190u8 , 146u8 , 59u8 , 226u8 , 157u8 , 101u8 , 103u8 , 117u8 , 249u8 , 65u8 , 18u8 , 191u8 , 103u8 , 119u8 , 53u8 , 85u8 , 81u8 , 96u8 , 220u8 , 42u8 , 184u8 , 239u8 , 42u8 , 246u8 ,]) } # [doc = " Initial Min Difficulty."] pub fn initial_min_difficulty (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u64 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("SubtensorModule" , "InitialMinDifficulty" , [128u8 , 214u8 , 205u8 , 242u8 , 181u8 , 142u8 , 124u8 , 231u8 , 190u8 , 146u8 , 59u8 , 226u8 , 157u8 , 101u8 , 103u8 , 117u8 , 249u8 , 65u8 , 18u8 , 191u8 , 103u8 , 119u8 , 53u8 , 85u8 , 81u8 , 96u8 , 220u8 , 42u8 , 184u8 , 239u8 , 42u8 , 246u8 ,]) } # [doc = " Initial RAO Recycled."] pub fn initial_rao_recycled_for_registration (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u64 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("SubtensorModule" , "InitialRAORecycledForRegistration" , [128u8 , 214u8 , 205u8 , 242u8 , 181u8 , 142u8 , 124u8 , 231u8 , 190u8 , 146u8 , 59u8 , 226u8 , 157u8 , 101u8 , 103u8 , 117u8 , 249u8 , 65u8 , 18u8 , 191u8 , 103u8 , 119u8 , 53u8 , 85u8 , 81u8 , 96u8 , 220u8 , 42u8 , 184u8 , 239u8 , 42u8 , 246u8 ,]) } # [doc = " Initial Burn."] pub fn initial_burn (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u64 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("SubtensorModule" , "InitialBurn" , [128u8 , 214u8 , 205u8 , 242u8 , 181u8 , 142u8 , 124u8 , 231u8 , 190u8 , 146u8 , 59u8 , 226u8 , 157u8 , 101u8 , 103u8 , 117u8 , 249u8 , 65u8 , 18u8 , 191u8 , 103u8 , 119u8 , 53u8 , 85u8 , 81u8 , 96u8 , 220u8 , 42u8 , 184u8 , 239u8 , 42u8 , 246u8 ,]) } # [doc = " Initial Max Burn."] pub fn initial_max_burn (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u64 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("SubtensorModule" , "InitialMaxBurn" , [128u8 , 214u8 , 205u8 , 242u8 , 181u8 , 142u8 , 124u8 , 231u8 , 190u8 , 146u8 , 59u8 , 226u8 , 157u8 , 101u8 , 103u8 , 117u8 , 249u8 , 65u8 , 18u8 , 191u8 , 103u8 , 119u8 , 53u8 , 85u8 , 81u8 , 96u8 , 220u8 , 42u8 , 184u8 , 239u8 , 42u8 , 246u8 ,]) } # [doc = " Initial Min Burn."] pub fn initial_min_burn (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u64 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("SubtensorModule" , "InitialMinBurn" , [128u8 , 214u8 , 205u8 , 242u8 , 181u8 , 142u8 , 124u8 , 231u8 , 190u8 , 146u8 , 59u8 , 226u8 , 157u8 , 101u8 , 103u8 , 117u8 , 249u8 , 65u8 , 18u8 , 191u8 , 103u8 , 119u8 , 53u8 , 85u8 , 81u8 , 96u8 , 220u8 , 42u8 , 184u8 , 239u8 , 42u8 , 246u8 ,]) } # [doc = " Initial adjustment interval."] pub fn initial_adjustment_interval (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u16 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("SubtensorModule" , "InitialAdjustmentInterval" , [116u8 , 33u8 , 2u8 , 170u8 , 181u8 , 147u8 , 171u8 , 169u8 , 167u8 , 227u8 , 41u8 , 144u8 , 11u8 , 236u8 , 82u8 , 100u8 , 74u8 , 60u8 , 184u8 , 72u8 , 169u8 , 90u8 , 208u8 , 135u8 , 15u8 , 117u8 , 10u8 , 123u8 , 128u8 , 193u8 , 29u8 , 70u8 ,]) } # [doc = " Initial bonds moving average."] pub fn initial_bonds_moving_average (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u64 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("SubtensorModule" , "InitialBondsMovingAverage" , [128u8 , 214u8 , 205u8 , 242u8 , 181u8 , 142u8 , 124u8 , 231u8 , 190u8 , 146u8 , 59u8 , 226u8 , 157u8 , 101u8 , 103u8 , 117u8 , 249u8 , 65u8 , 18u8 , 191u8 , 103u8 , 119u8 , 53u8 , 85u8 , 81u8 , 96u8 , 220u8 , 42u8 , 184u8 , 239u8 , 42u8 , 246u8 ,]) } # [doc = " Initial target registrations per interval."] pub fn initial_target_registrations_per_interval (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u16 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("SubtensorModule" , "InitialTargetRegistrationsPerInterval" , [116u8 , 33u8 , 2u8 , 170u8 , 181u8 , 147u8 , 171u8 , 169u8 , 167u8 , 227u8 , 41u8 , 144u8 , 11u8 , 236u8 , 82u8 , 100u8 , 74u8 , 60u8 , 184u8 , 72u8 , 169u8 , 90u8 , 208u8 , 135u8 , 15u8 , 117u8 , 10u8 , 123u8 , 128u8 , 193u8 , 29u8 , 70u8 ,]) } # [doc = " Rho constant."] pub fn initial_rho (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u16 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("SubtensorModule" , "InitialRho" , [116u8 , 33u8 , 2u8 , 170u8 , 181u8 , 147u8 , 171u8 , 169u8 , 167u8 , 227u8 , 41u8 , 144u8 , 11u8 , 236u8 , 82u8 , 100u8 , 74u8 , 60u8 , 184u8 , 72u8 , 169u8 , 90u8 , 208u8 , 135u8 , 15u8 , 117u8 , 10u8 , 123u8 , 128u8 , 193u8 , 29u8 , 70u8 ,]) } # [doc = " Kappa constant."] pub fn initial_kappa (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u16 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("SubtensorModule" , "InitialKappa" , [116u8 , 33u8 , 2u8 , 170u8 , 181u8 , 147u8 , 171u8 , 169u8 , 167u8 , 227u8 , 41u8 , 144u8 , 11u8 , 236u8 , 82u8 , 100u8 , 74u8 , 60u8 , 184u8 , 72u8 , 169u8 , 90u8 , 208u8 , 135u8 , 15u8 , 117u8 , 10u8 , 123u8 , 128u8 , 193u8 , 29u8 , 70u8 ,]) } # [doc = " Max UID constant."] pub fn initial_max_allowed_uids (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u16 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("SubtensorModule" , "InitialMaxAllowedUids" , [116u8 , 33u8 , 2u8 , 170u8 , 181u8 , 147u8 , 171u8 , 169u8 , 167u8 , 227u8 , 41u8 , 144u8 , 11u8 , 236u8 , 82u8 , 100u8 , 74u8 , 60u8 , 184u8 , 72u8 , 169u8 , 90u8 , 208u8 , 135u8 , 15u8 , 117u8 , 10u8 , 123u8 , 128u8 , 193u8 , 29u8 , 70u8 ,]) } # [doc = " Initial validator context pruning length."] pub fn initial_validator_prune_len (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u64 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("SubtensorModule" , "InitialValidatorPruneLen" , [128u8 , 214u8 , 205u8 , 242u8 , 181u8 , 142u8 , 124u8 , 231u8 , 190u8 , 146u8 , 59u8 , 226u8 , 157u8 , 101u8 , 103u8 , 117u8 , 249u8 , 65u8 , 18u8 , 191u8 , 103u8 , 119u8 , 53u8 , 85u8 , 81u8 , 96u8 , 220u8 , 42u8 , 184u8 , 239u8 , 42u8 , 246u8 ,]) } # [doc = " Initial scaling law power."] pub fn initial_scaling_law_power (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u16 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("SubtensorModule" , "InitialScalingLawPower" , [116u8 , 33u8 , 2u8 , 170u8 , 181u8 , 147u8 , 171u8 , 169u8 , 167u8 , 227u8 , 41u8 , 144u8 , 11u8 , 236u8 , 82u8 , 100u8 , 74u8 , 60u8 , 184u8 , 72u8 , 169u8 , 90u8 , 208u8 , 135u8 , 15u8 , 117u8 , 10u8 , 123u8 , 128u8 , 193u8 , 29u8 , 70u8 ,]) } # [doc = " Immunity Period Constant."] pub fn initial_immunity_period (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u16 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("SubtensorModule" , "InitialImmunityPeriod" , [116u8 , 33u8 , 2u8 , 170u8 , 181u8 , 147u8 , 171u8 , 169u8 , 167u8 , 227u8 , 41u8 , 144u8 , 11u8 , 236u8 , 82u8 , 100u8 , 74u8 , 60u8 , 184u8 , 72u8 , 169u8 , 90u8 , 208u8 , 135u8 , 15u8 , 117u8 , 10u8 , 123u8 , 128u8 , 193u8 , 29u8 , 70u8 ,]) } # [doc = " Activity constant."] pub fn initial_activity_cutoff (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u16 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("SubtensorModule" , "InitialActivityCutoff" , [116u8 , 33u8 , 2u8 , 170u8 , 181u8 , 147u8 , 171u8 , 169u8 , 167u8 , 227u8 , 41u8 , 144u8 , 11u8 , 236u8 , 82u8 , 100u8 , 74u8 , 60u8 , 184u8 , 72u8 , 169u8 , 90u8 , 208u8 , 135u8 , 15u8 , 117u8 , 10u8 , 123u8 , 128u8 , 193u8 , 29u8 , 70u8 ,]) } # [doc = " Initial max registrations per block."] pub fn initial_max_registrations_per_block (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u16 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("SubtensorModule" , "InitialMaxRegistrationsPerBlock" , [116u8 , 33u8 , 2u8 , 170u8 , 181u8 , 147u8 , 171u8 , 169u8 , 167u8 , 227u8 , 41u8 , 144u8 , 11u8 , 236u8 , 82u8 , 100u8 , 74u8 , 60u8 , 184u8 , 72u8 , 169u8 , 90u8 , 208u8 , 135u8 , 15u8 , 117u8 , 10u8 , 123u8 , 128u8 , 193u8 , 29u8 , 70u8 ,]) } # [doc = " Initial pruning score for each neuron."] pub fn initial_pruning_score (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u16 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("SubtensorModule" , "InitialPruningScore" , [116u8 , 33u8 , 2u8 , 170u8 , 181u8 , 147u8 , 171u8 , 169u8 , 167u8 , 227u8 , 41u8 , 144u8 , 11u8 , 236u8 , 82u8 , 100u8 , 74u8 , 60u8 , 184u8 , 72u8 , 169u8 , 90u8 , 208u8 , 135u8 , 15u8 , 117u8 , 10u8 , 123u8 , 128u8 , 193u8 , 29u8 , 70u8 ,]) } # [doc = " Initial maximum allowed validators per network."] pub fn initial_max_allowed_validators (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u16 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("SubtensorModule" , "InitialMaxAllowedValidators" , [116u8 , 33u8 , 2u8 , 170u8 , 181u8 , 147u8 , 171u8 , 169u8 , 167u8 , 227u8 , 41u8 , 144u8 , 11u8 , 236u8 , 82u8 , 100u8 , 74u8 , 60u8 , 184u8 , 72u8 , 169u8 , 90u8 , 208u8 , 135u8 , 15u8 , 117u8 , 10u8 , 123u8 , 128u8 , 193u8 , 29u8 , 70u8 ,]) } # [doc = " Initial default delegation take."] pub fn initial_default_delegate_take (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u16 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("SubtensorModule" , "InitialDefaultDelegateTake" , [116u8 , 33u8 , 2u8 , 170u8 , 181u8 , 147u8 , 171u8 , 169u8 , 167u8 , 227u8 , 41u8 , 144u8 , 11u8 , 236u8 , 82u8 , 100u8 , 74u8 , 60u8 , 184u8 , 72u8 , 169u8 , 90u8 , 208u8 , 135u8 , 15u8 , 117u8 , 10u8 , 123u8 , 128u8 , 193u8 , 29u8 , 70u8 ,]) } # [doc = " Initial minimum delegation take."] pub fn initial_min_delegate_take (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u16 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("SubtensorModule" , "InitialMinDelegateTake" , [116u8 , 33u8 , 2u8 , 170u8 , 181u8 , 147u8 , 171u8 , 169u8 , 167u8 , 227u8 , 41u8 , 144u8 , 11u8 , 236u8 , 82u8 , 100u8 , 74u8 , 60u8 , 184u8 , 72u8 , 169u8 , 90u8 , 208u8 , 135u8 , 15u8 , 117u8 , 10u8 , 123u8 , 128u8 , 193u8 , 29u8 , 70u8 ,]) } # [doc = " Initial default childkey take."] pub fn initial_default_child_key_take (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u16 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("SubtensorModule" , "InitialDefaultChildKeyTake" , [116u8 , 33u8 , 2u8 , 170u8 , 181u8 , 147u8 , 171u8 , 169u8 , 167u8 , 227u8 , 41u8 , 144u8 , 11u8 , 236u8 , 82u8 , 100u8 , 74u8 , 60u8 , 184u8 , 72u8 , 169u8 , 90u8 , 208u8 , 135u8 , 15u8 , 117u8 , 10u8 , 123u8 , 128u8 , 193u8 , 29u8 , 70u8 ,]) } # [doc = " Initial minimum childkey take."] pub fn initial_min_child_key_take (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u16 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("SubtensorModule" , "InitialMinChildKeyTake" , [116u8 , 33u8 , 2u8 , 170u8 , 181u8 , 147u8 , 171u8 , 169u8 , 167u8 , 227u8 , 41u8 , 144u8 , 11u8 , 236u8 , 82u8 , 100u8 , 74u8 , 60u8 , 184u8 , 72u8 , 169u8 , 90u8 , 208u8 , 135u8 , 15u8 , 117u8 , 10u8 , 123u8 , 128u8 , 193u8 , 29u8 , 70u8 ,]) } # [doc = " Initial maximum childkey take."] pub fn initial_max_child_key_take (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u16 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("SubtensorModule" , "InitialMaxChildKeyTake" , [116u8 , 33u8 , 2u8 , 170u8 , 181u8 , 147u8 , 171u8 , 169u8 , 167u8 , 227u8 , 41u8 , 144u8 , 11u8 , 236u8 , 82u8 , 100u8 , 74u8 , 60u8 , 184u8 , 72u8 , 169u8 , 90u8 , 208u8 , 135u8 , 15u8 , 117u8 , 10u8 , 123u8 , 128u8 , 193u8 , 29u8 , 70u8 ,]) } # [doc = " Initial weights version key."] pub fn initial_weights_version_key (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u64 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("SubtensorModule" , "InitialWeightsVersionKey" , [128u8 , 214u8 , 205u8 , 242u8 , 181u8 , 142u8 , 124u8 , 231u8 , 190u8 , 146u8 , 59u8 , 226u8 , 157u8 , 101u8 , 103u8 , 117u8 , 249u8 , 65u8 , 18u8 , 191u8 , 103u8 , 119u8 , 53u8 , 85u8 , 81u8 , 96u8 , 220u8 , 42u8 , 184u8 , 239u8 , 42u8 , 246u8 ,]) } # [doc = " Initial serving rate limit."] pub fn initial_serving_rate_limit (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u64 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("SubtensorModule" , "InitialServingRateLimit" , [128u8 , 214u8 , 205u8 , 242u8 , 181u8 , 142u8 , 124u8 , 231u8 , 190u8 , 146u8 , 59u8 , 226u8 , 157u8 , 101u8 , 103u8 , 117u8 , 249u8 , 65u8 , 18u8 , 191u8 , 103u8 , 119u8 , 53u8 , 85u8 , 81u8 , 96u8 , 220u8 , 42u8 , 184u8 , 239u8 , 42u8 , 246u8 ,]) } # [doc = " Initial transaction rate limit."] pub fn initial_tx_rate_limit (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u64 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("SubtensorModule" , "InitialTxRateLimit" , [128u8 , 214u8 , 205u8 , 242u8 , 181u8 , 142u8 , 124u8 , 231u8 , 190u8 , 146u8 , 59u8 , 226u8 , 157u8 , 101u8 , 103u8 , 117u8 , 249u8 , 65u8 , 18u8 , 191u8 , 103u8 , 119u8 , 53u8 , 85u8 , 81u8 , 96u8 , 220u8 , 42u8 , 184u8 , 239u8 , 42u8 , 246u8 ,]) } # [doc = " Initial delegate take transaction rate limit."] pub fn initial_tx_delegate_take_rate_limit (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u64 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("SubtensorModule" , "InitialTxDelegateTakeRateLimit" , [128u8 , 214u8 , 205u8 , 242u8 , 181u8 , 142u8 , 124u8 , 231u8 , 190u8 , 146u8 , 59u8 , 226u8 , 157u8 , 101u8 , 103u8 , 117u8 , 249u8 , 65u8 , 18u8 , 191u8 , 103u8 , 119u8 , 53u8 , 85u8 , 81u8 , 96u8 , 220u8 , 42u8 , 184u8 , 239u8 , 42u8 , 246u8 ,]) } # [doc = " Initial childkey take transaction rate limit."] pub fn initial_tx_child_key_take_rate_limit (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u64 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("SubtensorModule" , "InitialTxChildKeyTakeRateLimit" , [128u8 , 214u8 , 205u8 , 242u8 , 181u8 , 142u8 , 124u8 , 231u8 , 190u8 , 146u8 , 59u8 , 226u8 , 157u8 , 101u8 , 103u8 , 117u8 , 249u8 , 65u8 , 18u8 , 191u8 , 103u8 , 119u8 , 53u8 , 85u8 , 81u8 , 96u8 , 220u8 , 42u8 , 184u8 , 239u8 , 42u8 , 246u8 ,]) } # [doc = " Initial percentage of total stake required to join senate."] pub fn initial_senate_required_stake_percentage (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u64 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("SubtensorModule" , "InitialSenateRequiredStakePercentage" , [128u8 , 214u8 , 205u8 , 242u8 , 181u8 , 142u8 , 124u8 , 231u8 , 190u8 , 146u8 , 59u8 , 226u8 , 157u8 , 101u8 , 103u8 , 117u8 , 249u8 , 65u8 , 18u8 , 191u8 , 103u8 , 119u8 , 53u8 , 85u8 , 81u8 , 96u8 , 220u8 , 42u8 , 184u8 , 239u8 , 42u8 , 246u8 ,]) } # [doc = " Initial adjustment alpha on burn and pow."] pub fn initial_adjustment_alpha (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u64 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("SubtensorModule" , "InitialAdjustmentAlpha" , [128u8 , 214u8 , 205u8 , 242u8 , 181u8 , 142u8 , 124u8 , 231u8 , 190u8 , 146u8 , 59u8 , 226u8 , 157u8 , 101u8 , 103u8 , 117u8 , 249u8 , 65u8 , 18u8 , 191u8 , 103u8 , 119u8 , 53u8 , 85u8 , 81u8 , 96u8 , 220u8 , 42u8 , 184u8 , 239u8 , 42u8 , 246u8 ,]) } # [doc = " Initial network immunity period"] pub fn initial_network_immunity_period (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u64 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("SubtensorModule" , "InitialNetworkImmunityPeriod" , [128u8 , 214u8 , 205u8 , 242u8 , 181u8 , 142u8 , 124u8 , 231u8 , 190u8 , 146u8 , 59u8 , 226u8 , 157u8 , 101u8 , 103u8 , 117u8 , 249u8 , 65u8 , 18u8 , 191u8 , 103u8 , 119u8 , 53u8 , 85u8 , 81u8 , 96u8 , 220u8 , 42u8 , 184u8 , 239u8 , 42u8 , 246u8 ,]) } # [doc = " Initial minimum allowed network UIDs"] pub fn initial_network_min_allowed_uids (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u16 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("SubtensorModule" , "InitialNetworkMinAllowedUids" , [116u8 , 33u8 , 2u8 , 170u8 , 181u8 , 147u8 , 171u8 , 169u8 , 167u8 , 227u8 , 41u8 , 144u8 , 11u8 , 236u8 , 82u8 , 100u8 , 74u8 , 60u8 , 184u8 , 72u8 , 169u8 , 90u8 , 208u8 , 135u8 , 15u8 , 117u8 , 10u8 , 123u8 , 128u8 , 193u8 , 29u8 , 70u8 ,]) } # [doc = " Initial network minimum burn cost"] pub fn initial_network_min_lock_cost (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u64 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("SubtensorModule" , "InitialNetworkMinLockCost" , [128u8 , 214u8 , 205u8 , 242u8 , 181u8 , 142u8 , 124u8 , 231u8 , 190u8 , 146u8 , 59u8 , 226u8 , 157u8 , 101u8 , 103u8 , 117u8 , 249u8 , 65u8 , 18u8 , 191u8 , 103u8 , 119u8 , 53u8 , 85u8 , 81u8 , 96u8 , 220u8 , 42u8 , 184u8 , 239u8 , 42u8 , 246u8 ,]) } # [doc = " Initial network subnet cut."] pub fn initial_subnet_owner_cut (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u16 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("SubtensorModule" , "InitialSubnetOwnerCut" , [116u8 , 33u8 , 2u8 , 170u8 , 181u8 , 147u8 , 171u8 , 169u8 , 167u8 , 227u8 , 41u8 , 144u8 , 11u8 , 236u8 , 82u8 , 100u8 , 74u8 , 60u8 , 184u8 , 72u8 , 169u8 , 90u8 , 208u8 , 135u8 , 15u8 , 117u8 , 10u8 , 123u8 , 128u8 , 193u8 , 29u8 , 70u8 ,]) } # [doc = " Initial lock reduction interval."] pub fn initial_network_lock_reduction_interval (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u64 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("SubtensorModule" , "InitialNetworkLockReductionInterval" , [128u8 , 214u8 , 205u8 , 242u8 , 181u8 , 142u8 , 124u8 , 231u8 , 190u8 , 146u8 , 59u8 , 226u8 , 157u8 , 101u8 , 103u8 , 117u8 , 249u8 , 65u8 , 18u8 , 191u8 , 103u8 , 119u8 , 53u8 , 85u8 , 81u8 , 96u8 , 220u8 , 42u8 , 184u8 , 239u8 , 42u8 , 246u8 ,]) } # [doc = " Initial max allowed subnets"] pub fn initial_subnet_limit (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u16 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("SubtensorModule" , "InitialSubnetLimit" , [116u8 , 33u8 , 2u8 , 170u8 , 181u8 , 147u8 , 171u8 , 169u8 , 167u8 , 227u8 , 41u8 , 144u8 , 11u8 , 236u8 , 82u8 , 100u8 , 74u8 , 60u8 , 184u8 , 72u8 , 169u8 , 90u8 , 208u8 , 135u8 , 15u8 , 117u8 , 10u8 , 123u8 , 128u8 , 193u8 , 29u8 , 70u8 ,]) } # [doc = " Initial network creation rate limit"] pub fn initial_network_rate_limit (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u64 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("SubtensorModule" , "InitialNetworkRateLimit" , [128u8 , 214u8 , 205u8 , 242u8 , 181u8 , 142u8 , 124u8 , 231u8 , 190u8 , 146u8 , 59u8 , 226u8 , 157u8 , 101u8 , 103u8 , 117u8 , 249u8 , 65u8 , 18u8 , 191u8 , 103u8 , 119u8 , 53u8 , 85u8 , 81u8 , 96u8 , 220u8 , 42u8 , 184u8 , 239u8 , 42u8 , 246u8 ,]) } # [doc = " Initial target stakes per interval issuance."] pub fn initial_target_stakes_per_interval (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u64 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("SubtensorModule" , "InitialTargetStakesPerInterval" , [128u8 , 214u8 , 205u8 , 242u8 , 181u8 , 142u8 , 124u8 , 231u8 , 190u8 , 146u8 , 59u8 , 226u8 , 157u8 , 101u8 , 103u8 , 117u8 , 249u8 , 65u8 , 18u8 , 191u8 , 103u8 , 119u8 , 53u8 , 85u8 , 81u8 , 96u8 , 220u8 , 42u8 , 184u8 , 239u8 , 42u8 , 246u8 ,]) } # [doc = " Cost of swapping a hotkey."] pub fn key_swap_cost (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u64 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("SubtensorModule" , "KeySwapCost" , [128u8 , 214u8 , 205u8 , 242u8 , 181u8 , 142u8 , 124u8 , 231u8 , 190u8 , 146u8 , 59u8 , 226u8 , 157u8 , 101u8 , 103u8 , 117u8 , 249u8 , 65u8 , 18u8 , 191u8 , 103u8 , 119u8 , 53u8 , 85u8 , 81u8 , 96u8 , 220u8 , 42u8 , 184u8 , 239u8 , 42u8 , 246u8 ,]) } # [doc = " The upper bound for the alpha parameter. Used for Liquid Alpha."] pub fn alpha_high (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u16 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("SubtensorModule" , "AlphaHigh" , [116u8 , 33u8 , 2u8 , 170u8 , 181u8 , 147u8 , 171u8 , 169u8 , 167u8 , 227u8 , 41u8 , 144u8 , 11u8 , 236u8 , 82u8 , 100u8 , 74u8 , 60u8 , 184u8 , 72u8 , 169u8 , 90u8 , 208u8 , 135u8 , 15u8 , 117u8 , 10u8 , 123u8 , 128u8 , 193u8 , 29u8 , 70u8 ,]) } # [doc = " The lower bound for the alpha parameter. Used for Liquid Alpha."] pub fn alpha_low (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u16 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("SubtensorModule" , "AlphaLow" , [116u8 , 33u8 , 2u8 , 170u8 , 181u8 , 147u8 , 171u8 , 169u8 , 167u8 , 227u8 , 41u8 , 144u8 , 11u8 , 236u8 , 82u8 , 100u8 , 74u8 , 60u8 , 184u8 , 72u8 , 169u8 , 90u8 , 208u8 , 135u8 , 15u8 , 117u8 , 10u8 , 123u8 , 128u8 , 193u8 , 29u8 , 70u8 ,]) } # [doc = " A flag to indicate if Liquid Alpha is enabled."] pub fn liquid_alpha_on (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: bool > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("SubtensorModule" , "LiquidAlphaOn" , [165u8 , 28u8 , 112u8 , 190u8 , 18u8 , 129u8 , 182u8 , 206u8 , 237u8 , 1u8 , 68u8 , 252u8 , 125u8 , 234u8 , 185u8 , 50u8 , 149u8 , 164u8 , 47u8 , 126u8 , 134u8 , 100u8 , 14u8 , 86u8 , 209u8 , 39u8 , 20u8 , 4u8 , 233u8 , 115u8 , 102u8 , 131u8 ,]) } # [doc = " Initial network max stake."] pub fn initial_network_max_stake (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u64 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("SubtensorModule" , "InitialNetworkMaxStake" , [128u8 , 214u8 , 205u8 , 242u8 , 181u8 , 142u8 , 124u8 , 231u8 , 190u8 , 146u8 , 59u8 , 226u8 , 157u8 , 101u8 , 103u8 , 117u8 , 249u8 , 65u8 , 18u8 , 191u8 , 103u8 , 119u8 , 53u8 , 85u8 , 81u8 , 96u8 , 220u8 , 42u8 , 184u8 , 239u8 , 42u8 , 246u8 ,]) } # [doc = " Initial hotkey emission tempo."] pub fn initial_hotkey_emission_tempo (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u64 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("SubtensorModule" , "InitialHotkeyEmissionTempo" , [128u8 , 214u8 , 205u8 , 242u8 , 181u8 , 142u8 , 124u8 , 231u8 , 190u8 , 146u8 , 59u8 , 226u8 , 157u8 , 101u8 , 103u8 , 117u8 , 249u8 , 65u8 , 18u8 , 191u8 , 103u8 , 119u8 , 53u8 , 85u8 , 81u8 , 96u8 , 220u8 , 42u8 , 184u8 , 239u8 , 42u8 , 246u8 ,]) } # [doc = " Coldkey swap schedule duartion."] pub fn initial_coldkey_swap_schedule_duration (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u32 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("SubtensorModule" , "InitialColdkeySwapScheduleDuration" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " Dissolve network schedule duration"] pub fn initial_dissolve_network_schedule_duration (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u32 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("SubtensorModule" , "InitialDissolveNetworkScheduleDuration" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } } } } pub mod triumvirate { use super :: root_mod ; use super :: runtime_types ; # [doc = "The `Error` enum of this pallet."] pub type Error = runtime_types :: pallet_collective :: pallet :: Error ; # [doc = "Contains a variant per dispatchable extrinsic that this pallet has."] pub type Call = runtime_types :: pallet_collective :: pallet :: Call ; pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; pub mod types { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Set the collective's membership."] # [doc = ""] # [doc = "- `new_members`: The new member list. Be nice to the chain and provide it sorted."] # [doc = "- `prime`: The prime member whose vote sets the default."] # [doc = "- `old_count`: The upper bound for the previous number of members in storage. Used for"] # [doc = "  weight estimation."] # [doc = ""] # [doc = "The dispatch of this call must be `SetMembersOrigin`."] # [doc = ""] # [doc = "NOTE: Does not enforce the expected `MaxMembers` limit on the amount of members, but"] # [doc = "      the weight estimations rely on it to estimate dispatchable weight."] # [doc = ""] # [doc = "# WARNING:"] # [doc = ""] # [doc = "The `pallet-collective` can also be managed by logic outside of the pallet through the"] # [doc = "implementation of the trait [`ChangeMembers`]."] # [doc = "Any call to `set_members` must be careful that the member set doesn't get out of sync"] # [doc = "with other logic managing the member set."] # [doc = ""] # [doc = "## Complexity:"] # [doc = "- `O(MP + N)` where:"] # [doc = "  - `M` old-members-count (code- and governance-bounded)"] # [doc = "  - `N` new-members-count (code- and governance-bounded)"] # [doc = "  - `P` proposals-count (code-bounded)"] pub struct SetMembers { pub new_members : set_members :: NewMembers , pub prime : set_members :: Prime , pub old_count : set_members :: OldCount , } pub mod set_members { use super :: runtime_types ; pub type NewMembers = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: subxt :: ext :: subxt_core :: utils :: AccountId32 > ; pub type Prime = :: core :: option :: Option < :: subxt :: ext :: subxt_core :: utils :: AccountId32 > ; pub type OldCount = :: core :: primitive :: u32 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SetMembers { const PALLET : & 'static str = "Triumvirate" ; const CALL : & 'static str = "set_members" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Dispatch a proposal from a member using the `Member` origin."] # [doc = ""] # [doc = "Origin must be a member of the collective."] # [doc = ""] # [doc = "## Complexity:"] # [doc = "- `O(B + M + P)` where:"] # [doc = "- `B` is `proposal` size in bytes (length-fee-bounded)"] # [doc = "- `M` members-count (code-bounded)"] # [doc = "- `P` complexity of dispatching `proposal`"] pub struct Execute { pub proposal : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < execute :: Proposal > , # [codec (compact)] pub length_bound : execute :: LengthBound , } pub mod execute { use super :: runtime_types ; pub type Proposal = runtime_types :: node_subtensor_runtime :: RuntimeCall ; pub type LengthBound = :: core :: primitive :: u32 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for Execute { const PALLET : & 'static str = "Triumvirate" ; const CALL : & 'static str = "execute" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Add a new proposal to either be voted on or executed directly."] # [doc = ""] # [doc = "Requires the sender to be member."] # [doc = ""] # [doc = "`threshold` determines whether `proposal` is executed directly (`threshold < 2`)"] # [doc = "or put up for voting."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(B + M + P1)` or `O(B + M + P2)` where:"] # [doc = "  - `B` is `proposal` size in bytes (length-fee-bounded)"] # [doc = "  - `M` is members-count (code- and governance-bounded)"] # [doc = "  - branching is influenced by `threshold` where:"] # [doc = "    - `P1` is proposal execution complexity (`threshold < 2`)"] # [doc = "    - `P2` is proposals-count (code-bounded) (`threshold >= 2`)"] pub struct Propose { pub proposal : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < propose :: Proposal > , # [codec (compact)] pub length_bound : propose :: LengthBound , pub duration : propose :: Duration , } pub mod propose { use super :: runtime_types ; pub type Proposal = runtime_types :: node_subtensor_runtime :: RuntimeCall ; pub type LengthBound = :: core :: primitive :: u32 ; pub type Duration = :: core :: primitive :: u32 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for Propose { const PALLET : & 'static str = "Triumvirate" ; const CALL : & 'static str = "propose" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Add an aye or nay vote for the sender to the given proposal."] # [doc = ""] # [doc = "Requires the sender to be a member."] # [doc = ""] # [doc = "Transaction fees will be waived if the member is voting on any particular proposal"] # [doc = "for the first time and the call is successful. Subsequent vote changes will charge a"] # [doc = "fee."] # [doc = "## Complexity"] # [doc = "- `O(M)` where `M` is members-count (code- and governance-bounded)"] pub struct Vote { pub proposal : vote :: Proposal , # [codec (compact)] pub index : vote :: Index , pub approve : vote :: Approve , } pub mod vote { use super :: runtime_types ; pub type Proposal = :: subxt :: ext :: subxt_core :: utils :: H256 ; pub type Index = :: core :: primitive :: u32 ; pub type Approve = :: core :: primitive :: bool ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for Vote { const PALLET : & 'static str = "Triumvirate" ; const CALL : & 'static str = "vote" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Disapprove a proposal, close, and remove it from the system, regardless of its current"] # [doc = "state."] # [doc = ""] # [doc = "Must be called by the Root origin."] # [doc = ""] # [doc = "Parameters:"] # [doc = "* `proposal_hash`: The hash of the proposal that should be disapproved."] # [doc = ""] # [doc = "## Complexity"] # [doc = "O(P) where P is the number of max proposals"] pub struct DisapproveProposal { pub proposal_hash : disapprove_proposal :: ProposalHash , } pub mod disapprove_proposal { use super :: runtime_types ; pub type ProposalHash = :: subxt :: ext :: subxt_core :: utils :: H256 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for DisapproveProposal { const PALLET : & 'static str = "Triumvirate" ; const CALL : & 'static str = "disapprove_proposal" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Close a vote that is either approved, disapproved or whose voting period has ended."] # [doc = ""] # [doc = "May be called by any signed account in order to finish voting and close the proposal."] # [doc = ""] # [doc = "If called before the end of the voting period it will only close the vote if it is"] # [doc = "has enough votes to be approved or disapproved."] # [doc = ""] # [doc = "If called after the end of the voting period abstentions are counted as rejections"] # [doc = "unless there is a prime member set and the prime member cast an approval."] # [doc = ""] # [doc = "If the close operation completes successfully with disapproval, the transaction fee will"] # [doc = "be waived. Otherwise execution of the approved operation will be charged to the caller."] # [doc = ""] # [doc = "+ `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed"] # [doc = "proposal."] # [doc = "+ `length_bound`: The upper bound for the length of the proposal in storage. Checked via"] # [doc = "`storage::read` so it is `size_of::<u32>() == 4` larger than the pure length."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(B + M + P1 + P2)` where:"] # [doc = "  - `B` is `proposal` size in bytes (length-fee-bounded)"] # [doc = "  - `M` is members-count (code- and governance-bounded)"] # [doc = "  - `P1` is the complexity of `proposal` preimage."] # [doc = "  - `P2` is proposal-count (code-bounded)"] pub struct Close { pub proposal_hash : close :: ProposalHash , # [codec (compact)] pub index : close :: Index , pub proposal_weight_bound : close :: ProposalWeightBound , # [codec (compact)] pub length_bound : close :: LengthBound , } pub mod close { use super :: runtime_types ; pub type ProposalHash = :: subxt :: ext :: subxt_core :: utils :: H256 ; pub type Index = :: core :: primitive :: u32 ; pub type ProposalWeightBound = runtime_types :: sp_weights :: weight_v2 :: Weight ; pub type LengthBound = :: core :: primitive :: u32 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for Close { const PALLET : & 'static str = "Triumvirate" ; const CALL : & 'static str = "close" ; } } pub struct TransactionApi ; impl TransactionApi { # [doc = "Set the collective's membership."] # [doc = ""] # [doc = "- `new_members`: The new member list. Be nice to the chain and provide it sorted."] # [doc = "- `prime`: The prime member whose vote sets the default."] # [doc = "- `old_count`: The upper bound for the previous number of members in storage. Used for"] # [doc = "  weight estimation."] # [doc = ""] # [doc = "The dispatch of this call must be `SetMembersOrigin`."] # [doc = ""] # [doc = "NOTE: Does not enforce the expected `MaxMembers` limit on the amount of members, but"] # [doc = "      the weight estimations rely on it to estimate dispatchable weight."] # [doc = ""] # [doc = "# WARNING:"] # [doc = ""] # [doc = "The `pallet-collective` can also be managed by logic outside of the pallet through the"] # [doc = "implementation of the trait [`ChangeMembers`]."] # [doc = "Any call to `set_members` must be careful that the member set doesn't get out of sync"] # [doc = "with other logic managing the member set."] # [doc = ""] # [doc = "## Complexity:"] # [doc = "- `O(MP + N)` where:"] # [doc = "  - `M` old-members-count (code- and governance-bounded)"] # [doc = "  - `N` new-members-count (code- and governance-bounded)"] # [doc = "  - `P` proposals-count (code-bounded)"] pub fn set_members (& self , new_members : types :: set_members :: NewMembers , prime : types :: set_members :: Prime , old_count : types :: set_members :: OldCount ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SetMembers > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Triumvirate" , "set_members" , types :: SetMembers { new_members , prime , old_count , } , [66u8 , 224u8 , 186u8 , 178u8 , 41u8 , 208u8 , 67u8 , 192u8 , 57u8 , 242u8 , 141u8 , 31u8 , 216u8 , 118u8 , 192u8 , 43u8 , 125u8 , 213u8 , 226u8 , 85u8 , 142u8 , 225u8 , 131u8 , 45u8 , 172u8 , 142u8 , 12u8 , 9u8 , 73u8 , 7u8 , 218u8 , 61u8 ,]) } # [doc = "Dispatch a proposal from a member using the `Member` origin."] # [doc = ""] # [doc = "Origin must be a member of the collective."] # [doc = ""] # [doc = "## Complexity:"] # [doc = "- `O(B + M + P)` where:"] # [doc = "- `B` is `proposal` size in bytes (length-fee-bounded)"] # [doc = "- `M` members-count (code-bounded)"] # [doc = "- `P` complexity of dispatching `proposal`"] pub fn execute (& self , proposal : types :: execute :: Proposal , length_bound : types :: execute :: LengthBound ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: Execute > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Triumvirate" , "execute" , types :: Execute { proposal : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box :: new (proposal) , length_bound , } , [79u8 , 197u8 , 4u8 , 129u8 , 114u8 , 142u8 , 105u8 , 207u8 , 79u8 , 118u8 , 228u8 , 8u8 , 18u8 , 215u8 , 141u8 , 141u8 , 105u8 , 185u8 , 4u8 , 210u8 , 122u8 , 150u8 , 131u8 , 64u8 , 16u8 , 255u8 , 141u8 , 41u8 , 65u8 , 69u8 , 148u8 , 120u8 ,]) } # [doc = "Add a new proposal to either be voted on or executed directly."] # [doc = ""] # [doc = "Requires the sender to be member."] # [doc = ""] # [doc = "`threshold` determines whether `proposal` is executed directly (`threshold < 2`)"] # [doc = "or put up for voting."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(B + M + P1)` or `O(B + M + P2)` where:"] # [doc = "  - `B` is `proposal` size in bytes (length-fee-bounded)"] # [doc = "  - `M` is members-count (code- and governance-bounded)"] # [doc = "  - branching is influenced by `threshold` where:"] # [doc = "    - `P1` is proposal execution complexity (`threshold < 2`)"] # [doc = "    - `P2` is proposals-count (code-bounded) (`threshold >= 2`)"] pub fn propose (& self , proposal : types :: propose :: Proposal , length_bound : types :: propose :: LengthBound , duration : types :: propose :: Duration ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: Propose > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Triumvirate" , "propose" , types :: Propose { proposal : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box :: new (proposal) , length_bound , duration , } , [94u8 , 12u8 , 141u8 , 164u8 , 245u8 , 135u8 , 6u8 , 103u8 , 37u8 , 191u8 , 208u8 , 15u8 , 104u8 , 221u8 , 75u8 , 170u8 , 228u8 , 42u8 , 14u8 , 245u8 , 126u8 , 5u8 , 131u8 , 103u8 , 117u8 , 179u8 , 207u8 , 200u8 , 207u8 , 42u8 , 81u8 , 14u8 ,]) } # [doc = "Add an aye or nay vote for the sender to the given proposal."] # [doc = ""] # [doc = "Requires the sender to be a member."] # [doc = ""] # [doc = "Transaction fees will be waived if the member is voting on any particular proposal"] # [doc = "for the first time and the call is successful. Subsequent vote changes will charge a"] # [doc = "fee."] # [doc = "## Complexity"] # [doc = "- `O(M)` where `M` is members-count (code- and governance-bounded)"] pub fn vote (& self , proposal : types :: vote :: Proposal , index : types :: vote :: Index , approve : types :: vote :: Approve ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: Vote > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Triumvirate" , "vote" , types :: Vote { proposal , index , approve , } , [110u8 , 141u8 , 24u8 , 33u8 , 91u8 , 7u8 , 89u8 , 198u8 , 54u8 , 10u8 , 76u8 , 129u8 , 45u8 , 20u8 , 216u8 , 104u8 , 231u8 , 246u8 , 174u8 , 205u8 , 190u8 , 176u8 , 171u8 , 113u8 , 33u8 , 37u8 , 155u8 , 203u8 , 251u8 , 34u8 , 25u8 , 120u8 ,]) } # [doc = "Disapprove a proposal, close, and remove it from the system, regardless of its current"] # [doc = "state."] # [doc = ""] # [doc = "Must be called by the Root origin."] # [doc = ""] # [doc = "Parameters:"] # [doc = "* `proposal_hash`: The hash of the proposal that should be disapproved."] # [doc = ""] # [doc = "## Complexity"] # [doc = "O(P) where P is the number of max proposals"] pub fn disapprove_proposal (& self , proposal_hash : types :: disapprove_proposal :: ProposalHash ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: DisapproveProposal > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Triumvirate" , "disapprove_proposal" , types :: DisapproveProposal { proposal_hash , } , [26u8 , 140u8 , 111u8 , 193u8 , 229u8 , 59u8 , 53u8 , 196u8 , 230u8 , 60u8 , 7u8 , 155u8 , 168u8 , 7u8 , 201u8 , 177u8 , 70u8 , 103u8 , 190u8 , 57u8 , 244u8 , 156u8 , 67u8 , 101u8 , 228u8 , 6u8 , 213u8 , 83u8 , 225u8 , 95u8 , 148u8 , 96u8 ,]) } # [doc = "Close a vote that is either approved, disapproved or whose voting period has ended."] # [doc = ""] # [doc = "May be called by any signed account in order to finish voting and close the proposal."] # [doc = ""] # [doc = "If called before the end of the voting period it will only close the vote if it is"] # [doc = "has enough votes to be approved or disapproved."] # [doc = ""] # [doc = "If called after the end of the voting period abstentions are counted as rejections"] # [doc = "unless there is a prime member set and the prime member cast an approval."] # [doc = ""] # [doc = "If the close operation completes successfully with disapproval, the transaction fee will"] # [doc = "be waived. Otherwise execution of the approved operation will be charged to the caller."] # [doc = ""] # [doc = "+ `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed"] # [doc = "proposal."] # [doc = "+ `length_bound`: The upper bound for the length of the proposal in storage. Checked via"] # [doc = "`storage::read` so it is `size_of::<u32>() == 4` larger than the pure length."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(B + M + P1 + P2)` where:"] # [doc = "  - `B` is `proposal` size in bytes (length-fee-bounded)"] # [doc = "  - `M` is members-count (code- and governance-bounded)"] # [doc = "  - `P1` is the complexity of `proposal` preimage."] # [doc = "  - `P2` is proposal-count (code-bounded)"] pub fn close (& self , proposal_hash : types :: close :: ProposalHash , index : types :: close :: Index , proposal_weight_bound : types :: close :: ProposalWeightBound , length_bound : types :: close :: LengthBound ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: Close > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Triumvirate" , "close" , types :: Close { proposal_hash , index , proposal_weight_bound , length_bound , } , [136u8 , 48u8 , 243u8 , 34u8 , 60u8 , 109u8 , 186u8 , 158u8 , 72u8 , 48u8 , 62u8 , 34u8 , 167u8 , 46u8 , 33u8 , 142u8 , 239u8 , 43u8 , 238u8 , 125u8 , 94u8 , 80u8 , 157u8 , 245u8 , 220u8 , 126u8 , 58u8 , 244u8 , 186u8 , 195u8 , 30u8 , 127u8 ,]) } } } # [doc = "The `Event` enum of this pallet"] pub type Event = runtime_types :: pallet_collective :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "A motion (given hash) has been proposed (by given account) with a threshold (given"] # [doc = "`MemberCount`)."] pub struct Proposed { pub account : proposed :: Account , pub proposal_index : proposed :: ProposalIndex , pub proposal_hash : proposed :: ProposalHash , pub threshold : proposed :: Threshold , } pub mod proposed { use super :: runtime_types ; pub type Account = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type ProposalIndex = :: core :: primitive :: u32 ; pub type ProposalHash = :: subxt :: ext :: subxt_core :: utils :: H256 ; pub type Threshold = :: core :: primitive :: u32 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Proposed { const PALLET : & 'static str = "Triumvirate" ; const EVENT : & 'static str = "Proposed" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "A motion (given hash) has been voted on by given account, leaving"] # [doc = "a tally (yes votes and no votes given respectively as `MemberCount`)."] pub struct Voted { pub account : voted :: Account , pub proposal_hash : voted :: ProposalHash , pub voted : voted :: Voted , pub yes : voted :: Yes , pub no : voted :: No , } pub mod voted { use super :: runtime_types ; pub type Account = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type ProposalHash = :: subxt :: ext :: subxt_core :: utils :: H256 ; pub type Voted = :: core :: primitive :: bool ; pub type Yes = :: core :: primitive :: u32 ; pub type No = :: core :: primitive :: u32 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Voted { const PALLET : & 'static str = "Triumvirate" ; const EVENT : & 'static str = "Voted" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "A motion was approved by the required threshold."] pub struct Approved { pub proposal_hash : approved :: ProposalHash , } pub mod approved { use super :: runtime_types ; pub type ProposalHash = :: subxt :: ext :: subxt_core :: utils :: H256 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Approved { const PALLET : & 'static str = "Triumvirate" ; const EVENT : & 'static str = "Approved" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "A motion was not approved by the required threshold."] pub struct Disapproved { pub proposal_hash : disapproved :: ProposalHash , } pub mod disapproved { use super :: runtime_types ; pub type ProposalHash = :: subxt :: ext :: subxt_core :: utils :: H256 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Disapproved { const PALLET : & 'static str = "Triumvirate" ; const EVENT : & 'static str = "Disapproved" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "A motion was executed; result will be `Ok` if it returned without error."] pub struct Executed { pub proposal_hash : executed :: ProposalHash , pub result : executed :: Result , } pub mod executed { use super :: runtime_types ; pub type ProposalHash = :: subxt :: ext :: subxt_core :: utils :: H256 ; pub type Result = :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Executed { const PALLET : & 'static str = "Triumvirate" ; const EVENT : & 'static str = "Executed" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "A single member did some action; result will be `Ok` if it returned without error."] pub struct MemberExecuted { pub proposal_hash : member_executed :: ProposalHash , pub result : member_executed :: Result , } pub mod member_executed { use super :: runtime_types ; pub type ProposalHash = :: subxt :: ext :: subxt_core :: utils :: H256 ; pub type Result = :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for MemberExecuted { const PALLET : & 'static str = "Triumvirate" ; const EVENT : & 'static str = "MemberExecuted" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "A proposal was closed because its threshold was reached or after its duration was up."] pub struct Closed { pub proposal_hash : closed :: ProposalHash , pub yes : closed :: Yes , pub no : closed :: No , } pub mod closed { use super :: runtime_types ; pub type ProposalHash = :: subxt :: ext :: subxt_core :: utils :: H256 ; pub type Yes = :: core :: primitive :: u32 ; pub type No = :: core :: primitive :: u32 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Closed { const PALLET : & 'static str = "Triumvirate" ; const EVENT : & 'static str = "Closed" ; } } pub mod storage { use super :: runtime_types ; pub mod types { use super :: runtime_types ; pub mod proposals { use super :: runtime_types ; pub type Proposals = runtime_types :: bounded_collections :: bounded_vec :: BoundedVec < :: subxt :: ext :: subxt_core :: utils :: H256 > ; } pub mod proposal_of { use super :: runtime_types ; pub type ProposalOf = runtime_types :: node_subtensor_runtime :: RuntimeCall ; pub type Param0 = :: subxt :: ext :: subxt_core :: utils :: H256 ; } pub mod voting { use super :: runtime_types ; pub type Voting = runtime_types :: pallet_collective :: Votes < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , :: core :: primitive :: u32 > ; pub type Param0 = :: subxt :: ext :: subxt_core :: utils :: H256 ; } pub mod proposal_count { use super :: runtime_types ; pub type ProposalCount = :: core :: primitive :: u32 ; } pub mod members { use super :: runtime_types ; pub type Members = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: subxt :: ext :: subxt_core :: utils :: AccountId32 > ; } pub mod prime { use super :: runtime_types ; pub type Prime = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } } pub struct StorageApi ; impl StorageApi { # [doc = " The hashes of the active proposals."] pub fn proposals (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: proposals :: Proposals , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Triumvirate" , "Proposals" , () , [210u8 , 234u8 , 7u8 , 29u8 , 231u8 , 80u8 , 17u8 , 36u8 , 189u8 , 34u8 , 175u8 , 147u8 , 56u8 , 92u8 , 201u8 , 104u8 , 207u8 , 150u8 , 58u8 , 110u8 , 90u8 , 28u8 , 198u8 , 79u8 , 236u8 , 245u8 , 19u8 , 38u8 , 68u8 , 59u8 , 215u8 , 74u8 ,]) } # [doc = " Actual proposal for a given hash, if it's current."] pub fn proposal_of_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: proposal_of :: ProposalOf , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Triumvirate" , "ProposalOf" , () , [235u8 , 166u8 , 246u8 , 133u8 , 213u8 , 2u8 , 3u8 , 67u8 , 136u8 , 157u8 , 158u8 , 227u8 , 94u8 , 165u8 , 41u8 , 100u8 , 70u8 , 241u8 , 132u8 , 14u8 , 157u8 , 98u8 , 228u8 , 226u8 , 134u8 , 190u8 , 219u8 , 53u8 , 105u8 , 69u8 , 49u8 , 89u8 ,]) } # [doc = " Actual proposal for a given hash, if it's current."] pub fn proposal_of (& self , _0 : impl :: core :: borrow :: Borrow < types :: proposal_of :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: proposal_of :: Param0 > , types :: proposal_of :: ProposalOf , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Triumvirate" , "ProposalOf" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [235u8 , 166u8 , 246u8 , 133u8 , 213u8 , 2u8 , 3u8 , 67u8 , 136u8 , 157u8 , 158u8 , 227u8 , 94u8 , 165u8 , 41u8 , 100u8 , 70u8 , 241u8 , 132u8 , 14u8 , 157u8 , 98u8 , 228u8 , 226u8 , 134u8 , 190u8 , 219u8 , 53u8 , 105u8 , 69u8 , 49u8 , 89u8 ,]) } # [doc = " Votes on a given proposal, if it is ongoing."] pub fn voting_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: voting :: Voting , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Triumvirate" , "Voting" , () , [109u8 , 198u8 , 2u8 , 13u8 , 29u8 , 14u8 , 241u8 , 217u8 , 55u8 , 147u8 , 147u8 , 4u8 , 176u8 , 69u8 , 132u8 , 228u8 , 158u8 , 203u8 , 110u8 , 239u8 , 158u8 , 137u8 , 97u8 , 46u8 , 228u8 , 118u8 , 251u8 , 201u8 , 88u8 , 208u8 , 94u8 , 132u8 ,]) } # [doc = " Votes on a given proposal, if it is ongoing."] pub fn voting (& self , _0 : impl :: core :: borrow :: Borrow < types :: voting :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: voting :: Param0 > , types :: voting :: Voting , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Triumvirate" , "Voting" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [109u8 , 198u8 , 2u8 , 13u8 , 29u8 , 14u8 , 241u8 , 217u8 , 55u8 , 147u8 , 147u8 , 4u8 , 176u8 , 69u8 , 132u8 , 228u8 , 158u8 , 203u8 , 110u8 , 239u8 , 158u8 , 137u8 , 97u8 , 46u8 , 228u8 , 118u8 , 251u8 , 201u8 , 88u8 , 208u8 , 94u8 , 132u8 ,]) } # [doc = " Proposals so far."] pub fn proposal_count (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: proposal_count :: ProposalCount , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Triumvirate" , "ProposalCount" , () , [91u8 , 238u8 , 246u8 , 106u8 , 95u8 , 66u8 , 83u8 , 134u8 , 1u8 , 225u8 , 164u8 , 216u8 , 113u8 , 101u8 , 203u8 , 200u8 , 113u8 , 97u8 , 246u8 , 228u8 , 140u8 , 29u8 , 29u8 , 48u8 , 176u8 , 137u8 , 93u8 , 230u8 , 56u8 , 75u8 , 51u8 , 149u8 ,]) } # [doc = " The current members of the collective. This is stored sorted (just by value)."] pub fn members (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: members :: Members , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Triumvirate" , "Members" , () , [16u8 , 29u8 , 32u8 , 222u8 , 175u8 , 136u8 , 111u8 , 101u8 , 43u8 , 74u8 , 209u8 , 81u8 , 47u8 , 97u8 , 129u8 , 39u8 , 225u8 , 243u8 , 110u8 , 229u8 , 237u8 , 21u8 , 90u8 , 127u8 , 80u8 , 239u8 , 156u8 , 32u8 , 90u8 , 109u8 , 179u8 , 0u8 ,]) } # [doc = " The prime member that helps determine the default vote behavior in case of absentations."] pub fn prime (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: prime :: Prime , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Triumvirate" , "Prime" , () , [72u8 , 128u8 , 214u8 , 72u8 , 78u8 , 80u8 , 100u8 , 198u8 , 114u8 , 215u8 , 59u8 , 3u8 , 103u8 , 14u8 , 152u8 , 202u8 , 12u8 , 165u8 , 224u8 , 10u8 , 41u8 , 154u8 , 77u8 , 95u8 , 116u8 , 143u8 , 250u8 , 250u8 , 176u8 , 92u8 , 238u8 , 154u8 ,]) } } } } pub mod triumvirate_members { use super :: root_mod ; use super :: runtime_types ; # [doc = "The `Error` enum of this pallet."] pub type Error = runtime_types :: pallet_membership :: pallet :: Error ; # [doc = "Contains a variant per dispatchable extrinsic that this pallet has."] pub type Call = runtime_types :: pallet_membership :: pallet :: Call ; pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; pub mod types { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Add a member `who` to the set."] # [doc = ""] # [doc = "May only be called from `T::AddOrigin`."] pub struct AddMember { pub who : add_member :: Who , } pub mod add_member { use super :: runtime_types ; pub type Who = :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for AddMember { const PALLET : & 'static str = "TriumvirateMembers" ; const CALL : & 'static str = "add_member" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Remove a member `who` from the set."] # [doc = ""] # [doc = "May only be called from `T::RemoveOrigin`."] pub struct RemoveMember { pub who : remove_member :: Who , } pub mod remove_member { use super :: runtime_types ; pub type Who = :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for RemoveMember { const PALLET : & 'static str = "TriumvirateMembers" ; const CALL : & 'static str = "remove_member" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Swap out one member `remove` for another `add`."] # [doc = ""] # [doc = "May only be called from `T::SwapOrigin`."] # [doc = ""] # [doc = "Prime membership is *not* passed from `remove` to `add`, if extant."] pub struct SwapMember { pub remove : swap_member :: Remove , pub add : swap_member :: Add , } pub mod swap_member { use super :: runtime_types ; pub type Remove = :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > ; pub type Add = :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SwapMember { const PALLET : & 'static str = "TriumvirateMembers" ; const CALL : & 'static str = "swap_member" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Change the membership to a new set, disregarding the existing membership. Be nice and"] # [doc = "pass `members` pre-sorted."] # [doc = ""] # [doc = "May only be called from `T::ResetOrigin`."] pub struct ResetMembers { pub members : reset_members :: Members , } pub mod reset_members { use super :: runtime_types ; pub type Members = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: subxt :: ext :: subxt_core :: utils :: AccountId32 > ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for ResetMembers { const PALLET : & 'static str = "TriumvirateMembers" ; const CALL : & 'static str = "reset_members" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Swap out the sending member for some other key `new`."] # [doc = ""] # [doc = "May only be called from `Signed` origin of a current member."] # [doc = ""] # [doc = "Prime membership is passed from the origin account to `new`, if extant."] pub struct ChangeKey { pub new : change_key :: New , } pub mod change_key { use super :: runtime_types ; pub type New = :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for ChangeKey { const PALLET : & 'static str = "TriumvirateMembers" ; const CALL : & 'static str = "change_key" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Set the prime member. Must be a current member."] # [doc = ""] # [doc = "May only be called from `T::PrimeOrigin`."] pub struct SetPrime { pub who : set_prime :: Who , } pub mod set_prime { use super :: runtime_types ; pub type Who = :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SetPrime { const PALLET : & 'static str = "TriumvirateMembers" ; const CALL : & 'static str = "set_prime" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Remove the prime member if it exists."] # [doc = ""] # [doc = "May only be called from `T::PrimeOrigin`."] pub struct ClearPrime ; impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for ClearPrime { const PALLET : & 'static str = "TriumvirateMembers" ; const CALL : & 'static str = "clear_prime" ; } } pub struct TransactionApi ; impl TransactionApi { # [doc = "Add a member `who` to the set."] # [doc = ""] # [doc = "May only be called from `T::AddOrigin`."] pub fn add_member (& self , who : types :: add_member :: Who ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: AddMember > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("TriumvirateMembers" , "add_member" , types :: AddMember { who , } , [2u8 , 131u8 , 37u8 , 217u8 , 112u8 , 46u8 , 86u8 , 165u8 , 248u8 , 244u8 , 33u8 , 236u8 , 155u8 , 28u8 , 163u8 , 169u8 , 213u8 , 32u8 , 70u8 , 217u8 , 97u8 , 194u8 , 138u8 , 77u8 , 133u8 , 97u8 , 188u8 , 49u8 , 49u8 , 31u8 , 177u8 , 206u8 ,]) } # [doc = "Remove a member `who` from the set."] # [doc = ""] # [doc = "May only be called from `T::RemoveOrigin`."] pub fn remove_member (& self , who : types :: remove_member :: Who ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: RemoveMember > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("TriumvirateMembers" , "remove_member" , types :: RemoveMember { who , } , [78u8 , 153u8 , 97u8 , 110u8 , 121u8 , 242u8 , 112u8 , 56u8 , 195u8 , 217u8 , 10u8 , 202u8 , 114u8 , 134u8 , 220u8 , 237u8 , 198u8 , 109u8 , 247u8 , 85u8 , 156u8 , 88u8 , 138u8 , 79u8 , 189u8 , 37u8 , 230u8 , 55u8 , 1u8 , 27u8 , 89u8 , 80u8 ,]) } # [doc = "Swap out one member `remove` for another `add`."] # [doc = ""] # [doc = "May only be called from `T::SwapOrigin`."] # [doc = ""] # [doc = "Prime membership is *not* passed from `remove` to `add`, if extant."] pub fn swap_member (& self , remove : types :: swap_member :: Remove , add : types :: swap_member :: Add ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SwapMember > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("TriumvirateMembers" , "swap_member" , types :: SwapMember { remove , add , } , [170u8 , 68u8 , 212u8 , 185u8 , 186u8 , 38u8 , 222u8 , 227u8 , 255u8 , 119u8 , 187u8 , 170u8 , 247u8 , 101u8 , 138u8 , 167u8 , 232u8 , 33u8 , 116u8 , 1u8 , 229u8 , 171u8 , 94u8 , 150u8 , 193u8 , 51u8 , 254u8 , 106u8 , 44u8 , 96u8 , 28u8 , 88u8 ,]) } # [doc = "Change the membership to a new set, disregarding the existing membership. Be nice and"] # [doc = "pass `members` pre-sorted."] # [doc = ""] # [doc = "May only be called from `T::ResetOrigin`."] pub fn reset_members (& self , members : types :: reset_members :: Members ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: ResetMembers > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("TriumvirateMembers" , "reset_members" , types :: ResetMembers { members , } , [212u8 , 144u8 , 99u8 , 156u8 , 70u8 , 4u8 , 219u8 , 227u8 , 150u8 , 25u8 , 86u8 , 8u8 , 215u8 , 128u8 , 193u8 , 206u8 , 33u8 , 193u8 , 71u8 , 15u8 , 20u8 , 92u8 , 99u8 , 89u8 , 174u8 , 236u8 , 102u8 , 82u8 , 164u8 , 234u8 , 12u8 , 45u8 ,]) } # [doc = "Swap out the sending member for some other key `new`."] # [doc = ""] # [doc = "May only be called from `Signed` origin of a current member."] # [doc = ""] # [doc = "Prime membership is passed from the origin account to `new`, if extant."] pub fn change_key (& self , new : types :: change_key :: New ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: ChangeKey > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("TriumvirateMembers" , "change_key" , types :: ChangeKey { new , } , [129u8 , 233u8 , 205u8 , 107u8 , 5u8 , 50u8 , 160u8 , 60u8 , 161u8 , 248u8 , 44u8 , 53u8 , 50u8 , 141u8 , 169u8 , 36u8 , 182u8 , 195u8 , 173u8 , 142u8 , 121u8 , 153u8 , 249u8 , 234u8 , 253u8 , 64u8 , 110u8 , 51u8 , 207u8 , 127u8 , 166u8 , 108u8 ,]) } # [doc = "Set the prime member. Must be a current member."] # [doc = ""] # [doc = "May only be called from `T::PrimeOrigin`."] pub fn set_prime (& self , who : types :: set_prime :: Who ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SetPrime > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("TriumvirateMembers" , "set_prime" , types :: SetPrime { who , } , [213u8 , 60u8 , 220u8 , 4u8 , 28u8 , 111u8 , 6u8 , 128u8 , 228u8 , 150u8 , 14u8 , 182u8 , 183u8 , 94u8 , 120u8 , 238u8 , 15u8 , 241u8 , 107u8 , 152u8 , 182u8 , 33u8 , 154u8 , 203u8 , 172u8 , 217u8 , 31u8 , 212u8 , 112u8 , 158u8 , 17u8 , 188u8 ,]) } # [doc = "Remove the prime member if it exists."] # [doc = ""] # [doc = "May only be called from `T::PrimeOrigin`."] pub fn clear_prime (& self ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: ClearPrime > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("TriumvirateMembers" , "clear_prime" , types :: ClearPrime { } , [71u8 , 213u8 , 34u8 , 23u8 , 186u8 , 63u8 , 240u8 , 216u8 , 190u8 , 251u8 , 84u8 , 109u8 , 140u8 , 137u8 , 210u8 , 211u8 , 242u8 , 231u8 , 212u8 , 133u8 , 151u8 , 125u8 , 25u8 , 46u8 , 210u8 , 53u8 , 133u8 , 222u8 , 21u8 , 107u8 , 120u8 , 52u8 ,]) } } } # [doc = "The `Event` enum of this pallet"] pub type Event = runtime_types :: pallet_membership :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The given member was added; see the transaction for who."] pub struct MemberAdded ; impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for MemberAdded { const PALLET : & 'static str = "TriumvirateMembers" ; const EVENT : & 'static str = "MemberAdded" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The given member was removed; see the transaction for who."] pub struct MemberRemoved ; impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for MemberRemoved { const PALLET : & 'static str = "TriumvirateMembers" ; const EVENT : & 'static str = "MemberRemoved" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Two members were swapped; see the transaction for who."] pub struct MembersSwapped ; impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for MembersSwapped { const PALLET : & 'static str = "TriumvirateMembers" ; const EVENT : & 'static str = "MembersSwapped" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The membership was reset; see the transaction for who the new set is."] pub struct MembersReset ; impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for MembersReset { const PALLET : & 'static str = "TriumvirateMembers" ; const EVENT : & 'static str = "MembersReset" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "One of the members' keys changed."] pub struct KeyChanged ; impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for KeyChanged { const PALLET : & 'static str = "TriumvirateMembers" ; const EVENT : & 'static str = "KeyChanged" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Phantom member, never used."] pub struct Dummy ; impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Dummy { const PALLET : & 'static str = "TriumvirateMembers" ; const EVENT : & 'static str = "Dummy" ; } } pub mod storage { use super :: runtime_types ; pub mod types { use super :: runtime_types ; pub mod members { use super :: runtime_types ; pub type Members = runtime_types :: bounded_collections :: bounded_vec :: BoundedVec < :: subxt :: ext :: subxt_core :: utils :: AccountId32 > ; } pub mod prime { use super :: runtime_types ; pub type Prime = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } } pub struct StorageApi ; impl StorageApi { # [doc = " The current membership, stored as an ordered Vec."] pub fn members (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: members :: Members , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("TriumvirateMembers" , "Members" , () , [109u8 , 100u8 , 14u8 , 195u8 , 213u8 , 67u8 , 44u8 , 218u8 , 84u8 , 254u8 , 76u8 , 80u8 , 210u8 , 155u8 , 155u8 , 30u8 , 18u8 , 169u8 , 195u8 , 92u8 , 208u8 , 223u8 , 242u8 , 97u8 , 147u8 , 20u8 , 168u8 , 145u8 , 254u8 , 115u8 , 225u8 , 193u8 ,]) } # [doc = " The current prime member, if one exists."] pub fn prime (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: prime :: Prime , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("TriumvirateMembers" , "Prime" , () , [72u8 , 128u8 , 214u8 , 72u8 , 78u8 , 80u8 , 100u8 , 198u8 , 114u8 , 215u8 , 59u8 , 3u8 , 103u8 , 14u8 , 152u8 , 202u8 , 12u8 , 165u8 , 224u8 , 10u8 , 41u8 , 154u8 , 77u8 , 95u8 , 116u8 , 143u8 , 250u8 , 250u8 , 176u8 , 92u8 , 238u8 , 154u8 ,]) } } } } pub mod senate_members { use super :: root_mod ; use super :: runtime_types ; # [doc = "The `Error` enum of this pallet."] pub type Error = runtime_types :: pallet_membership :: pallet :: Error ; # [doc = "Contains a variant per dispatchable extrinsic that this pallet has."] pub type Call = runtime_types :: pallet_membership :: pallet :: Call ; pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; pub mod types { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Add a member `who` to the set."] # [doc = ""] # [doc = "May only be called from `T::AddOrigin`."] pub struct AddMember { pub who : add_member :: Who , } pub mod add_member { use super :: runtime_types ; pub type Who = :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for AddMember { const PALLET : & 'static str = "SenateMembers" ; const CALL : & 'static str = "add_member" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Remove a member `who` from the set."] # [doc = ""] # [doc = "May only be called from `T::RemoveOrigin`."] pub struct RemoveMember { pub who : remove_member :: Who , } pub mod remove_member { use super :: runtime_types ; pub type Who = :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for RemoveMember { const PALLET : & 'static str = "SenateMembers" ; const CALL : & 'static str = "remove_member" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Swap out one member `remove` for another `add`."] # [doc = ""] # [doc = "May only be called from `T::SwapOrigin`."] # [doc = ""] # [doc = "Prime membership is *not* passed from `remove` to `add`, if extant."] pub struct SwapMember { pub remove : swap_member :: Remove , pub add : swap_member :: Add , } pub mod swap_member { use super :: runtime_types ; pub type Remove = :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > ; pub type Add = :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SwapMember { const PALLET : & 'static str = "SenateMembers" ; const CALL : & 'static str = "swap_member" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Change the membership to a new set, disregarding the existing membership. Be nice and"] # [doc = "pass `members` pre-sorted."] # [doc = ""] # [doc = "May only be called from `T::ResetOrigin`."] pub struct ResetMembers { pub members : reset_members :: Members , } pub mod reset_members { use super :: runtime_types ; pub type Members = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: subxt :: ext :: subxt_core :: utils :: AccountId32 > ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for ResetMembers { const PALLET : & 'static str = "SenateMembers" ; const CALL : & 'static str = "reset_members" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Swap out the sending member for some other key `new`."] # [doc = ""] # [doc = "May only be called from `Signed` origin of a current member."] # [doc = ""] # [doc = "Prime membership is passed from the origin account to `new`, if extant."] pub struct ChangeKey { pub new : change_key :: New , } pub mod change_key { use super :: runtime_types ; pub type New = :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for ChangeKey { const PALLET : & 'static str = "SenateMembers" ; const CALL : & 'static str = "change_key" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Set the prime member. Must be a current member."] # [doc = ""] # [doc = "May only be called from `T::PrimeOrigin`."] pub struct SetPrime { pub who : set_prime :: Who , } pub mod set_prime { use super :: runtime_types ; pub type Who = :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SetPrime { const PALLET : & 'static str = "SenateMembers" ; const CALL : & 'static str = "set_prime" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Remove the prime member if it exists."] # [doc = ""] # [doc = "May only be called from `T::PrimeOrigin`."] pub struct ClearPrime ; impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for ClearPrime { const PALLET : & 'static str = "SenateMembers" ; const CALL : & 'static str = "clear_prime" ; } } pub struct TransactionApi ; impl TransactionApi { # [doc = "Add a member `who` to the set."] # [doc = ""] # [doc = "May only be called from `T::AddOrigin`."] pub fn add_member (& self , who : types :: add_member :: Who ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: AddMember > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("SenateMembers" , "add_member" , types :: AddMember { who , } , [2u8 , 131u8 , 37u8 , 217u8 , 112u8 , 46u8 , 86u8 , 165u8 , 248u8 , 244u8 , 33u8 , 236u8 , 155u8 , 28u8 , 163u8 , 169u8 , 213u8 , 32u8 , 70u8 , 217u8 , 97u8 , 194u8 , 138u8 , 77u8 , 133u8 , 97u8 , 188u8 , 49u8 , 49u8 , 31u8 , 177u8 , 206u8 ,]) } # [doc = "Remove a member `who` from the set."] # [doc = ""] # [doc = "May only be called from `T::RemoveOrigin`."] pub fn remove_member (& self , who : types :: remove_member :: Who ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: RemoveMember > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("SenateMembers" , "remove_member" , types :: RemoveMember { who , } , [78u8 , 153u8 , 97u8 , 110u8 , 121u8 , 242u8 , 112u8 , 56u8 , 195u8 , 217u8 , 10u8 , 202u8 , 114u8 , 134u8 , 220u8 , 237u8 , 198u8 , 109u8 , 247u8 , 85u8 , 156u8 , 88u8 , 138u8 , 79u8 , 189u8 , 37u8 , 230u8 , 55u8 , 1u8 , 27u8 , 89u8 , 80u8 ,]) } # [doc = "Swap out one member `remove` for another `add`."] # [doc = ""] # [doc = "May only be called from `T::SwapOrigin`."] # [doc = ""] # [doc = "Prime membership is *not* passed from `remove` to `add`, if extant."] pub fn swap_member (& self , remove : types :: swap_member :: Remove , add : types :: swap_member :: Add ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SwapMember > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("SenateMembers" , "swap_member" , types :: SwapMember { remove , add , } , [170u8 , 68u8 , 212u8 , 185u8 , 186u8 , 38u8 , 222u8 , 227u8 , 255u8 , 119u8 , 187u8 , 170u8 , 247u8 , 101u8 , 138u8 , 167u8 , 232u8 , 33u8 , 116u8 , 1u8 , 229u8 , 171u8 , 94u8 , 150u8 , 193u8 , 51u8 , 254u8 , 106u8 , 44u8 , 96u8 , 28u8 , 88u8 ,]) } # [doc = "Change the membership to a new set, disregarding the existing membership. Be nice and"] # [doc = "pass `members` pre-sorted."] # [doc = ""] # [doc = "May only be called from `T::ResetOrigin`."] pub fn reset_members (& self , members : types :: reset_members :: Members ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: ResetMembers > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("SenateMembers" , "reset_members" , types :: ResetMembers { members , } , [212u8 , 144u8 , 99u8 , 156u8 , 70u8 , 4u8 , 219u8 , 227u8 , 150u8 , 25u8 , 86u8 , 8u8 , 215u8 , 128u8 , 193u8 , 206u8 , 33u8 , 193u8 , 71u8 , 15u8 , 20u8 , 92u8 , 99u8 , 89u8 , 174u8 , 236u8 , 102u8 , 82u8 , 164u8 , 234u8 , 12u8 , 45u8 ,]) } # [doc = "Swap out the sending member for some other key `new`."] # [doc = ""] # [doc = "May only be called from `Signed` origin of a current member."] # [doc = ""] # [doc = "Prime membership is passed from the origin account to `new`, if extant."] pub fn change_key (& self , new : types :: change_key :: New ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: ChangeKey > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("SenateMembers" , "change_key" , types :: ChangeKey { new , } , [129u8 , 233u8 , 205u8 , 107u8 , 5u8 , 50u8 , 160u8 , 60u8 , 161u8 , 248u8 , 44u8 , 53u8 , 50u8 , 141u8 , 169u8 , 36u8 , 182u8 , 195u8 , 173u8 , 142u8 , 121u8 , 153u8 , 249u8 , 234u8 , 253u8 , 64u8 , 110u8 , 51u8 , 207u8 , 127u8 , 166u8 , 108u8 ,]) } # [doc = "Set the prime member. Must be a current member."] # [doc = ""] # [doc = "May only be called from `T::PrimeOrigin`."] pub fn set_prime (& self , who : types :: set_prime :: Who ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SetPrime > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("SenateMembers" , "set_prime" , types :: SetPrime { who , } , [213u8 , 60u8 , 220u8 , 4u8 , 28u8 , 111u8 , 6u8 , 128u8 , 228u8 , 150u8 , 14u8 , 182u8 , 183u8 , 94u8 , 120u8 , 238u8 , 15u8 , 241u8 , 107u8 , 152u8 , 182u8 , 33u8 , 154u8 , 203u8 , 172u8 , 217u8 , 31u8 , 212u8 , 112u8 , 158u8 , 17u8 , 188u8 ,]) } # [doc = "Remove the prime member if it exists."] # [doc = ""] # [doc = "May only be called from `T::PrimeOrigin`."] pub fn clear_prime (& self ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: ClearPrime > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("SenateMembers" , "clear_prime" , types :: ClearPrime { } , [71u8 , 213u8 , 34u8 , 23u8 , 186u8 , 63u8 , 240u8 , 216u8 , 190u8 , 251u8 , 84u8 , 109u8 , 140u8 , 137u8 , 210u8 , 211u8 , 242u8 , 231u8 , 212u8 , 133u8 , 151u8 , 125u8 , 25u8 , 46u8 , 210u8 , 53u8 , 133u8 , 222u8 , 21u8 , 107u8 , 120u8 , 52u8 ,]) } } } # [doc = "The `Event` enum of this pallet"] pub type Event = runtime_types :: pallet_membership :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The given member was added; see the transaction for who."] pub struct MemberAdded ; impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for MemberAdded { const PALLET : & 'static str = "SenateMembers" ; const EVENT : & 'static str = "MemberAdded" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The given member was removed; see the transaction for who."] pub struct MemberRemoved ; impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for MemberRemoved { const PALLET : & 'static str = "SenateMembers" ; const EVENT : & 'static str = "MemberRemoved" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Two members were swapped; see the transaction for who."] pub struct MembersSwapped ; impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for MembersSwapped { const PALLET : & 'static str = "SenateMembers" ; const EVENT : & 'static str = "MembersSwapped" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The membership was reset; see the transaction for who the new set is."] pub struct MembersReset ; impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for MembersReset { const PALLET : & 'static str = "SenateMembers" ; const EVENT : & 'static str = "MembersReset" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "One of the members' keys changed."] pub struct KeyChanged ; impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for KeyChanged { const PALLET : & 'static str = "SenateMembers" ; const EVENT : & 'static str = "KeyChanged" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Phantom member, never used."] pub struct Dummy ; impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Dummy { const PALLET : & 'static str = "SenateMembers" ; const EVENT : & 'static str = "Dummy" ; } } pub mod storage { use super :: runtime_types ; pub mod types { use super :: runtime_types ; pub mod members { use super :: runtime_types ; pub type Members = runtime_types :: bounded_collections :: bounded_vec :: BoundedVec < :: subxt :: ext :: subxt_core :: utils :: AccountId32 > ; } pub mod prime { use super :: runtime_types ; pub type Prime = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } } pub struct StorageApi ; impl StorageApi { # [doc = " The current membership, stored as an ordered Vec."] pub fn members (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: members :: Members , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SenateMembers" , "Members" , () , [109u8 , 100u8 , 14u8 , 195u8 , 213u8 , 67u8 , 44u8 , 218u8 , 84u8 , 254u8 , 76u8 , 80u8 , 210u8 , 155u8 , 155u8 , 30u8 , 18u8 , 169u8 , 195u8 , 92u8 , 208u8 , 223u8 , 242u8 , 97u8 , 147u8 , 20u8 , 168u8 , 145u8 , 254u8 , 115u8 , 225u8 , 193u8 ,]) } # [doc = " The current prime member, if one exists."] pub fn prime (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: prime :: Prime , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SenateMembers" , "Prime" , () , [72u8 , 128u8 , 214u8 , 72u8 , 78u8 , 80u8 , 100u8 , 198u8 , 114u8 , 215u8 , 59u8 , 3u8 , 103u8 , 14u8 , 152u8 , 202u8 , 12u8 , 165u8 , 224u8 , 10u8 , 41u8 , 154u8 , 77u8 , 95u8 , 116u8 , 143u8 , 250u8 , 250u8 , 176u8 , 92u8 , 238u8 , 154u8 ,]) } } } } pub mod utility { use super :: root_mod ; use super :: runtime_types ; # [doc = "The `Error` enum of this pallet."] pub type Error = runtime_types :: pallet_utility :: pallet :: Error ; # [doc = "Contains a variant per dispatchable extrinsic that this pallet has."] pub type Call = runtime_types :: pallet_utility :: pallet :: Call ; pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; pub mod types { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Send a batch of dispatch calls."] # [doc = ""] # [doc = "May be called from any origin except `None`."] # [doc = ""] # [doc = "- `calls`: The calls to be dispatched from the same origin. The number of call must not"] # [doc = "  exceed the constant: `batched_calls_limit` (available in constant metadata)."] # [doc = ""] # [doc = "If origin is root then the calls are dispatched without checking origin filter. (This"] # [doc = "includes bypassing `frame_system::Config::BaseCallFilter`)."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- O(C) where C is the number of calls to be batched."] # [doc = ""] # [doc = "This will return `Ok` in all circumstances. To determine the success of the batch, an"] # [doc = "event is deposited. If a call failed and the batch was interrupted, then the"] # [doc = "`BatchInterrupted` event is deposited, along with the number of successful calls made"] # [doc = "and the error of the failed call. If all were successful, then the `BatchCompleted`"] # [doc = "event is deposited."] pub struct Batch { pub calls : batch :: Calls , } pub mod batch { use super :: runtime_types ; pub type Calls = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < runtime_types :: node_subtensor_runtime :: RuntimeCall > ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for Batch { const PALLET : & 'static str = "Utility" ; const CALL : & 'static str = "batch" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Send a call through an indexed pseudonym of the sender."] # [doc = ""] # [doc = "Filter from origin are passed along. The call will be dispatched with an origin which"] # [doc = "use the same filter as the origin of this call."] # [doc = ""] # [doc = "NOTE: If you need to ensure that any account-based filtering is not honored (i.e."] # [doc = "because you expect `proxy` to have been used prior in the call stack and you do not want"] # [doc = "the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`"] # [doc = "in the Multisig pallet instead."] # [doc = ""] # [doc = "NOTE: Prior to version *12, this was called `as_limited_sub`."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] pub struct AsDerivative { pub index : as_derivative :: Index , pub call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < as_derivative :: Call > , } pub mod as_derivative { use super :: runtime_types ; pub type Index = :: core :: primitive :: u16 ; pub type Call = runtime_types :: node_subtensor_runtime :: RuntimeCall ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for AsDerivative { const PALLET : & 'static str = "Utility" ; const CALL : & 'static str = "as_derivative" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Send a batch of dispatch calls and atomically execute them."] # [doc = "The whole transaction will rollback and fail if any of the calls failed."] # [doc = ""] # [doc = "May be called from any origin except `None`."] # [doc = ""] # [doc = "- `calls`: The calls to be dispatched from the same origin. The number of call must not"] # [doc = "  exceed the constant: `batched_calls_limit` (available in constant metadata)."] # [doc = ""] # [doc = "If origin is root then the calls are dispatched without checking origin filter. (This"] # [doc = "includes bypassing `frame_system::Config::BaseCallFilter`)."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- O(C) where C is the number of calls to be batched."] pub struct BatchAll { pub calls : batch_all :: Calls , } pub mod batch_all { use super :: runtime_types ; pub type Calls = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < runtime_types :: node_subtensor_runtime :: RuntimeCall > ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for BatchAll { const PALLET : & 'static str = "Utility" ; const CALL : & 'static str = "batch_all" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Dispatches a function call with a provided origin."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Root_."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- O(1)."] pub struct DispatchAs { pub as_origin : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < dispatch_as :: AsOrigin > , pub call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < dispatch_as :: Call > , } pub mod dispatch_as { use super :: runtime_types ; pub type AsOrigin = runtime_types :: node_subtensor_runtime :: OriginCaller ; pub type Call = runtime_types :: node_subtensor_runtime :: RuntimeCall ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for DispatchAs { const PALLET : & 'static str = "Utility" ; const CALL : & 'static str = "dispatch_as" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Send a batch of dispatch calls."] # [doc = "Unlike `batch`, it allows errors and won't interrupt."] # [doc = ""] # [doc = "May be called from any origin except `None`."] # [doc = ""] # [doc = "- `calls`: The calls to be dispatched from the same origin. The number of call must not"] # [doc = "  exceed the constant: `batched_calls_limit` (available in constant metadata)."] # [doc = ""] # [doc = "If origin is root then the calls are dispatch without checking origin filter. (This"] # [doc = "includes bypassing `frame_system::Config::BaseCallFilter`)."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- O(C) where C is the number of calls to be batched."] pub struct ForceBatch { pub calls : force_batch :: Calls , } pub mod force_batch { use super :: runtime_types ; pub type Calls = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < runtime_types :: node_subtensor_runtime :: RuntimeCall > ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for ForceBatch { const PALLET : & 'static str = "Utility" ; const CALL : & 'static str = "force_batch" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Dispatch a function call with a specified weight."] # [doc = ""] # [doc = "This function does not check the weight of the call, and instead allows the"] # [doc = "Root origin to specify the weight of the call."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Root_."] pub struct WithWeight { pub call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < with_weight :: Call > , pub weight : with_weight :: Weight , } pub mod with_weight { use super :: runtime_types ; pub type Call = runtime_types :: node_subtensor_runtime :: RuntimeCall ; pub type Weight = runtime_types :: sp_weights :: weight_v2 :: Weight ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for WithWeight { const PALLET : & 'static str = "Utility" ; const CALL : & 'static str = "with_weight" ; } } pub struct TransactionApi ; impl TransactionApi { # [doc = "Send a batch of dispatch calls."] # [doc = ""] # [doc = "May be called from any origin except `None`."] # [doc = ""] # [doc = "- `calls`: The calls to be dispatched from the same origin. The number of call must not"] # [doc = "  exceed the constant: `batched_calls_limit` (available in constant metadata)."] # [doc = ""] # [doc = "If origin is root then the calls are dispatched without checking origin filter. (This"] # [doc = "includes bypassing `frame_system::Config::BaseCallFilter`)."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- O(C) where C is the number of calls to be batched."] # [doc = ""] # [doc = "This will return `Ok` in all circumstances. To determine the success of the batch, an"] # [doc = "event is deposited. If a call failed and the batch was interrupted, then the"] # [doc = "`BatchInterrupted` event is deposited, along with the number of successful calls made"] # [doc = "and the error of the failed call. If all were successful, then the `BatchCompleted`"] # [doc = "event is deposited."] pub fn batch (& self , calls : types :: batch :: Calls ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: Batch > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Utility" , "batch" , types :: Batch { calls , } , [135u8 , 204u8 , 43u8 , 211u8 , 186u8 , 228u8 , 227u8 , 98u8 , 242u8 , 121u8 , 90u8 , 138u8 , 217u8 , 57u8 , 169u8 , 171u8 , 91u8 , 59u8 , 254u8 , 122u8 , 112u8 , 48u8 , 221u8 , 57u8 , 159u8 , 179u8 , 117u8 , 125u8 , 171u8 , 243u8 , 12u8 , 236u8 ,]) } # [doc = "Send a call through an indexed pseudonym of the sender."] # [doc = ""] # [doc = "Filter from origin are passed along. The call will be dispatched with an origin which"] # [doc = "use the same filter as the origin of this call."] # [doc = ""] # [doc = "NOTE: If you need to ensure that any account-based filtering is not honored (i.e."] # [doc = "because you expect `proxy` to have been used prior in the call stack and you do not want"] # [doc = "the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`"] # [doc = "in the Multisig pallet instead."] # [doc = ""] # [doc = "NOTE: Prior to version *12, this was called `as_limited_sub`."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] pub fn as_derivative (& self , index : types :: as_derivative :: Index , call : types :: as_derivative :: Call ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: AsDerivative > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Utility" , "as_derivative" , types :: AsDerivative { index , call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box :: new (call) , } , [140u8 , 58u8 , 169u8 , 14u8 , 193u8 , 8u8 , 179u8 , 133u8 , 225u8 , 24u8 , 147u8 , 161u8 , 83u8 , 194u8 , 29u8 , 211u8 , 8u8 , 227u8 , 37u8 , 231u8 , 253u8 , 103u8 , 60u8 , 225u8 , 136u8 , 119u8 , 114u8 , 49u8 , 127u8 , 131u8 , 138u8 , 159u8 ,]) } # [doc = "Send a batch of dispatch calls and atomically execute them."] # [doc = "The whole transaction will rollback and fail if any of the calls failed."] # [doc = ""] # [doc = "May be called from any origin except `None`."] # [doc = ""] # [doc = "- `calls`: The calls to be dispatched from the same origin. The number of call must not"] # [doc = "  exceed the constant: `batched_calls_limit` (available in constant metadata)."] # [doc = ""] # [doc = "If origin is root then the calls are dispatched without checking origin filter. (This"] # [doc = "includes bypassing `frame_system::Config::BaseCallFilter`)."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- O(C) where C is the number of calls to be batched."] pub fn batch_all (& self , calls : types :: batch_all :: Calls ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: BatchAll > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Utility" , "batch_all" , types :: BatchAll { calls , } , [238u8 , 135u8 , 38u8 , 96u8 , 139u8 , 151u8 , 76u8 , 145u8 , 75u8 , 52u8 , 159u8 , 143u8 , 148u8 , 49u8 , 24u8 , 222u8 , 86u8 , 86u8 , 24u8 , 83u8 , 239u8 , 33u8 , 166u8 , 48u8 , 200u8 , 84u8 , 228u8 , 42u8 , 161u8 , 69u8 , 207u8 , 214u8 ,]) } # [doc = "Dispatches a function call with a provided origin."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Root_."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- O(1)."] pub fn dispatch_as (& self , as_origin : types :: dispatch_as :: AsOrigin , call : types :: dispatch_as :: Call ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: DispatchAs > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Utility" , "dispatch_as" , types :: DispatchAs { as_origin : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box :: new (as_origin) , call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box :: new (call) , } , [226u8 , 48u8 , 70u8 , 114u8 , 106u8 , 108u8 , 169u8 , 0u8 , 176u8 , 67u8 , 60u8 , 113u8 , 39u8 , 138u8 , 209u8 , 79u8 , 109u8 , 143u8 , 226u8 , 142u8 , 36u8 , 51u8 , 244u8 , 78u8 , 245u8 , 232u8 , 167u8 , 22u8 , 187u8 , 164u8 , 59u8 , 254u8 ,]) } # [doc = "Send a batch of dispatch calls."] # [doc = "Unlike `batch`, it allows errors and won't interrupt."] # [doc = ""] # [doc = "May be called from any origin except `None`."] # [doc = ""] # [doc = "- `calls`: The calls to be dispatched from the same origin. The number of call must not"] # [doc = "  exceed the constant: `batched_calls_limit` (available in constant metadata)."] # [doc = ""] # [doc = "If origin is root then the calls are dispatch without checking origin filter. (This"] # [doc = "includes bypassing `frame_system::Config::BaseCallFilter`)."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- O(C) where C is the number of calls to be batched."] pub fn force_batch (& self , calls : types :: force_batch :: Calls ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: ForceBatch > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Utility" , "force_batch" , types :: ForceBatch { calls , } , [32u8 , 115u8 , 222u8 , 216u8 , 246u8 , 72u8 , 158u8 , 148u8 , 165u8 , 3u8 , 232u8 , 206u8 , 22u8 , 166u8 , 14u8 , 120u8 , 85u8 , 168u8 , 224u8 , 173u8 , 167u8 , 109u8 , 120u8 , 49u8 , 48u8 , 80u8 , 125u8 , 2u8 , 153u8 , 133u8 , 74u8 , 130u8 ,]) } # [doc = "Dispatch a function call with a specified weight."] # [doc = ""] # [doc = "This function does not check the weight of the call, and instead allows the"] # [doc = "Root origin to specify the weight of the call."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Root_."] pub fn with_weight (& self , call : types :: with_weight :: Call , weight : types :: with_weight :: Weight ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: WithWeight > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Utility" , "with_weight" , types :: WithWeight { call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box :: new (call) , weight , } , [207u8 , 127u8 , 59u8 , 167u8 , 221u8 , 189u8 , 133u8 , 185u8 , 252u8 , 211u8 , 46u8 , 248u8 , 224u8 , 229u8 , 111u8 , 203u8 , 154u8 , 172u8 , 93u8 , 196u8 , 151u8 , 172u8 , 174u8 , 41u8 , 221u8 , 103u8 , 254u8 , 118u8 , 42u8 , 68u8 , 220u8 , 4u8 ,]) } } } # [doc = "The `Event` enum of this pallet"] pub type Event = runtime_types :: pallet_utility :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Batch of dispatches did not complete fully. Index of first failing dispatch given, as"] # [doc = "well as the error."] pub struct BatchInterrupted { pub index : batch_interrupted :: Index , pub error : batch_interrupted :: Error , } pub mod batch_interrupted { use super :: runtime_types ; pub type Index = :: core :: primitive :: u32 ; pub type Error = runtime_types :: sp_runtime :: DispatchError ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for BatchInterrupted { const PALLET : & 'static str = "Utility" ; const EVENT : & 'static str = "BatchInterrupted" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Batch of dispatches completed fully with no error."] pub struct BatchCompleted ; impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for BatchCompleted { const PALLET : & 'static str = "Utility" ; const EVENT : & 'static str = "BatchCompleted" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Batch of dispatches completed but has errors."] pub struct BatchCompletedWithErrors ; impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for BatchCompletedWithErrors { const PALLET : & 'static str = "Utility" ; const EVENT : & 'static str = "BatchCompletedWithErrors" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "A single item within a Batch of dispatches has completed with no error."] pub struct ItemCompleted ; impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for ItemCompleted { const PALLET : & 'static str = "Utility" ; const EVENT : & 'static str = "ItemCompleted" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "A single item within a Batch of dispatches has completed with error."] pub struct ItemFailed { pub error : item_failed :: Error , } pub mod item_failed { use super :: runtime_types ; pub type Error = runtime_types :: sp_runtime :: DispatchError ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for ItemFailed { const PALLET : & 'static str = "Utility" ; const EVENT : & 'static str = "ItemFailed" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "A call was dispatched."] pub struct DispatchedAs { pub result : dispatched_as :: Result , } pub mod dispatched_as { use super :: runtime_types ; pub type Result = :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for DispatchedAs { const PALLET : & 'static str = "Utility" ; const EVENT : & 'static str = "DispatchedAs" ; } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi ; impl ConstantsApi { # [doc = " The limit on the number of batched calls."] pub fn batched_calls_limit (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u32 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Utility" , "batched_calls_limit" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } } } } pub mod sudo { use super :: root_mod ; use super :: runtime_types ; # [doc = "Error for the Sudo pallet."] pub type Error = runtime_types :: pallet_sudo :: pallet :: Error ; # [doc = "Contains a variant per dispatchable extrinsic that this pallet has."] pub type Call = runtime_types :: pallet_sudo :: pallet :: Call ; pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; pub mod types { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Authenticates the sudo key and dispatches a function call with `Root` origin."] pub struct Sudo { pub call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < sudo :: Call > , } pub mod sudo { use super :: runtime_types ; pub type Call = runtime_types :: node_subtensor_runtime :: RuntimeCall ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for Sudo { const PALLET : & 'static str = "Sudo" ; const CALL : & 'static str = "sudo" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Authenticates the sudo key and dispatches a function call with `Root` origin."] # [doc = "This function does not check the weight of the call, and instead allows the"] # [doc = "Sudo user to specify the weight of the call."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] pub struct SudoUncheckedWeight { pub call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < sudo_unchecked_weight :: Call > , pub weight : sudo_unchecked_weight :: Weight , } pub mod sudo_unchecked_weight { use super :: runtime_types ; pub type Call = runtime_types :: node_subtensor_runtime :: RuntimeCall ; pub type Weight = runtime_types :: sp_weights :: weight_v2 :: Weight ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SudoUncheckedWeight { const PALLET : & 'static str = "Sudo" ; const CALL : & 'static str = "sudo_unchecked_weight" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Authenticates the current sudo key and sets the given AccountId (`new`) as the new sudo"] # [doc = "key."] pub struct SetKey { pub new : set_key :: New , } pub mod set_key { use super :: runtime_types ; pub type New = :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SetKey { const PALLET : & 'static str = "Sudo" ; const CALL : & 'static str = "set_key" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Authenticates the sudo key and dispatches a function call with `Signed` origin from"] # [doc = "a given account."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] pub struct SudoAs { pub who : sudo_as :: Who , pub call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < sudo_as :: Call > , } pub mod sudo_as { use super :: runtime_types ; pub type Who = :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > ; pub type Call = runtime_types :: node_subtensor_runtime :: RuntimeCall ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SudoAs { const PALLET : & 'static str = "Sudo" ; const CALL : & 'static str = "sudo_as" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Permanently removes the sudo key."] # [doc = ""] # [doc = "**This cannot be un-done.**"] pub struct RemoveKey ; impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for RemoveKey { const PALLET : & 'static str = "Sudo" ; const CALL : & 'static str = "remove_key" ; } } pub struct TransactionApi ; impl TransactionApi { # [doc = "Authenticates the sudo key and dispatches a function call with `Root` origin."] pub fn sudo (& self , call : types :: sudo :: Call ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: Sudo > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Sudo" , "sudo" , types :: Sudo { call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box :: new (call) , } , [41u8 , 238u8 , 226u8 , 94u8 , 35u8 , 223u8 , 125u8 , 105u8 , 141u8 , 141u8 , 157u8 , 159u8 , 42u8 , 203u8 , 2u8 , 105u8 , 251u8 , 249u8 , 252u8 , 114u8 , 61u8 , 43u8 , 116u8 , 153u8 , 151u8 , 248u8 , 139u8 , 6u8 , 65u8 , 191u8 , 13u8 , 205u8 ,]) } # [doc = "Authenticates the sudo key and dispatches a function call with `Root` origin."] # [doc = "This function does not check the weight of the call, and instead allows the"] # [doc = "Sudo user to specify the weight of the call."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] pub fn sudo_unchecked_weight (& self , call : types :: sudo_unchecked_weight :: Call , weight : types :: sudo_unchecked_weight :: Weight ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SudoUncheckedWeight > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Sudo" , "sudo_unchecked_weight" , types :: SudoUncheckedWeight { call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box :: new (call) , weight , } , [199u8 , 170u8 , 67u8 , 209u8 , 33u8 , 161u8 , 120u8 , 195u8 , 43u8 , 78u8 , 216u8 , 125u8 , 57u8 , 24u8 , 30u8 , 218u8 , 25u8 , 42u8 , 49u8 , 167u8 , 46u8 , 0u8 , 240u8 , 230u8 , 7u8 , 244u8 , 179u8 , 99u8 , 245u8 , 231u8 , 234u8 , 59u8 ,]) } # [doc = "Authenticates the current sudo key and sets the given AccountId (`new`) as the new sudo"] # [doc = "key."] pub fn set_key (& self , new : types :: set_key :: New ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SetKey > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Sudo" , "set_key" , types :: SetKey { new , } , [9u8 , 73u8 , 39u8 , 205u8 , 188u8 , 127u8 , 143u8 , 54u8 , 128u8 , 94u8 , 8u8 , 227u8 , 197u8 , 44u8 , 70u8 , 93u8 , 228u8 , 196u8 , 64u8 , 165u8 , 226u8 , 158u8 , 101u8 , 192u8 , 22u8 , 193u8 , 102u8 , 84u8 , 21u8 , 35u8 , 92u8 , 198u8 ,]) } # [doc = "Authenticates the sudo key and dispatches a function call with `Signed` origin from"] # [doc = "a given account."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] pub fn sudo_as (& self , who : types :: sudo_as :: Who , call : types :: sudo_as :: Call ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SudoAs > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Sudo" , "sudo_as" , types :: SudoAs { who , call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box :: new (call) , } , [205u8 , 200u8 , 243u8 , 115u8 , 16u8 , 225u8 , 244u8 , 178u8 , 222u8 , 88u8 , 101u8 , 239u8 , 18u8 , 69u8 , 153u8 , 132u8 , 79u8 , 134u8 , 17u8 , 148u8 , 161u8 , 244u8 , 159u8 , 189u8 , 57u8 , 197u8 , 235u8 , 240u8 , 104u8 , 127u8 , 112u8 , 187u8 ,]) } # [doc = "Permanently removes the sudo key."] # [doc = ""] # [doc = "**This cannot be un-done.**"] pub fn remove_key (& self ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: RemoveKey > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Sudo" , "remove_key" , types :: RemoveKey { } , [133u8 , 253u8 , 54u8 , 175u8 , 202u8 , 239u8 , 5u8 , 198u8 , 180u8 , 138u8 , 25u8 , 28u8 , 109u8 , 40u8 , 30u8 , 56u8 , 126u8 , 100u8 , 52u8 , 205u8 , 250u8 , 191u8 , 61u8 , 195u8 , 172u8 , 142u8 , 184u8 , 239u8 , 247u8 , 10u8 , 211u8 , 79u8 ,]) } } } # [doc = "The `Event` enum of this pallet"] pub type Event = runtime_types :: pallet_sudo :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "A sudo call just took place."] pub struct Sudid { pub sudo_result : sudid :: SudoResult , } pub mod sudid { use super :: runtime_types ; pub type SudoResult = :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Sudid { const PALLET : & 'static str = "Sudo" ; const EVENT : & 'static str = "Sudid" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The sudo key has been updated."] pub struct KeyChanged { pub old : key_changed :: Old , pub new : key_changed :: New , } pub mod key_changed { use super :: runtime_types ; pub type Old = :: core :: option :: Option < :: subxt :: ext :: subxt_core :: utils :: AccountId32 > ; pub type New = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for KeyChanged { const PALLET : & 'static str = "Sudo" ; const EVENT : & 'static str = "KeyChanged" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The key was permanently removed."] pub struct KeyRemoved ; impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for KeyRemoved { const PALLET : & 'static str = "Sudo" ; const EVENT : & 'static str = "KeyRemoved" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "A [sudo_as](Pallet::sudo_as) call just took place."] pub struct SudoAsDone { pub sudo_result : sudo_as_done :: SudoResult , } pub mod sudo_as_done { use super :: runtime_types ; pub type SudoResult = :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for SudoAsDone { const PALLET : & 'static str = "Sudo" ; const EVENT : & 'static str = "SudoAsDone" ; } } pub mod storage { use super :: runtime_types ; pub mod types { use super :: runtime_types ; pub mod key { use super :: runtime_types ; pub type Key = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } } pub struct StorageApi ; impl StorageApi { # [doc = " The `AccountId` of the sudo key."] pub fn key (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: key :: Key , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Sudo" , "Key" , () , [72u8 , 14u8 , 225u8 , 162u8 , 205u8 , 247u8 , 227u8 , 105u8 , 116u8 , 57u8 , 4u8 , 31u8 , 84u8 , 137u8 , 227u8 , 228u8 , 133u8 , 245u8 , 206u8 , 227u8 , 117u8 , 36u8 , 252u8 , 151u8 , 107u8 , 15u8 , 180u8 , 4u8 , 4u8 , 152u8 , 195u8 , 144u8 ,]) } } } } pub mod multisig { use super :: root_mod ; use super :: runtime_types ; # [doc = "The `Error` enum of this pallet."] pub type Error = runtime_types :: pallet_multisig :: pallet :: Error ; # [doc = "Contains a variant per dispatchable extrinsic that this pallet has."] pub type Call = runtime_types :: pallet_multisig :: pallet :: Call ; pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; pub mod types { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Immediately dispatch a multi-signature call using a single approval from the caller."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "- `other_signatories`: The accounts (other than the sender) who are part of the"] # [doc = "multi-signature, but do not participate in the approval process."] # [doc = "- `call`: The call to be executed."] # [doc = ""] # [doc = "Result is equivalent to the dispatched result."] # [doc = ""] # [doc = "## Complexity"] # [doc = "O(Z + C) where Z is the length of the call and C its execution weight."] pub struct AsMultiThreshold1 { pub other_signatories : as_multi_threshold1 :: OtherSignatories , pub call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < as_multi_threshold1 :: Call > , } pub mod as_multi_threshold1 { use super :: runtime_types ; pub type OtherSignatories = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: subxt :: ext :: subxt_core :: utils :: AccountId32 > ; pub type Call = runtime_types :: node_subtensor_runtime :: RuntimeCall ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for AsMultiThreshold1 { const PALLET : & 'static str = "Multisig" ; const CALL : & 'static str = "as_multi_threshold_1" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Register approval for a dispatch to be made from a deterministic composite account if"] # [doc = "approved by a total of `threshold - 1` of `other_signatories`."] # [doc = ""] # [doc = "If there are enough, then dispatch the call."] # [doc = ""] # [doc = "Payment: `DepositBase` will be reserved if this is the first approval, plus"] # [doc = "`threshold` times `DepositFactor`. It is returned once this dispatch happens or"] # [doc = "is cancelled."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "- `threshold`: The total number of approvals for this dispatch before it is executed."] # [doc = "- `other_signatories`: The accounts (other than the sender) who can approve this"] # [doc = "dispatch. May not be empty."] # [doc = "- `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is"] # [doc = "not the first approval, then it must be `Some`, with the timepoint (block number and"] # [doc = "transaction index) of the first approval transaction."] # [doc = "- `call`: The call to be executed."] # [doc = ""] # [doc = "NOTE: Unless this is the final approval, you will generally want to use"] # [doc = "`approve_as_multi` instead, since it only requires a hash of the call."] # [doc = ""] # [doc = "Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise"] # [doc = "on success, result is `Ok` and the result from the interior call, if it was executed,"] # [doc = "may be found in the deposited `MultisigExecuted` event."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(S + Z + Call)`."] # [doc = "- Up to one balance-reserve or unreserve operation."] # [doc = "- One passthrough operation, one insert, both `O(S)` where `S` is the number of"] # [doc = "  signatories. `S` is capped by `MaxSignatories`, with weight being proportional."] # [doc = "- One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len."] # [doc = "- One encode & hash, both of complexity `O(S)`."] # [doc = "- Up to one binary search and insert (`O(logS + S)`)."] # [doc = "- I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove."] # [doc = "- One event."] # [doc = "- The weight of the `call`."] # [doc = "- Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit"] # [doc = "  taken for its lifetime of `DepositBase + threshold * DepositFactor`."] pub struct AsMulti { pub threshold : as_multi :: Threshold , pub other_signatories : as_multi :: OtherSignatories , pub maybe_timepoint : as_multi :: MaybeTimepoint , pub call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < as_multi :: Call > , pub max_weight : as_multi :: MaxWeight , } pub mod as_multi { use super :: runtime_types ; pub type Threshold = :: core :: primitive :: u16 ; pub type OtherSignatories = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: subxt :: ext :: subxt_core :: utils :: AccountId32 > ; pub type MaybeTimepoint = :: core :: option :: Option < runtime_types :: pallet_multisig :: Timepoint < :: core :: primitive :: u32 > > ; pub type Call = runtime_types :: node_subtensor_runtime :: RuntimeCall ; pub type MaxWeight = runtime_types :: sp_weights :: weight_v2 :: Weight ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for AsMulti { const PALLET : & 'static str = "Multisig" ; const CALL : & 'static str = "as_multi" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Register approval for a dispatch to be made from a deterministic composite account if"] # [doc = "approved by a total of `threshold - 1` of `other_signatories`."] # [doc = ""] # [doc = "Payment: `DepositBase` will be reserved if this is the first approval, plus"] # [doc = "`threshold` times `DepositFactor`. It is returned once this dispatch happens or"] # [doc = "is cancelled."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "- `threshold`: The total number of approvals for this dispatch before it is executed."] # [doc = "- `other_signatories`: The accounts (other than the sender) who can approve this"] # [doc = "dispatch. May not be empty."] # [doc = "- `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is"] # [doc = "not the first approval, then it must be `Some`, with the timepoint (block number and"] # [doc = "transaction index) of the first approval transaction."] # [doc = "- `call_hash`: The hash of the call to be executed."] # [doc = ""] # [doc = "NOTE: If this is the final approval, you will want to use `as_multi` instead."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(S)`."] # [doc = "- Up to one balance-reserve or unreserve operation."] # [doc = "- One passthrough operation, one insert, both `O(S)` where `S` is the number of"] # [doc = "  signatories. `S` is capped by `MaxSignatories`, with weight being proportional."] # [doc = "- One encode & hash, both of complexity `O(S)`."] # [doc = "- Up to one binary search and insert (`O(logS + S)`)."] # [doc = "- I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove."] # [doc = "- One event."] # [doc = "- Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit"] # [doc = "  taken for its lifetime of `DepositBase + threshold * DepositFactor`."] pub struct ApproveAsMulti { pub threshold : approve_as_multi :: Threshold , pub other_signatories : approve_as_multi :: OtherSignatories , pub maybe_timepoint : approve_as_multi :: MaybeTimepoint , pub call_hash : approve_as_multi :: CallHash , pub max_weight : approve_as_multi :: MaxWeight , } pub mod approve_as_multi { use super :: runtime_types ; pub type Threshold = :: core :: primitive :: u16 ; pub type OtherSignatories = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: subxt :: ext :: subxt_core :: utils :: AccountId32 > ; pub type MaybeTimepoint = :: core :: option :: Option < runtime_types :: pallet_multisig :: Timepoint < :: core :: primitive :: u32 > > ; pub type CallHash = [:: core :: primitive :: u8 ; 32usize] ; pub type MaxWeight = runtime_types :: sp_weights :: weight_v2 :: Weight ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for ApproveAsMulti { const PALLET : & 'static str = "Multisig" ; const CALL : & 'static str = "approve_as_multi" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Cancel a pre-existing, on-going multisig transaction. Any deposit reserved previously"] # [doc = "for this operation will be unreserved on success."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "- `threshold`: The total number of approvals for this dispatch before it is executed."] # [doc = "- `other_signatories`: The accounts (other than the sender) who can approve this"] # [doc = "dispatch. May not be empty."] # [doc = "- `timepoint`: The timepoint (block number and transaction index) of the first approval"] # [doc = "transaction for this dispatch."] # [doc = "- `call_hash`: The hash of the call to be executed."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(S)`."] # [doc = "- Up to one balance-reserve or unreserve operation."] # [doc = "- One passthrough operation, one insert, both `O(S)` where `S` is the number of"] # [doc = "  signatories. `S` is capped by `MaxSignatories`, with weight being proportional."] # [doc = "- One encode & hash, both of complexity `O(S)`."] # [doc = "- One event."] # [doc = "- I/O: 1 read `O(S)`, one remove."] # [doc = "- Storage: removes one item."] pub struct CancelAsMulti { pub threshold : cancel_as_multi :: Threshold , pub other_signatories : cancel_as_multi :: OtherSignatories , pub timepoint : cancel_as_multi :: Timepoint , pub call_hash : cancel_as_multi :: CallHash , } pub mod cancel_as_multi { use super :: runtime_types ; pub type Threshold = :: core :: primitive :: u16 ; pub type OtherSignatories = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: subxt :: ext :: subxt_core :: utils :: AccountId32 > ; pub type Timepoint = runtime_types :: pallet_multisig :: Timepoint < :: core :: primitive :: u32 > ; pub type CallHash = [:: core :: primitive :: u8 ; 32usize] ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for CancelAsMulti { const PALLET : & 'static str = "Multisig" ; const CALL : & 'static str = "cancel_as_multi" ; } } pub struct TransactionApi ; impl TransactionApi { # [doc = "Immediately dispatch a multi-signature call using a single approval from the caller."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "- `other_signatories`: The accounts (other than the sender) who are part of the"] # [doc = "multi-signature, but do not participate in the approval process."] # [doc = "- `call`: The call to be executed."] # [doc = ""] # [doc = "Result is equivalent to the dispatched result."] # [doc = ""] # [doc = "## Complexity"] # [doc = "O(Z + C) where Z is the length of the call and C its execution weight."] pub fn as_multi_threshold_1 (& self , other_signatories : types :: as_multi_threshold1 :: OtherSignatories , call : types :: as_multi_threshold1 :: Call ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: AsMultiThreshold1 > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Multisig" , "as_multi_threshold_1" , types :: AsMultiThreshold1 { other_signatories , call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box :: new (call) , } , [170u8 , 108u8 , 7u8 , 58u8 , 99u8 , 52u8 , 82u8 , 198u8 , 45u8 , 8u8 , 248u8 , 140u8 , 144u8 , 175u8 , 18u8 , 214u8 , 226u8 , 152u8 , 79u8 , 11u8 , 99u8 , 236u8 , 123u8 , 71u8 , 55u8 , 57u8 , 79u8 , 130u8 , 33u8 , 139u8 , 208u8 , 253u8 ,]) } # [doc = "Register approval for a dispatch to be made from a deterministic composite account if"] # [doc = "approved by a total of `threshold - 1` of `other_signatories`."] # [doc = ""] # [doc = "If there are enough, then dispatch the call."] # [doc = ""] # [doc = "Payment: `DepositBase` will be reserved if this is the first approval, plus"] # [doc = "`threshold` times `DepositFactor`. It is returned once this dispatch happens or"] # [doc = "is cancelled."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "- `threshold`: The total number of approvals for this dispatch before it is executed."] # [doc = "- `other_signatories`: The accounts (other than the sender) who can approve this"] # [doc = "dispatch. May not be empty."] # [doc = "- `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is"] # [doc = "not the first approval, then it must be `Some`, with the timepoint (block number and"] # [doc = "transaction index) of the first approval transaction."] # [doc = "- `call`: The call to be executed."] # [doc = ""] # [doc = "NOTE: Unless this is the final approval, you will generally want to use"] # [doc = "`approve_as_multi` instead, since it only requires a hash of the call."] # [doc = ""] # [doc = "Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise"] # [doc = "on success, result is `Ok` and the result from the interior call, if it was executed,"] # [doc = "may be found in the deposited `MultisigExecuted` event."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(S + Z + Call)`."] # [doc = "- Up to one balance-reserve or unreserve operation."] # [doc = "- One passthrough operation, one insert, both `O(S)` where `S` is the number of"] # [doc = "  signatories. `S` is capped by `MaxSignatories`, with weight being proportional."] # [doc = "- One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len."] # [doc = "- One encode & hash, both of complexity `O(S)`."] # [doc = "- Up to one binary search and insert (`O(logS + S)`)."] # [doc = "- I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove."] # [doc = "- One event."] # [doc = "- The weight of the `call`."] # [doc = "- Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit"] # [doc = "  taken for its lifetime of `DepositBase + threshold * DepositFactor`."] pub fn as_multi (& self , threshold : types :: as_multi :: Threshold , other_signatories : types :: as_multi :: OtherSignatories , maybe_timepoint : types :: as_multi :: MaybeTimepoint , call : types :: as_multi :: Call , max_weight : types :: as_multi :: MaxWeight ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: AsMulti > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Multisig" , "as_multi" , types :: AsMulti { threshold , other_signatories , maybe_timepoint , call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box :: new (call) , max_weight , } , [240u8 , 85u8 , 15u8 , 254u8 , 39u8 , 239u8 , 72u8 , 66u8 , 10u8 , 74u8 , 29u8 , 41u8 , 10u8 , 156u8 , 41u8 , 67u8 , 152u8 , 163u8 , 51u8 , 69u8 , 228u8 , 138u8 , 6u8 , 132u8 , 54u8 , 152u8 , 104u8 , 249u8 , 64u8 , 135u8 , 18u8 , 211u8 ,]) } # [doc = "Register approval for a dispatch to be made from a deterministic composite account if"] # [doc = "approved by a total of `threshold - 1` of `other_signatories`."] # [doc = ""] # [doc = "Payment: `DepositBase` will be reserved if this is the first approval, plus"] # [doc = "`threshold` times `DepositFactor`. It is returned once this dispatch happens or"] # [doc = "is cancelled."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "- `threshold`: The total number of approvals for this dispatch before it is executed."] # [doc = "- `other_signatories`: The accounts (other than the sender) who can approve this"] # [doc = "dispatch. May not be empty."] # [doc = "- `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is"] # [doc = "not the first approval, then it must be `Some`, with the timepoint (block number and"] # [doc = "transaction index) of the first approval transaction."] # [doc = "- `call_hash`: The hash of the call to be executed."] # [doc = ""] # [doc = "NOTE: If this is the final approval, you will want to use `as_multi` instead."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(S)`."] # [doc = "- Up to one balance-reserve or unreserve operation."] # [doc = "- One passthrough operation, one insert, both `O(S)` where `S` is the number of"] # [doc = "  signatories. `S` is capped by `MaxSignatories`, with weight being proportional."] # [doc = "- One encode & hash, both of complexity `O(S)`."] # [doc = "- Up to one binary search and insert (`O(logS + S)`)."] # [doc = "- I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove."] # [doc = "- One event."] # [doc = "- Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit"] # [doc = "  taken for its lifetime of `DepositBase + threshold * DepositFactor`."] pub fn approve_as_multi (& self , threshold : types :: approve_as_multi :: Threshold , other_signatories : types :: approve_as_multi :: OtherSignatories , maybe_timepoint : types :: approve_as_multi :: MaybeTimepoint , call_hash : types :: approve_as_multi :: CallHash , max_weight : types :: approve_as_multi :: MaxWeight ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: ApproveAsMulti > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Multisig" , "approve_as_multi" , types :: ApproveAsMulti { threshold , other_signatories , maybe_timepoint , call_hash , max_weight , } , [248u8 , 46u8 , 131u8 , 35u8 , 204u8 , 12u8 , 218u8 , 150u8 , 88u8 , 131u8 , 89u8 , 13u8 , 95u8 , 122u8 , 87u8 , 107u8 , 136u8 , 154u8 , 92u8 , 199u8 , 108u8 , 92u8 , 207u8 , 171u8 , 113u8 , 8u8 , 47u8 , 248u8 , 65u8 , 26u8 , 203u8 , 135u8 ,]) } # [doc = "Cancel a pre-existing, on-going multisig transaction. Any deposit reserved previously"] # [doc = "for this operation will be unreserved on success."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "- `threshold`: The total number of approvals for this dispatch before it is executed."] # [doc = "- `other_signatories`: The accounts (other than the sender) who can approve this"] # [doc = "dispatch. May not be empty."] # [doc = "- `timepoint`: The timepoint (block number and transaction index) of the first approval"] # [doc = "transaction for this dispatch."] # [doc = "- `call_hash`: The hash of the call to be executed."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(S)`."] # [doc = "- Up to one balance-reserve or unreserve operation."] # [doc = "- One passthrough operation, one insert, both `O(S)` where `S` is the number of"] # [doc = "  signatories. `S` is capped by `MaxSignatories`, with weight being proportional."] # [doc = "- One encode & hash, both of complexity `O(S)`."] # [doc = "- One event."] # [doc = "- I/O: 1 read `O(S)`, one remove."] # [doc = "- Storage: removes one item."] pub fn cancel_as_multi (& self , threshold : types :: cancel_as_multi :: Threshold , other_signatories : types :: cancel_as_multi :: OtherSignatories , timepoint : types :: cancel_as_multi :: Timepoint , call_hash : types :: cancel_as_multi :: CallHash ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: CancelAsMulti > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Multisig" , "cancel_as_multi" , types :: CancelAsMulti { threshold , other_signatories , timepoint , call_hash , } , [212u8 , 179u8 , 123u8 , 40u8 , 209u8 , 228u8 , 181u8 , 0u8 , 109u8 , 28u8 , 27u8 , 48u8 , 15u8 , 47u8 , 203u8 , 54u8 , 106u8 , 114u8 , 28u8 , 118u8 , 101u8 , 201u8 , 95u8 , 187u8 , 46u8 , 182u8 , 4u8 , 30u8 , 227u8 , 105u8 , 14u8 , 81u8 ,]) } } } # [doc = "The `Event` enum of this pallet"] pub type Event = runtime_types :: pallet_multisig :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "A new multisig operation has begun."] pub struct NewMultisig { pub approving : new_multisig :: Approving , pub multisig : new_multisig :: Multisig , pub call_hash : new_multisig :: CallHash , } pub mod new_multisig { use super :: runtime_types ; pub type Approving = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Multisig = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type CallHash = [:: core :: primitive :: u8 ; 32usize] ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for NewMultisig { const PALLET : & 'static str = "Multisig" ; const EVENT : & 'static str = "NewMultisig" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "A multisig operation has been approved by someone."] pub struct MultisigApproval { pub approving : multisig_approval :: Approving , pub timepoint : multisig_approval :: Timepoint , pub multisig : multisig_approval :: Multisig , pub call_hash : multisig_approval :: CallHash , } pub mod multisig_approval { use super :: runtime_types ; pub type Approving = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Timepoint = runtime_types :: pallet_multisig :: Timepoint < :: core :: primitive :: u32 > ; pub type Multisig = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type CallHash = [:: core :: primitive :: u8 ; 32usize] ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for MultisigApproval { const PALLET : & 'static str = "Multisig" ; const EVENT : & 'static str = "MultisigApproval" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "A multisig operation has been executed."] pub struct MultisigExecuted { pub approving : multisig_executed :: Approving , pub timepoint : multisig_executed :: Timepoint , pub multisig : multisig_executed :: Multisig , pub call_hash : multisig_executed :: CallHash , pub result : multisig_executed :: Result , } pub mod multisig_executed { use super :: runtime_types ; pub type Approving = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Timepoint = runtime_types :: pallet_multisig :: Timepoint < :: core :: primitive :: u32 > ; pub type Multisig = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type CallHash = [:: core :: primitive :: u8 ; 32usize] ; pub type Result = :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for MultisigExecuted { const PALLET : & 'static str = "Multisig" ; const EVENT : & 'static str = "MultisigExecuted" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "A multisig operation has been cancelled."] pub struct MultisigCancelled { pub cancelling : multisig_cancelled :: Cancelling , pub timepoint : multisig_cancelled :: Timepoint , pub multisig : multisig_cancelled :: Multisig , pub call_hash : multisig_cancelled :: CallHash , } pub mod multisig_cancelled { use super :: runtime_types ; pub type Cancelling = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Timepoint = runtime_types :: pallet_multisig :: Timepoint < :: core :: primitive :: u32 > ; pub type Multisig = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type CallHash = [:: core :: primitive :: u8 ; 32usize] ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for MultisigCancelled { const PALLET : & 'static str = "Multisig" ; const EVENT : & 'static str = "MultisigCancelled" ; } } pub mod storage { use super :: runtime_types ; pub mod types { use super :: runtime_types ; pub mod multisigs { use super :: runtime_types ; pub type Multisigs = runtime_types :: pallet_multisig :: Multisig < :: core :: primitive :: u32 , :: core :: primitive :: u64 , :: subxt :: ext :: subxt_core :: utils :: AccountId32 > ; pub type Param0 = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Param1 = [:: core :: primitive :: u8 ; 32usize] ; } } pub struct StorageApi ; impl StorageApi { # [doc = " The set of open multisig operations."] pub fn multisigs_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: multisigs :: Multisigs , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Multisig" , "Multisigs" , () , [208u8 , 119u8 , 103u8 , 193u8 , 220u8 , 35u8 , 173u8 , 190u8 , 239u8 , 195u8 , 81u8 , 14u8 , 114u8 , 66u8 , 251u8 , 46u8 , 29u8 , 186u8 , 184u8 , 21u8 , 202u8 , 73u8 , 249u8 , 167u8 , 204u8 , 248u8 , 106u8 , 82u8 , 138u8 , 73u8 , 9u8 , 140u8 ,]) } # [doc = " The set of open multisig operations."] pub fn multisigs_iter1 (& self , _0 : impl :: core :: borrow :: Borrow < types :: multisigs :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: multisigs :: Param0 > , types :: multisigs :: Multisigs , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Multisig" , "Multisigs" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [208u8 , 119u8 , 103u8 , 193u8 , 220u8 , 35u8 , 173u8 , 190u8 , 239u8 , 195u8 , 81u8 , 14u8 , 114u8 , 66u8 , 251u8 , 46u8 , 29u8 , 186u8 , 184u8 , 21u8 , 202u8 , 73u8 , 249u8 , 167u8 , 204u8 , 248u8 , 106u8 , 82u8 , 138u8 , 73u8 , 9u8 , 140u8 ,]) } # [doc = " The set of open multisig operations."] pub fn multisigs (& self , _0 : impl :: core :: borrow :: Borrow < types :: multisigs :: Param0 > , _1 : impl :: core :: borrow :: Borrow < types :: multisigs :: Param1 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < (:: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: multisigs :: Param0 > , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: multisigs :: Param1 > ,) , types :: multisigs :: Multisigs , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Multisig" , "Multisigs" , (:: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_1 . borrow ()) ,) , [208u8 , 119u8 , 103u8 , 193u8 , 220u8 , 35u8 , 173u8 , 190u8 , 239u8 , 195u8 , 81u8 , 14u8 , 114u8 , 66u8 , 251u8 , 46u8 , 29u8 , 186u8 , 184u8 , 21u8 , 202u8 , 73u8 , 249u8 , 167u8 , 204u8 , 248u8 , 106u8 , 82u8 , 138u8 , 73u8 , 9u8 , 140u8 ,]) } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi ; impl ConstantsApi { # [doc = " The base amount of currency needed to reserve for creating a multisig execution or to"] # [doc = " store a dispatch call for later."] # [doc = ""] # [doc = " This is held for an additional storage item whose value size is"] # [doc = " `4 + sizeof((BlockNumber, Balance, AccountId))` bytes and whose key size is"] # [doc = " `32 + sizeof(AccountId)` bytes."] pub fn deposit_base (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u64 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Multisig" , "DepositBase" , [128u8 , 214u8 , 205u8 , 242u8 , 181u8 , 142u8 , 124u8 , 231u8 , 190u8 , 146u8 , 59u8 , 226u8 , 157u8 , 101u8 , 103u8 , 117u8 , 249u8 , 65u8 , 18u8 , 191u8 , 103u8 , 119u8 , 53u8 , 85u8 , 81u8 , 96u8 , 220u8 , 42u8 , 184u8 , 239u8 , 42u8 , 246u8 ,]) } # [doc = " The amount of currency needed per unit threshold when creating a multisig execution."] # [doc = ""] # [doc = " This is held for adding 32 bytes more into a pre-existing storage value."] pub fn deposit_factor (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u64 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Multisig" , "DepositFactor" , [128u8 , 214u8 , 205u8 , 242u8 , 181u8 , 142u8 , 124u8 , 231u8 , 190u8 , 146u8 , 59u8 , 226u8 , 157u8 , 101u8 , 103u8 , 117u8 , 249u8 , 65u8 , 18u8 , 191u8 , 103u8 , 119u8 , 53u8 , 85u8 , 81u8 , 96u8 , 220u8 , 42u8 , 184u8 , 239u8 , 42u8 , 246u8 ,]) } # [doc = " The maximum amount of signatories allowed in the multisig."] pub fn max_signatories (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u32 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Multisig" , "MaxSignatories" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } } } } pub mod preimage { use super :: root_mod ; use super :: runtime_types ; # [doc = "The `Error` enum of this pallet."] pub type Error = runtime_types :: pallet_preimage :: pallet :: Error ; # [doc = "Contains a variant per dispatchable extrinsic that this pallet has."] pub type Call = runtime_types :: pallet_preimage :: pallet :: Call ; pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; pub mod types { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Register a preimage on-chain."] # [doc = ""] # [doc = "If the preimage was previously requested, no fees or deposits are taken for providing"] # [doc = "the preimage. Otherwise, a deposit is taken proportional to the size of the preimage."] pub struct NotePreimage { pub bytes : note_preimage :: Bytes , } pub mod note_preimage { use super :: runtime_types ; pub type Bytes = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for NotePreimage { const PALLET : & 'static str = "Preimage" ; const CALL : & 'static str = "note_preimage" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Clear an unrequested preimage from the runtime storage."] # [doc = ""] # [doc = "If `len` is provided, then it will be a much cheaper operation."] # [doc = ""] # [doc = "- `hash`: The hash of the preimage to be removed from the store."] # [doc = "- `len`: The length of the preimage of `hash`."] pub struct UnnotePreimage { pub hash : unnote_preimage :: Hash , } pub mod unnote_preimage { use super :: runtime_types ; pub type Hash = :: subxt :: ext :: subxt_core :: utils :: H256 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for UnnotePreimage { const PALLET : & 'static str = "Preimage" ; const CALL : & 'static str = "unnote_preimage" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Request a preimage be uploaded to the chain without paying any fees or deposits."] # [doc = ""] # [doc = "If the preimage requests has already been provided on-chain, we unreserve any deposit"] # [doc = "a user may have paid, and take the control of the preimage out of their hands."] pub struct RequestPreimage { pub hash : request_preimage :: Hash , } pub mod request_preimage { use super :: runtime_types ; pub type Hash = :: subxt :: ext :: subxt_core :: utils :: H256 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for RequestPreimage { const PALLET : & 'static str = "Preimage" ; const CALL : & 'static str = "request_preimage" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Clear a previously made request for a preimage."] # [doc = ""] # [doc = "NOTE: THIS MUST NOT BE CALLED ON `hash` MORE TIMES THAN `request_preimage`."] pub struct UnrequestPreimage { pub hash : unrequest_preimage :: Hash , } pub mod unrequest_preimage { use super :: runtime_types ; pub type Hash = :: subxt :: ext :: subxt_core :: utils :: H256 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for UnrequestPreimage { const PALLET : & 'static str = "Preimage" ; const CALL : & 'static str = "unrequest_preimage" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Ensure that the a bulk of pre-images is upgraded."] # [doc = ""] # [doc = "The caller pays no fee if at least 90% of pre-images were successfully updated."] pub struct EnsureUpdated { pub hashes : ensure_updated :: Hashes , } pub mod ensure_updated { use super :: runtime_types ; pub type Hashes = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: subxt :: ext :: subxt_core :: utils :: H256 > ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for EnsureUpdated { const PALLET : & 'static str = "Preimage" ; const CALL : & 'static str = "ensure_updated" ; } } pub struct TransactionApi ; impl TransactionApi { # [doc = "Register a preimage on-chain."] # [doc = ""] # [doc = "If the preimage was previously requested, no fees or deposits are taken for providing"] # [doc = "the preimage. Otherwise, a deposit is taken proportional to the size of the preimage."] pub fn note_preimage (& self , bytes : types :: note_preimage :: Bytes ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: NotePreimage > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Preimage" , "note_preimage" , types :: NotePreimage { bytes , } , [121u8 , 88u8 , 18u8 , 92u8 , 176u8 , 15u8 , 192u8 , 198u8 , 146u8 , 198u8 , 38u8 , 242u8 , 213u8 , 83u8 , 7u8 , 230u8 , 14u8 , 110u8 , 235u8 , 32u8 , 215u8 , 26u8 , 192u8 , 217u8 , 113u8 , 224u8 , 206u8 , 96u8 , 177u8 , 198u8 , 246u8 , 33u8 ,]) } # [doc = "Clear an unrequested preimage from the runtime storage."] # [doc = ""] # [doc = "If `len` is provided, then it will be a much cheaper operation."] # [doc = ""] # [doc = "- `hash`: The hash of the preimage to be removed from the store."] # [doc = "- `len`: The length of the preimage of `hash`."] pub fn unnote_preimage (& self , hash : types :: unnote_preimage :: Hash ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: UnnotePreimage > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Preimage" , "unnote_preimage" , types :: UnnotePreimage { hash , } , [188u8 , 116u8 , 222u8 , 22u8 , 127u8 , 215u8 , 2u8 , 133u8 , 96u8 , 202u8 , 190u8 , 123u8 , 203u8 , 43u8 , 200u8 , 161u8 , 226u8 , 24u8 , 49u8 , 36u8 , 221u8 , 160u8 , 130u8 , 119u8 , 30u8 , 138u8 , 144u8 , 85u8 , 5u8 , 164u8 , 252u8 , 222u8 ,]) } # [doc = "Request a preimage be uploaded to the chain without paying any fees or deposits."] # [doc = ""] # [doc = "If the preimage requests has already been provided on-chain, we unreserve any deposit"] # [doc = "a user may have paid, and take the control of the preimage out of their hands."] pub fn request_preimage (& self , hash : types :: request_preimage :: Hash ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: RequestPreimage > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Preimage" , "request_preimage" , types :: RequestPreimage { hash , } , [87u8 , 0u8 , 204u8 , 111u8 , 43u8 , 115u8 , 64u8 , 209u8 , 133u8 , 13u8 , 83u8 , 45u8 , 164u8 , 166u8 , 233u8 , 105u8 , 242u8 , 238u8 , 235u8 , 208u8 , 113u8 , 134u8 , 93u8 , 242u8 , 86u8 , 32u8 , 7u8 , 152u8 , 107u8 , 208u8 , 79u8 , 59u8 ,]) } # [doc = "Clear a previously made request for a preimage."] # [doc = ""] # [doc = "NOTE: THIS MUST NOT BE CALLED ON `hash` MORE TIMES THAN `request_preimage`."] pub fn unrequest_preimage (& self , hash : types :: unrequest_preimage :: Hash ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: UnrequestPreimage > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Preimage" , "unrequest_preimage" , types :: UnrequestPreimage { hash , } , [55u8 , 37u8 , 224u8 , 149u8 , 142u8 , 120u8 , 8u8 , 68u8 , 183u8 , 225u8 , 255u8 , 240u8 , 254u8 , 111u8 , 58u8 , 200u8 , 113u8 , 217u8 , 177u8 , 203u8 , 107u8 , 104u8 , 233u8 , 87u8 , 252u8 , 53u8 , 33u8 , 112u8 , 116u8 , 254u8 , 117u8 , 134u8 ,]) } # [doc = "Ensure that the a bulk of pre-images is upgraded."] # [doc = ""] # [doc = "The caller pays no fee if at least 90% of pre-images were successfully updated."] pub fn ensure_updated (& self , hashes : types :: ensure_updated :: Hashes ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: EnsureUpdated > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Preimage" , "ensure_updated" , types :: EnsureUpdated { hashes , } , [254u8 , 228u8 , 88u8 , 44u8 , 126u8 , 235u8 , 188u8 , 153u8 , 61u8 , 27u8 , 103u8 , 253u8 , 163u8 , 161u8 , 113u8 , 243u8 , 87u8 , 136u8 , 2u8 , 231u8 , 209u8 , 188u8 , 215u8 , 106u8 , 192u8 , 225u8 , 75u8 , 125u8 , 224u8 , 96u8 , 221u8 , 90u8 ,]) } } } # [doc = "The `Event` enum of this pallet"] pub type Event = runtime_types :: pallet_preimage :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "A preimage has been noted."] pub struct Noted { pub hash : noted :: Hash , } pub mod noted { use super :: runtime_types ; pub type Hash = :: subxt :: ext :: subxt_core :: utils :: H256 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Noted { const PALLET : & 'static str = "Preimage" ; const EVENT : & 'static str = "Noted" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "A preimage has been requested."] pub struct Requested { pub hash : requested :: Hash , } pub mod requested { use super :: runtime_types ; pub type Hash = :: subxt :: ext :: subxt_core :: utils :: H256 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Requested { const PALLET : & 'static str = "Preimage" ; const EVENT : & 'static str = "Requested" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "A preimage has ben cleared."] pub struct Cleared { pub hash : cleared :: Hash , } pub mod cleared { use super :: runtime_types ; pub type Hash = :: subxt :: ext :: subxt_core :: utils :: H256 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Cleared { const PALLET : & 'static str = "Preimage" ; const EVENT : & 'static str = "Cleared" ; } } pub mod storage { use super :: runtime_types ; pub mod types { use super :: runtime_types ; pub mod status_for { use super :: runtime_types ; pub type StatusFor = runtime_types :: pallet_preimage :: OldRequestStatus < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , :: core :: primitive :: u64 > ; pub type Param0 = :: subxt :: ext :: subxt_core :: utils :: H256 ; } pub mod request_status_for { use super :: runtime_types ; pub type RequestStatusFor = runtime_types :: pallet_preimage :: RequestStatus < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , runtime_types :: frame_support :: traits :: tokens :: fungible :: HoldConsideration > ; pub type Param0 = :: subxt :: ext :: subxt_core :: utils :: H256 ; } pub mod preimage_for { use super :: runtime_types ; pub type PreimageFor = runtime_types :: bounded_collections :: bounded_vec :: BoundedVec < :: core :: primitive :: u8 > ; pub type Param0 = :: subxt :: ext :: subxt_core :: utils :: H256 ; pub type Param1 = :: core :: primitive :: u32 ; } } pub struct StorageApi ; impl StorageApi { # [doc = " The request status of a given hash."] pub fn status_for_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: status_for :: StatusFor , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Preimage" , "StatusFor" , () , [16u8 , 95u8 , 212u8 , 193u8 , 245u8 , 56u8 , 255u8 , 183u8 , 177u8 , 15u8 , 81u8 , 194u8 , 210u8 , 12u8 , 101u8 , 227u8 , 189u8 , 125u8 , 47u8 , 186u8 , 245u8 , 94u8 , 221u8 , 238u8 , 86u8 , 130u8 , 12u8 , 82u8 , 154u8 , 114u8 , 5u8 , 63u8 ,]) } # [doc = " The request status of a given hash."] pub fn status_for (& self , _0 : impl :: core :: borrow :: Borrow < types :: status_for :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: status_for :: Param0 > , types :: status_for :: StatusFor , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Preimage" , "StatusFor" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [16u8 , 95u8 , 212u8 , 193u8 , 245u8 , 56u8 , 255u8 , 183u8 , 177u8 , 15u8 , 81u8 , 194u8 , 210u8 , 12u8 , 101u8 , 227u8 , 189u8 , 125u8 , 47u8 , 186u8 , 245u8 , 94u8 , 221u8 , 238u8 , 86u8 , 130u8 , 12u8 , 82u8 , 154u8 , 114u8 , 5u8 , 63u8 ,]) } # [doc = " The request status of a given hash."] pub fn request_status_for_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: request_status_for :: RequestStatusFor , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Preimage" , "RequestStatusFor" , () , [244u8 , 110u8 , 140u8 , 65u8 , 68u8 , 102u8 , 62u8 , 65u8 , 2u8 , 1u8 , 230u8 , 241u8 , 57u8 , 137u8 , 200u8 , 170u8 , 40u8 , 170u8 , 41u8 , 114u8 , 148u8 , 39u8 , 128u8 , 144u8 , 159u8 , 73u8 , 0u8 , 96u8 , 1u8 , 114u8 , 121u8 , 72u8 ,]) } # [doc = " The request status of a given hash."] pub fn request_status_for (& self , _0 : impl :: core :: borrow :: Borrow < types :: request_status_for :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: request_status_for :: Param0 > , types :: request_status_for :: RequestStatusFor , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Preimage" , "RequestStatusFor" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [244u8 , 110u8 , 140u8 , 65u8 , 68u8 , 102u8 , 62u8 , 65u8 , 2u8 , 1u8 , 230u8 , 241u8 , 57u8 , 137u8 , 200u8 , 170u8 , 40u8 , 170u8 , 41u8 , 114u8 , 148u8 , 39u8 , 128u8 , 144u8 , 159u8 , 73u8 , 0u8 , 96u8 , 1u8 , 114u8 , 121u8 , 72u8 ,]) } pub fn preimage_for_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: preimage_for :: PreimageFor , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Preimage" , "PreimageFor" , () , [106u8 , 5u8 , 17u8 , 46u8 , 6u8 , 184u8 , 177u8 , 113u8 , 169u8 , 34u8 , 119u8 , 141u8 , 117u8 , 40u8 , 30u8 , 94u8 , 187u8 , 35u8 , 206u8 , 216u8 , 143u8 , 208u8 , 49u8 , 156u8 , 200u8 , 255u8 , 109u8 , 200u8 , 210u8 , 134u8 , 24u8 , 139u8 ,]) } pub fn preimage_for_iter1 (& self , _0 : impl :: core :: borrow :: Borrow < types :: preimage_for :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: preimage_for :: Param0 > , types :: preimage_for :: PreimageFor , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Preimage" , "PreimageFor" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [106u8 , 5u8 , 17u8 , 46u8 , 6u8 , 184u8 , 177u8 , 113u8 , 169u8 , 34u8 , 119u8 , 141u8 , 117u8 , 40u8 , 30u8 , 94u8 , 187u8 , 35u8 , 206u8 , 216u8 , 143u8 , 208u8 , 49u8 , 156u8 , 200u8 , 255u8 , 109u8 , 200u8 , 210u8 , 134u8 , 24u8 , 139u8 ,]) } pub fn preimage_for (& self , _0 : impl :: core :: borrow :: Borrow < types :: preimage_for :: Param0 > , _1 : impl :: core :: borrow :: Borrow < types :: preimage_for :: Param1 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < (:: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: preimage_for :: Param0 > , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: preimage_for :: Param1 > ,) , types :: preimage_for :: PreimageFor , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Preimage" , "PreimageFor" , (:: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_1 . borrow ()) ,) , [106u8 , 5u8 , 17u8 , 46u8 , 6u8 , 184u8 , 177u8 , 113u8 , 169u8 , 34u8 , 119u8 , 141u8 , 117u8 , 40u8 , 30u8 , 94u8 , 187u8 , 35u8 , 206u8 , 216u8 , 143u8 , 208u8 , 49u8 , 156u8 , 200u8 , 255u8 , 109u8 , 200u8 , 210u8 , 134u8 , 24u8 , 139u8 ,]) } } } } pub mod scheduler { use super :: root_mod ; use super :: runtime_types ; # [doc = "The `Error` enum of this pallet."] pub type Error = runtime_types :: pallet_scheduler :: pallet :: Error ; # [doc = "Contains a variant per dispatchable extrinsic that this pallet has."] pub type Call = runtime_types :: pallet_scheduler :: pallet :: Call ; pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; pub mod types { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Anonymously schedule a task."] pub struct Schedule { pub when : schedule :: When , pub maybe_periodic : schedule :: MaybePeriodic , pub priority : schedule :: Priority , pub call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < schedule :: Call > , } pub mod schedule { use super :: runtime_types ; pub type When = :: core :: primitive :: u32 ; pub type MaybePeriodic = :: core :: option :: Option < (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) > ; pub type Priority = :: core :: primitive :: u8 ; pub type Call = runtime_types :: node_subtensor_runtime :: RuntimeCall ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for Schedule { const PALLET : & 'static str = "Scheduler" ; const CALL : & 'static str = "schedule" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Cancel an anonymously scheduled task."] pub struct Cancel { pub when : cancel :: When , pub index : cancel :: Index , } pub mod cancel { use super :: runtime_types ; pub type When = :: core :: primitive :: u32 ; pub type Index = :: core :: primitive :: u32 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for Cancel { const PALLET : & 'static str = "Scheduler" ; const CALL : & 'static str = "cancel" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Schedule a named task."] pub struct ScheduleNamed { pub id : schedule_named :: Id , pub when : schedule_named :: When , pub maybe_periodic : schedule_named :: MaybePeriodic , pub priority : schedule_named :: Priority , pub call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < schedule_named :: Call > , } pub mod schedule_named { use super :: runtime_types ; pub type Id = [:: core :: primitive :: u8 ; 32usize] ; pub type When = :: core :: primitive :: u32 ; pub type MaybePeriodic = :: core :: option :: Option < (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) > ; pub type Priority = :: core :: primitive :: u8 ; pub type Call = runtime_types :: node_subtensor_runtime :: RuntimeCall ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for ScheduleNamed { const PALLET : & 'static str = "Scheduler" ; const CALL : & 'static str = "schedule_named" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Cancel a named scheduled task."] pub struct CancelNamed { pub id : cancel_named :: Id , } pub mod cancel_named { use super :: runtime_types ; pub type Id = [:: core :: primitive :: u8 ; 32usize] ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for CancelNamed { const PALLET : & 'static str = "Scheduler" ; const CALL : & 'static str = "cancel_named" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Anonymously schedule a task after a delay."] pub struct ScheduleAfter { pub after : schedule_after :: After , pub maybe_periodic : schedule_after :: MaybePeriodic , pub priority : schedule_after :: Priority , pub call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < schedule_after :: Call > , } pub mod schedule_after { use super :: runtime_types ; pub type After = :: core :: primitive :: u32 ; pub type MaybePeriodic = :: core :: option :: Option < (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) > ; pub type Priority = :: core :: primitive :: u8 ; pub type Call = runtime_types :: node_subtensor_runtime :: RuntimeCall ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for ScheduleAfter { const PALLET : & 'static str = "Scheduler" ; const CALL : & 'static str = "schedule_after" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Schedule a named task after a delay."] pub struct ScheduleNamedAfter { pub id : schedule_named_after :: Id , pub after : schedule_named_after :: After , pub maybe_periodic : schedule_named_after :: MaybePeriodic , pub priority : schedule_named_after :: Priority , pub call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < schedule_named_after :: Call > , } pub mod schedule_named_after { use super :: runtime_types ; pub type Id = [:: core :: primitive :: u8 ; 32usize] ; pub type After = :: core :: primitive :: u32 ; pub type MaybePeriodic = :: core :: option :: Option < (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) > ; pub type Priority = :: core :: primitive :: u8 ; pub type Call = runtime_types :: node_subtensor_runtime :: RuntimeCall ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for ScheduleNamedAfter { const PALLET : & 'static str = "Scheduler" ; const CALL : & 'static str = "schedule_named_after" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Set a retry configuration for a task so that, in case its scheduled run fails, it will"] # [doc = "be retried after `period` blocks, for a total amount of `retries` retries or until it"] # [doc = "succeeds."] # [doc = ""] # [doc = "Tasks which need to be scheduled for a retry are still subject to weight metering and"] # [doc = "agenda space, same as a regular task. If a periodic task fails, it will be scheduled"] # [doc = "normally while the task is retrying."] # [doc = ""] # [doc = "Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic"] # [doc = "clones of the original task. Their retry configuration will be derived from the"] # [doc = "original task's configuration, but will have a lower value for `remaining` than the"] # [doc = "original `total_retries`."] pub struct SetRetry { pub task : set_retry :: Task , pub retries : set_retry :: Retries , pub period : set_retry :: Period , } pub mod set_retry { use super :: runtime_types ; pub type Task = (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) ; pub type Retries = :: core :: primitive :: u8 ; pub type Period = :: core :: primitive :: u32 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SetRetry { const PALLET : & 'static str = "Scheduler" ; const CALL : & 'static str = "set_retry" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Set a retry configuration for a named task so that, in case its scheduled run fails, it"] # [doc = "will be retried after `period` blocks, for a total amount of `retries` retries or until"] # [doc = "it succeeds."] # [doc = ""] # [doc = "Tasks which need to be scheduled for a retry are still subject to weight metering and"] # [doc = "agenda space, same as a regular task. If a periodic task fails, it will be scheduled"] # [doc = "normally while the task is retrying."] # [doc = ""] # [doc = "Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic"] # [doc = "clones of the original task. Their retry configuration will be derived from the"] # [doc = "original task's configuration, but will have a lower value for `remaining` than the"] # [doc = "original `total_retries`."] pub struct SetRetryNamed { pub id : set_retry_named :: Id , pub retries : set_retry_named :: Retries , pub period : set_retry_named :: Period , } pub mod set_retry_named { use super :: runtime_types ; pub type Id = [:: core :: primitive :: u8 ; 32usize] ; pub type Retries = :: core :: primitive :: u8 ; pub type Period = :: core :: primitive :: u32 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SetRetryNamed { const PALLET : & 'static str = "Scheduler" ; const CALL : & 'static str = "set_retry_named" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Removes the retry configuration of a task."] pub struct CancelRetry { pub task : cancel_retry :: Task , } pub mod cancel_retry { use super :: runtime_types ; pub type Task = (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for CancelRetry { const PALLET : & 'static str = "Scheduler" ; const CALL : & 'static str = "cancel_retry" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Cancel the retry configuration of a named task."] pub struct CancelRetryNamed { pub id : cancel_retry_named :: Id , } pub mod cancel_retry_named { use super :: runtime_types ; pub type Id = [:: core :: primitive :: u8 ; 32usize] ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for CancelRetryNamed { const PALLET : & 'static str = "Scheduler" ; const CALL : & 'static str = "cancel_retry_named" ; } } pub struct TransactionApi ; impl TransactionApi { # [doc = "Anonymously schedule a task."] pub fn schedule (& self , when : types :: schedule :: When , maybe_periodic : types :: schedule :: MaybePeriodic , priority : types :: schedule :: Priority , call : types :: schedule :: Call ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: Schedule > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Scheduler" , "schedule" , types :: Schedule { when , maybe_periodic , priority , call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box :: new (call) , } , [77u8 , 179u8 , 105u8 , 158u8 , 168u8 , 70u8 , 236u8 , 86u8 , 65u8 , 75u8 , 4u8 , 76u8 , 70u8 , 95u8 , 92u8 , 184u8 , 233u8 , 23u8 , 207u8 , 249u8 , 38u8 , 5u8 , 65u8 , 204u8 , 28u8 , 39u8 , 128u8 , 255u8 , 136u8 , 188u8 , 85u8 , 9u8 ,]) } # [doc = "Cancel an anonymously scheduled task."] pub fn cancel (& self , when : types :: cancel :: When , index : types :: cancel :: Index ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: Cancel > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Scheduler" , "cancel" , types :: Cancel { when , index , } , [183u8 , 204u8 , 143u8 , 86u8 , 17u8 , 130u8 , 132u8 , 91u8 , 133u8 , 168u8 , 103u8 , 129u8 , 114u8 , 56u8 , 123u8 , 42u8 , 123u8 , 120u8 , 221u8 , 211u8 , 26u8 , 85u8 , 82u8 , 246u8 , 192u8 , 39u8 , 254u8 , 45u8 , 147u8 , 56u8 , 178u8 , 133u8 ,]) } # [doc = "Schedule a named task."] pub fn schedule_named (& self , id : types :: schedule_named :: Id , when : types :: schedule_named :: When , maybe_periodic : types :: schedule_named :: MaybePeriodic , priority : types :: schedule_named :: Priority , call : types :: schedule_named :: Call ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: ScheduleNamed > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Scheduler" , "schedule_named" , types :: ScheduleNamed { id , when , maybe_periodic , priority , call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box :: new (call) , } , [22u8 , 161u8 , 165u8 , 142u8 , 156u8 , 216u8 , 155u8 , 247u8 , 38u8 , 13u8 , 195u8 , 20u8 , 96u8 , 253u8 , 52u8 , 212u8 , 229u8 , 14u8 , 137u8 , 2u8 , 25u8 , 2u8 , 165u8 , 242u8 , 216u8 , 81u8 , 187u8 , 22u8 , 19u8 , 111u8 , 48u8 , 25u8 ,]) } # [doc = "Cancel a named scheduled task."] pub fn cancel_named (& self , id : types :: cancel_named :: Id ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: CancelNamed > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Scheduler" , "cancel_named" , types :: CancelNamed { id , } , [205u8 , 35u8 , 28u8 , 57u8 , 224u8 , 7u8 , 49u8 , 233u8 , 236u8 , 163u8 , 93u8 , 236u8 , 103u8 , 69u8 , 65u8 , 51u8 , 121u8 , 84u8 , 9u8 , 196u8 , 147u8 , 122u8 , 227u8 , 200u8 , 181u8 , 233u8 , 62u8 , 240u8 , 174u8 , 83u8 , 129u8 , 193u8 ,]) } # [doc = "Anonymously schedule a task after a delay."] pub fn schedule_after (& self , after : types :: schedule_after :: After , maybe_periodic : types :: schedule_after :: MaybePeriodic , priority : types :: schedule_after :: Priority , call : types :: schedule_after :: Call ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: ScheduleAfter > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Scheduler" , "schedule_after" , types :: ScheduleAfter { after , maybe_periodic , priority , call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box :: new (call) , } , [105u8 , 91u8 , 44u8 , 92u8 , 158u8 , 241u8 , 98u8 , 167u8 , 179u8 , 50u8 , 66u8 , 190u8 , 99u8 , 204u8 , 175u8 , 85u8 , 112u8 , 195u8 , 229u8 , 3u8 , 47u8 , 116u8 , 227u8 , 44u8 , 218u8 , 118u8 , 12u8 , 43u8 , 74u8 , 242u8 , 65u8 , 89u8 ,]) } # [doc = "Schedule a named task after a delay."] pub fn schedule_named_after (& self , id : types :: schedule_named_after :: Id , after : types :: schedule_named_after :: After , maybe_periodic : types :: schedule_named_after :: MaybePeriodic , priority : types :: schedule_named_after :: Priority , call : types :: schedule_named_after :: Call ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: ScheduleNamedAfter > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Scheduler" , "schedule_named_after" , types :: ScheduleNamedAfter { id , after , maybe_periodic , priority , call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box :: new (call) , } , [54u8 , 236u8 , 179u8 , 135u8 , 224u8 , 233u8 , 42u8 , 73u8 , 215u8 , 194u8 , 186u8 , 31u8 , 8u8 , 120u8 , 205u8 , 173u8 , 193u8 , 175u8 , 87u8 , 138u8 , 202u8 , 107u8 , 232u8 , 161u8 , 126u8 , 149u8 , 184u8 , 35u8 , 181u8 , 180u8 , 46u8 , 224u8 ,]) } # [doc = "Set a retry configuration for a task so that, in case its scheduled run fails, it will"] # [doc = "be retried after `period` blocks, for a total amount of `retries` retries or until it"] # [doc = "succeeds."] # [doc = ""] # [doc = "Tasks which need to be scheduled for a retry are still subject to weight metering and"] # [doc = "agenda space, same as a regular task. If a periodic task fails, it will be scheduled"] # [doc = "normally while the task is retrying."] # [doc = ""] # [doc = "Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic"] # [doc = "clones of the original task. Their retry configuration will be derived from the"] # [doc = "original task's configuration, but will have a lower value for `remaining` than the"] # [doc = "original `total_retries`."] pub fn set_retry (& self , task : types :: set_retry :: Task , retries : types :: set_retry :: Retries , period : types :: set_retry :: Period ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SetRetry > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Scheduler" , "set_retry" , types :: SetRetry { task , retries , period , } , [2u8 , 242u8 , 180u8 , 69u8 , 237u8 , 168u8 , 243u8 , 93u8 , 47u8 , 222u8 , 189u8 , 74u8 , 233u8 , 106u8 , 54u8 , 40u8 , 160u8 , 61u8 , 78u8 , 138u8 , 232u8 , 20u8 , 243u8 , 17u8 , 151u8 , 194u8 , 67u8 , 200u8 , 186u8 , 192u8 , 210u8 , 214u8 ,]) } # [doc = "Set a retry configuration for a named task so that, in case its scheduled run fails, it"] # [doc = "will be retried after `period` blocks, for a total amount of `retries` retries or until"] # [doc = "it succeeds."] # [doc = ""] # [doc = "Tasks which need to be scheduled for a retry are still subject to weight metering and"] # [doc = "agenda space, same as a regular task. If a periodic task fails, it will be scheduled"] # [doc = "normally while the task is retrying."] # [doc = ""] # [doc = "Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic"] # [doc = "clones of the original task. Their retry configuration will be derived from the"] # [doc = "original task's configuration, but will have a lower value for `remaining` than the"] # [doc = "original `total_retries`."] pub fn set_retry_named (& self , id : types :: set_retry_named :: Id , retries : types :: set_retry_named :: Retries , period : types :: set_retry_named :: Period ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SetRetryNamed > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Scheduler" , "set_retry_named" , types :: SetRetryNamed { id , retries , period , } , [240u8 , 102u8 , 255u8 , 253u8 , 52u8 , 81u8 , 164u8 , 170u8 , 184u8 , 178u8 , 254u8 , 126u8 , 41u8 , 247u8 , 121u8 , 22u8 , 254u8 , 136u8 , 237u8 , 37u8 , 11u8 , 42u8 , 227u8 , 234u8 , 132u8 , 83u8 , 109u8 , 168u8 , 31u8 , 44u8 , 231u8 , 70u8 ,]) } # [doc = "Removes the retry configuration of a task."] pub fn cancel_retry (& self , task : types :: cancel_retry :: Task ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: CancelRetry > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Scheduler" , "cancel_retry" , types :: CancelRetry { task , } , [142u8 , 126u8 , 127u8 , 216u8 , 64u8 , 189u8 , 42u8 , 126u8 , 63u8 , 249u8 , 211u8 , 202u8 , 224u8 , 197u8 , 199u8 , 240u8 , 58u8 , 94u8 , 219u8 , 177u8 , 20u8 , 210u8 , 153u8 , 0u8 , 127u8 , 255u8 , 235u8 , 238u8 , 170u8 , 240u8 , 44u8 , 49u8 ,]) } # [doc = "Cancel the retry configuration of a named task."] pub fn cancel_retry_named (& self , id : types :: cancel_retry_named :: Id ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: CancelRetryNamed > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Scheduler" , "cancel_retry_named" , types :: CancelRetryNamed { id , } , [76u8 , 157u8 , 253u8 , 113u8 , 162u8 , 54u8 , 98u8 , 21u8 , 62u8 , 44u8 , 155u8 , 202u8 , 2u8 , 28u8 , 153u8 , 219u8 , 67u8 , 166u8 , 206u8 , 79u8 , 139u8 , 3u8 , 119u8 , 182u8 , 254u8 , 134u8 , 143u8 , 121u8 , 155u8 , 220u8 , 192u8 , 209u8 ,]) } } } # [doc = "Events type."] pub type Event = runtime_types :: pallet_scheduler :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Scheduled some task."] pub struct Scheduled { pub when : scheduled :: When , pub index : scheduled :: Index , } pub mod scheduled { use super :: runtime_types ; pub type When = :: core :: primitive :: u32 ; pub type Index = :: core :: primitive :: u32 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Scheduled { const PALLET : & 'static str = "Scheduler" ; const EVENT : & 'static str = "Scheduled" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Canceled some task."] pub struct Canceled { pub when : canceled :: When , pub index : canceled :: Index , } pub mod canceled { use super :: runtime_types ; pub type When = :: core :: primitive :: u32 ; pub type Index = :: core :: primitive :: u32 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Canceled { const PALLET : & 'static str = "Scheduler" ; const EVENT : & 'static str = "Canceled" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Dispatched some task."] pub struct Dispatched { pub task : dispatched :: Task , pub id : dispatched :: Id , pub result : dispatched :: Result , } pub mod dispatched { use super :: runtime_types ; pub type Task = (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) ; pub type Id = :: core :: option :: Option < [:: core :: primitive :: u8 ; 32usize] > ; pub type Result = :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Dispatched { const PALLET : & 'static str = "Scheduler" ; const EVENT : & 'static str = "Dispatched" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Set a retry configuration for some task."] pub struct RetrySet { pub task : retry_set :: Task , pub id : retry_set :: Id , pub period : retry_set :: Period , pub retries : retry_set :: Retries , } pub mod retry_set { use super :: runtime_types ; pub type Task = (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) ; pub type Id = :: core :: option :: Option < [:: core :: primitive :: u8 ; 32usize] > ; pub type Period = :: core :: primitive :: u32 ; pub type Retries = :: core :: primitive :: u8 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for RetrySet { const PALLET : & 'static str = "Scheduler" ; const EVENT : & 'static str = "RetrySet" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Cancel a retry configuration for some task."] pub struct RetryCancelled { pub task : retry_cancelled :: Task , pub id : retry_cancelled :: Id , } pub mod retry_cancelled { use super :: runtime_types ; pub type Task = (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) ; pub type Id = :: core :: option :: Option < [:: core :: primitive :: u8 ; 32usize] > ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for RetryCancelled { const PALLET : & 'static str = "Scheduler" ; const EVENT : & 'static str = "RetryCancelled" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The call for the provided hash was not found so the task has been aborted."] pub struct CallUnavailable { pub task : call_unavailable :: Task , pub id : call_unavailable :: Id , } pub mod call_unavailable { use super :: runtime_types ; pub type Task = (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) ; pub type Id = :: core :: option :: Option < [:: core :: primitive :: u8 ; 32usize] > ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for CallUnavailable { const PALLET : & 'static str = "Scheduler" ; const EVENT : & 'static str = "CallUnavailable" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The given task was unable to be renewed since the agenda is full at that block."] pub struct PeriodicFailed { pub task : periodic_failed :: Task , pub id : periodic_failed :: Id , } pub mod periodic_failed { use super :: runtime_types ; pub type Task = (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) ; pub type Id = :: core :: option :: Option < [:: core :: primitive :: u8 ; 32usize] > ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for PeriodicFailed { const PALLET : & 'static str = "Scheduler" ; const EVENT : & 'static str = "PeriodicFailed" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The given task was unable to be retried since the agenda is full at that block or there"] # [doc = "was not enough weight to reschedule it."] pub struct RetryFailed { pub task : retry_failed :: Task , pub id : retry_failed :: Id , } pub mod retry_failed { use super :: runtime_types ; pub type Task = (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) ; pub type Id = :: core :: option :: Option < [:: core :: primitive :: u8 ; 32usize] > ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for RetryFailed { const PALLET : & 'static str = "Scheduler" ; const EVENT : & 'static str = "RetryFailed" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The given task can never be executed since it is overweight."] pub struct PermanentlyOverweight { pub task : permanently_overweight :: Task , pub id : permanently_overweight :: Id , } pub mod permanently_overweight { use super :: runtime_types ; pub type Task = (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) ; pub type Id = :: core :: option :: Option < [:: core :: primitive :: u8 ; 32usize] > ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for PermanentlyOverweight { const PALLET : & 'static str = "Scheduler" ; const EVENT : & 'static str = "PermanentlyOverweight" ; } } pub mod storage { use super :: runtime_types ; pub mod types { use super :: runtime_types ; pub mod incomplete_since { use super :: runtime_types ; pub type IncompleteSince = :: core :: primitive :: u32 ; } pub mod agenda { use super :: runtime_types ; pub type Agenda = runtime_types :: bounded_collections :: bounded_vec :: BoundedVec < :: core :: option :: Option < runtime_types :: pallet_scheduler :: Scheduled < [:: core :: primitive :: u8 ; 32usize] , runtime_types :: frame_support :: traits :: preimages :: Bounded < runtime_types :: node_subtensor_runtime :: RuntimeCall , runtime_types :: sp_runtime :: traits :: BlakeTwo256 > , :: core :: primitive :: u32 , runtime_types :: node_subtensor_runtime :: OriginCaller , :: subxt :: ext :: subxt_core :: utils :: AccountId32 > > > ; pub type Param0 = :: core :: primitive :: u32 ; } pub mod retries { use super :: runtime_types ; pub type Retries = runtime_types :: pallet_scheduler :: RetryConfig < :: core :: primitive :: u32 > ; pub type Param0 = :: core :: primitive :: u32 ; pub type Param1 = :: core :: primitive :: u32 ; } pub mod lookup { use super :: runtime_types ; pub type Lookup = (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) ; pub type Param0 = [:: core :: primitive :: u8 ; 32usize] ; } } pub struct StorageApi ; impl StorageApi { pub fn incomplete_since (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: incomplete_since :: IncompleteSince , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Scheduler" , "IncompleteSince" , () , [250u8 , 83u8 , 64u8 , 167u8 , 205u8 , 59u8 , 225u8 , 97u8 , 205u8 , 12u8 , 76u8 , 130u8 , 197u8 , 4u8 , 111u8 , 208u8 , 92u8 , 217u8 , 145u8 , 119u8 , 38u8 , 135u8 , 1u8 , 242u8 , 228u8 , 143u8 , 56u8 , 25u8 , 115u8 , 233u8 , 227u8 , 66u8 ,]) } # [doc = " Items to be executed, indexed by the block number that they should be executed on."] pub fn agenda_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: agenda :: Agenda , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Scheduler" , "Agenda" , () , [83u8 , 128u8 , 245u8 , 203u8 , 151u8 , 54u8 , 165u8 , 1u8 , 206u8 , 52u8 , 241u8 , 179u8 , 206u8 , 21u8 , 38u8 , 33u8 , 145u8 , 19u8 , 171u8 , 14u8 , 215u8 , 157u8 , 252u8 , 98u8 , 5u8 , 181u8 , 3u8 , 139u8 , 102u8 , 216u8 , 135u8 , 79u8 ,]) } # [doc = " Items to be executed, indexed by the block number that they should be executed on."] pub fn agenda (& self , _0 : impl :: core :: borrow :: Borrow < types :: agenda :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: agenda :: Param0 > , types :: agenda :: Agenda , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Scheduler" , "Agenda" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [83u8 , 128u8 , 245u8 , 203u8 , 151u8 , 54u8 , 165u8 , 1u8 , 206u8 , 52u8 , 241u8 , 179u8 , 206u8 , 21u8 , 38u8 , 33u8 , 145u8 , 19u8 , 171u8 , 14u8 , 215u8 , 157u8 , 252u8 , 98u8 , 5u8 , 181u8 , 3u8 , 139u8 , 102u8 , 216u8 , 135u8 , 79u8 ,]) } # [doc = " Retry configurations for items to be executed, indexed by task address."] pub fn retries_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: retries :: Retries , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Scheduler" , "Retries" , () , [164u8 , 27u8 , 208u8 , 185u8 , 19u8 , 232u8 , 190u8 , 97u8 , 137u8 , 73u8 , 146u8 , 10u8 , 241u8 , 176u8 , 251u8 , 140u8 , 133u8 , 65u8 , 190u8 , 162u8 , 59u8 , 32u8 , 77u8 , 201u8 , 27u8 , 78u8 , 183u8 , 164u8 , 74u8 , 46u8 , 139u8 , 145u8 ,]) } # [doc = " Retry configurations for items to be executed, indexed by task address."] pub fn retries_iter1 (& self , _0 : impl :: core :: borrow :: Borrow < types :: retries :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: retries :: Param0 > , types :: retries :: Retries , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Scheduler" , "Retries" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [164u8 , 27u8 , 208u8 , 185u8 , 19u8 , 232u8 , 190u8 , 97u8 , 137u8 , 73u8 , 146u8 , 10u8 , 241u8 , 176u8 , 251u8 , 140u8 , 133u8 , 65u8 , 190u8 , 162u8 , 59u8 , 32u8 , 77u8 , 201u8 , 27u8 , 78u8 , 183u8 , 164u8 , 74u8 , 46u8 , 139u8 , 145u8 ,]) } # [doc = " Retry configurations for items to be executed, indexed by task address."] pub fn retries (& self , _0 : impl :: core :: borrow :: Borrow < types :: retries :: Param0 > , _1 : impl :: core :: borrow :: Borrow < types :: retries :: Param1 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < (:: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: retries :: Param0 > , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: retries :: Param1 > ,) , types :: retries :: Retries , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Scheduler" , "Retries" , (:: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_1 . borrow ()) ,) , [164u8 , 27u8 , 208u8 , 185u8 , 19u8 , 232u8 , 190u8 , 97u8 , 137u8 , 73u8 , 146u8 , 10u8 , 241u8 , 176u8 , 251u8 , 140u8 , 133u8 , 65u8 , 190u8 , 162u8 , 59u8 , 32u8 , 77u8 , 201u8 , 27u8 , 78u8 , 183u8 , 164u8 , 74u8 , 46u8 , 139u8 , 145u8 ,]) } # [doc = " Lookup from a name to the block number and index of the task."] # [doc = ""] # [doc = " For v3 -> v4 the previously unbounded identities are Blake2-256 hashed to form the v4"] # [doc = " identities."] pub fn lookup_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: lookup :: Lookup , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Scheduler" , "Lookup" , () , [24u8 , 87u8 , 96u8 , 127u8 , 136u8 , 205u8 , 238u8 , 174u8 , 71u8 , 110u8 , 65u8 , 98u8 , 228u8 , 167u8 , 99u8 , 71u8 , 171u8 , 186u8 , 12u8 , 218u8 , 137u8 , 70u8 , 70u8 , 228u8 , 153u8 , 111u8 , 165u8 , 114u8 , 229u8 , 136u8 , 118u8 , 131u8 ,]) } # [doc = " Lookup from a name to the block number and index of the task."] # [doc = ""] # [doc = " For v3 -> v4 the previously unbounded identities are Blake2-256 hashed to form the v4"] # [doc = " identities."] pub fn lookup (& self , _0 : impl :: core :: borrow :: Borrow < types :: lookup :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: lookup :: Param0 > , types :: lookup :: Lookup , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Scheduler" , "Lookup" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [24u8 , 87u8 , 96u8 , 127u8 , 136u8 , 205u8 , 238u8 , 174u8 , 71u8 , 110u8 , 65u8 , 98u8 , 228u8 , 167u8 , 99u8 , 71u8 , 171u8 , 186u8 , 12u8 , 218u8 , 137u8 , 70u8 , 70u8 , 228u8 , 153u8 , 111u8 , 165u8 , 114u8 , 229u8 , 136u8 , 118u8 , 131u8 ,]) } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi ; impl ConstantsApi { # [doc = " The maximum weight that may be scheduled per block for any dispatchables."] pub fn maximum_weight (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < runtime_types :: sp_weights :: weight_v2 :: Weight > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Scheduler" , "MaximumWeight" , [149u8 , 252u8 , 129u8 , 80u8 , 169u8 , 36u8 , 79u8 , 127u8 , 240u8 , 156u8 , 56u8 , 202u8 , 219u8 , 86u8 , 5u8 , 65u8 , 245u8 , 148u8 , 138u8 , 243u8 , 210u8 , 128u8 , 234u8 , 216u8 , 240u8 , 219u8 , 123u8 , 235u8 , 21u8 , 158u8 , 237u8 , 112u8 ,]) } # [doc = " The maximum number of scheduled calls in the queue for a single block."] # [doc = ""] # [doc = " NOTE:"] # [doc = " + Dependent pallets' benchmarks might require a higher limit for the setting. Set a"] # [doc = " higher limit under `runtime-benchmarks` feature."] pub fn max_scheduled_per_block (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u32 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Scheduler" , "MaxScheduledPerBlock" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } } } } pub mod proxy { use super :: root_mod ; use super :: runtime_types ; # [doc = "The `Error` enum of this pallet."] pub type Error = runtime_types :: pallet_proxy :: pallet :: Error ; # [doc = "Contains a variant per dispatchable extrinsic that this pallet has."] pub type Call = runtime_types :: pallet_proxy :: pallet :: Call ; pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; pub mod types { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Dispatch the given `call` from an account that the sender is authorised for through"] # [doc = "`add_proxy`."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "Parameters:"] # [doc = "- `real`: The account that the proxy will make a call on behalf of."] # [doc = "- `force_proxy_type`: Specify the exact proxy type to be used and checked for this call."] # [doc = "- `call`: The call to be made by the `real` account."] pub struct Proxy { pub real : proxy :: Real , pub force_proxy_type : proxy :: ForceProxyType , pub call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < proxy :: Call > , } pub mod proxy { use super :: runtime_types ; pub type Real = :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > ; pub type ForceProxyType = :: core :: option :: Option < runtime_types :: node_subtensor_runtime :: ProxyType > ; pub type Call = runtime_types :: node_subtensor_runtime :: RuntimeCall ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for Proxy { const PALLET : & 'static str = "Proxy" ; const CALL : & 'static str = "proxy" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Register a proxy account for the sender that is able to make calls on its behalf."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "Parameters:"] # [doc = "- `proxy`: The account that the `caller` would like to make a proxy."] # [doc = "- `proxy_type`: The permissions allowed for this proxy account."] # [doc = "- `delay`: The announcement period required of the initial proxy. Will generally be"] # [doc = "zero."] pub struct AddProxy { pub delegate : add_proxy :: Delegate , pub proxy_type : add_proxy :: ProxyType , pub delay : add_proxy :: Delay , } pub mod add_proxy { use super :: runtime_types ; pub type Delegate = :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > ; pub type ProxyType = runtime_types :: node_subtensor_runtime :: ProxyType ; pub type Delay = :: core :: primitive :: u32 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for AddProxy { const PALLET : & 'static str = "Proxy" ; const CALL : & 'static str = "add_proxy" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Unregister a proxy account for the sender."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "Parameters:"] # [doc = "- `proxy`: The account that the `caller` would like to remove as a proxy."] # [doc = "- `proxy_type`: The permissions currently enabled for the removed proxy account."] pub struct RemoveProxy { pub delegate : remove_proxy :: Delegate , pub proxy_type : remove_proxy :: ProxyType , pub delay : remove_proxy :: Delay , } pub mod remove_proxy { use super :: runtime_types ; pub type Delegate = :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > ; pub type ProxyType = runtime_types :: node_subtensor_runtime :: ProxyType ; pub type Delay = :: core :: primitive :: u32 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for RemoveProxy { const PALLET : & 'static str = "Proxy" ; const CALL : & 'static str = "remove_proxy" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Unregister all proxy accounts for the sender."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "WARNING: This may be called on accounts created by `pure`, however if done, then"] # [doc = "the unreserved fees will be inaccessible. **All access to this account will be lost.**"] pub struct RemoveProxies ; impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for RemoveProxies { const PALLET : & 'static str = "Proxy" ; const CALL : & 'static str = "remove_proxies" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Spawn a fresh new account that is guaranteed to be otherwise inaccessible, and"] # [doc = "initialize it with a proxy of `proxy_type` for `origin` sender."] # [doc = ""] # [doc = "Requires a `Signed` origin."] # [doc = ""] # [doc = "- `proxy_type`: The type of the proxy that the sender will be registered as over the"] # [doc = "new account. This will almost always be the most permissive `ProxyType` possible to"] # [doc = "allow for maximum flexibility."] # [doc = "- `index`: A disambiguation index, in case this is called multiple times in the same"] # [doc = "transaction (e.g. with `utility::batch`). Unless you're using `batch` you probably just"] # [doc = "want to use `0`."] # [doc = "- `delay`: The announcement period required of the initial proxy. Will generally be"] # [doc = "zero."] # [doc = ""] # [doc = "Fails with `Duplicate` if this has already been called in this transaction, from the"] # [doc = "same sender, with the same parameters."] # [doc = ""] # [doc = "Fails if there are insufficient funds to pay for deposit."] pub struct CreatePure { pub proxy_type : create_pure :: ProxyType , pub delay : create_pure :: Delay , pub index : create_pure :: Index , } pub mod create_pure { use super :: runtime_types ; pub type ProxyType = runtime_types :: node_subtensor_runtime :: ProxyType ; pub type Delay = :: core :: primitive :: u32 ; pub type Index = :: core :: primitive :: u16 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for CreatePure { const PALLET : & 'static str = "Proxy" ; const CALL : & 'static str = "create_pure" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Removes a previously spawned pure proxy."] # [doc = ""] # [doc = "WARNING: **All access to this account will be lost.** Any funds held in it will be"] # [doc = "inaccessible."] # [doc = ""] # [doc = "Requires a `Signed` origin, and the sender account must have been created by a call to"] # [doc = "`pure` with corresponding parameters."] # [doc = ""] # [doc = "- `spawner`: The account that originally called `pure` to create this account."] # [doc = "- `index`: The disambiguation index originally passed to `pure`. Probably `0`."] # [doc = "- `proxy_type`: The proxy type originally passed to `pure`."] # [doc = "- `height`: The height of the chain when the call to `pure` was processed."] # [doc = "- `ext_index`: The extrinsic index in which the call to `pure` was processed."] # [doc = ""] # [doc = "Fails with `NoPermission` in case the caller is not a previously created pure"] # [doc = "account whose `pure` call has corresponding parameters."] pub struct KillPure { pub spawner : kill_pure :: Spawner , pub proxy_type : kill_pure :: ProxyType , pub index : kill_pure :: Index , # [codec (compact)] pub height : kill_pure :: Height , # [codec (compact)] pub ext_index : kill_pure :: ExtIndex , } pub mod kill_pure { use super :: runtime_types ; pub type Spawner = :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > ; pub type ProxyType = runtime_types :: node_subtensor_runtime :: ProxyType ; pub type Index = :: core :: primitive :: u16 ; pub type Height = :: core :: primitive :: u32 ; pub type ExtIndex = :: core :: primitive :: u32 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for KillPure { const PALLET : & 'static str = "Proxy" ; const CALL : & 'static str = "kill_pure" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Publish the hash of a proxy-call that will be made in the future."] # [doc = ""] # [doc = "This must be called some number of blocks before the corresponding `proxy` is attempted"] # [doc = "if the delay associated with the proxy relationship is greater than zero."] # [doc = ""] # [doc = "No more than `MaxPending` announcements may be made at any one time."] # [doc = ""] # [doc = "This will take a deposit of `AnnouncementDepositFactor` as well as"] # [doc = "`AnnouncementDepositBase` if there are no other pending announcements."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ and a proxy of `real`."] # [doc = ""] # [doc = "Parameters:"] # [doc = "- `real`: The account that the proxy will make a call on behalf of."] # [doc = "- `call_hash`: The hash of the call to be made by the `real` account."] pub struct Announce { pub real : announce :: Real , pub call_hash : announce :: CallHash , } pub mod announce { use super :: runtime_types ; pub type Real = :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > ; pub type CallHash = :: subxt :: ext :: subxt_core :: utils :: H256 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for Announce { const PALLET : & 'static str = "Proxy" ; const CALL : & 'static str = "announce" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Remove a given announcement."] # [doc = ""] # [doc = "May be called by a proxy account to remove a call they previously announced and return"] # [doc = "the deposit."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "Parameters:"] # [doc = "- `real`: The account that the proxy will make a call on behalf of."] # [doc = "- `call_hash`: The hash of the call to be made by the `real` account."] pub struct RemoveAnnouncement { pub real : remove_announcement :: Real , pub call_hash : remove_announcement :: CallHash , } pub mod remove_announcement { use super :: runtime_types ; pub type Real = :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > ; pub type CallHash = :: subxt :: ext :: subxt_core :: utils :: H256 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for RemoveAnnouncement { const PALLET : & 'static str = "Proxy" ; const CALL : & 'static str = "remove_announcement" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Remove the given announcement of a delegate."] # [doc = ""] # [doc = "May be called by a target (proxied) account to remove a call that one of their delegates"] # [doc = "(`delegate`) has announced they want to execute. The deposit is returned."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "Parameters:"] # [doc = "- `delegate`: The account that previously announced the call."] # [doc = "- `call_hash`: The hash of the call to be made."] pub struct RejectAnnouncement { pub delegate : reject_announcement :: Delegate , pub call_hash : reject_announcement :: CallHash , } pub mod reject_announcement { use super :: runtime_types ; pub type Delegate = :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > ; pub type CallHash = :: subxt :: ext :: subxt_core :: utils :: H256 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for RejectAnnouncement { const PALLET : & 'static str = "Proxy" ; const CALL : & 'static str = "reject_announcement" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Dispatch the given `call` from an account that the sender is authorized for through"] # [doc = "`add_proxy`."] # [doc = ""] # [doc = "Removes any corresponding announcement(s)."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "Parameters:"] # [doc = "- `real`: The account that the proxy will make a call on behalf of."] # [doc = "- `force_proxy_type`: Specify the exact proxy type to be used and checked for this call."] # [doc = "- `call`: The call to be made by the `real` account."] pub struct ProxyAnnounced { pub delegate : proxy_announced :: Delegate , pub real : proxy_announced :: Real , pub force_proxy_type : proxy_announced :: ForceProxyType , pub call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < proxy_announced :: Call > , } pub mod proxy_announced { use super :: runtime_types ; pub type Delegate = :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > ; pub type Real = :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > ; pub type ForceProxyType = :: core :: option :: Option < runtime_types :: node_subtensor_runtime :: ProxyType > ; pub type Call = runtime_types :: node_subtensor_runtime :: RuntimeCall ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for ProxyAnnounced { const PALLET : & 'static str = "Proxy" ; const CALL : & 'static str = "proxy_announced" ; } } pub struct TransactionApi ; impl TransactionApi { # [doc = "Dispatch the given `call` from an account that the sender is authorised for through"] # [doc = "`add_proxy`."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "Parameters:"] # [doc = "- `real`: The account that the proxy will make a call on behalf of."] # [doc = "- `force_proxy_type`: Specify the exact proxy type to be used and checked for this call."] # [doc = "- `call`: The call to be made by the `real` account."] pub fn proxy (& self , real : types :: proxy :: Real , force_proxy_type : types :: proxy :: ForceProxyType , call : types :: proxy :: Call ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: Proxy > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Proxy" , "proxy" , types :: Proxy { real , force_proxy_type , call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box :: new (call) , } , [230u8 , 111u8 , 224u8 , 38u8 , 229u8 , 233u8 , 122u8 , 210u8 , 227u8 , 174u8 , 171u8 , 134u8 , 8u8 , 10u8 , 170u8 , 141u8 , 150u8 , 17u8 , 226u8 , 157u8 , 45u8 , 44u8 , 66u8 , 221u8 , 171u8 , 16u8 , 173u8 , 28u8 , 28u8 , 158u8 , 13u8 , 209u8 ,]) } # [doc = "Register a proxy account for the sender that is able to make calls on its behalf."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "Parameters:"] # [doc = "- `proxy`: The account that the `caller` would like to make a proxy."] # [doc = "- `proxy_type`: The permissions allowed for this proxy account."] # [doc = "- `delay`: The announcement period required of the initial proxy. Will generally be"] # [doc = "zero."] pub fn add_proxy (& self , delegate : types :: add_proxy :: Delegate , proxy_type : types :: add_proxy :: ProxyType , delay : types :: add_proxy :: Delay ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: AddProxy > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Proxy" , "add_proxy" , types :: AddProxy { delegate , proxy_type , delay , } , [30u8 , 116u8 , 240u8 , 7u8 , 0u8 , 10u8 , 51u8 , 240u8 , 240u8 , 92u8 , 244u8 , 83u8 , 157u8 , 143u8 , 42u8 , 209u8 , 191u8 , 152u8 , 194u8 , 122u8 , 127u8 , 222u8 , 243u8 , 93u8 , 120u8 , 2u8 , 229u8 , 147u8 , 157u8 , 221u8 , 249u8 , 69u8 ,]) } # [doc = "Unregister a proxy account for the sender."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "Parameters:"] # [doc = "- `proxy`: The account that the `caller` would like to remove as a proxy."] # [doc = "- `proxy_type`: The permissions currently enabled for the removed proxy account."] pub fn remove_proxy (& self , delegate : types :: remove_proxy :: Delegate , proxy_type : types :: remove_proxy :: ProxyType , delay : types :: remove_proxy :: Delay ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: RemoveProxy > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Proxy" , "remove_proxy" , types :: RemoveProxy { delegate , proxy_type , delay , } , [150u8 , 4u8 , 14u8 , 98u8 , 193u8 , 79u8 , 12u8 , 191u8 , 28u8 , 5u8 , 49u8 , 20u8 , 172u8 , 233u8 , 40u8 , 201u8 , 133u8 , 26u8 , 50u8 , 224u8 , 93u8 , 251u8 , 157u8 , 56u8 , 28u8 , 85u8 , 45u8 , 1u8 , 26u8 , 83u8 , 225u8 , 100u8 ,]) } # [doc = "Unregister all proxy accounts for the sender."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "WARNING: This may be called on accounts created by `pure`, however if done, then"] # [doc = "the unreserved fees will be inaccessible. **All access to this account will be lost.**"] pub fn remove_proxies (& self ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: RemoveProxies > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Proxy" , "remove_proxies" , types :: RemoveProxies { } , [1u8 , 126u8 , 36u8 , 227u8 , 185u8 , 34u8 , 218u8 , 236u8 , 125u8 , 231u8 , 68u8 , 185u8 , 145u8 , 63u8 , 250u8 , 225u8 , 103u8 , 3u8 , 189u8 , 37u8 , 172u8 , 195u8 , 197u8 , 216u8 , 99u8 , 210u8 , 240u8 , 162u8 , 158u8 , 132u8 , 24u8 , 6u8 ,]) } # [doc = "Spawn a fresh new account that is guaranteed to be otherwise inaccessible, and"] # [doc = "initialize it with a proxy of `proxy_type` for `origin` sender."] # [doc = ""] # [doc = "Requires a `Signed` origin."] # [doc = ""] # [doc = "- `proxy_type`: The type of the proxy that the sender will be registered as over the"] # [doc = "new account. This will almost always be the most permissive `ProxyType` possible to"] # [doc = "allow for maximum flexibility."] # [doc = "- `index`: A disambiguation index, in case this is called multiple times in the same"] # [doc = "transaction (e.g. with `utility::batch`). Unless you're using `batch` you probably just"] # [doc = "want to use `0`."] # [doc = "- `delay`: The announcement period required of the initial proxy. Will generally be"] # [doc = "zero."] # [doc = ""] # [doc = "Fails with `Duplicate` if this has already been called in this transaction, from the"] # [doc = "same sender, with the same parameters."] # [doc = ""] # [doc = "Fails if there are insufficient funds to pay for deposit."] pub fn create_pure (& self , proxy_type : types :: create_pure :: ProxyType , delay : types :: create_pure :: Delay , index : types :: create_pure :: Index ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: CreatePure > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Proxy" , "create_pure" , types :: CreatePure { proxy_type , delay , index , } , [111u8 , 104u8 , 72u8 , 221u8 , 165u8 , 158u8 , 246u8 , 15u8 , 133u8 , 200u8 , 51u8 , 198u8 , 94u8 , 214u8 , 199u8 , 60u8 , 121u8 , 210u8 , 19u8 , 70u8 , 167u8 , 228u8 , 221u8 , 76u8 , 199u8 , 160u8 , 47u8 , 242u8 , 179u8 , 163u8 , 48u8 , 124u8 ,]) } # [doc = "Removes a previously spawned pure proxy."] # [doc = ""] # [doc = "WARNING: **All access to this account will be lost.** Any funds held in it will be"] # [doc = "inaccessible."] # [doc = ""] # [doc = "Requires a `Signed` origin, and the sender account must have been created by a call to"] # [doc = "`pure` with corresponding parameters."] # [doc = ""] # [doc = "- `spawner`: The account that originally called `pure` to create this account."] # [doc = "- `index`: The disambiguation index originally passed to `pure`. Probably `0`."] # [doc = "- `proxy_type`: The proxy type originally passed to `pure`."] # [doc = "- `height`: The height of the chain when the call to `pure` was processed."] # [doc = "- `ext_index`: The extrinsic index in which the call to `pure` was processed."] # [doc = ""] # [doc = "Fails with `NoPermission` in case the caller is not a previously created pure"] # [doc = "account whose `pure` call has corresponding parameters."] pub fn kill_pure (& self , spawner : types :: kill_pure :: Spawner , proxy_type : types :: kill_pure :: ProxyType , index : types :: kill_pure :: Index , height : types :: kill_pure :: Height , ext_index : types :: kill_pure :: ExtIndex ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: KillPure > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Proxy" , "kill_pure" , types :: KillPure { spawner , proxy_type , index , height , ext_index , } , [184u8 , 221u8 , 53u8 , 121u8 , 185u8 , 2u8 , 245u8 , 19u8 , 95u8 , 228u8 , 8u8 , 137u8 , 193u8 , 149u8 , 84u8 , 159u8 , 134u8 , 32u8 , 121u8 , 245u8 , 248u8 , 10u8 , 162u8 , 48u8 , 82u8 , 138u8 , 76u8 , 142u8 , 96u8 , 35u8 , 32u8 , 118u8 ,]) } # [doc = "Publish the hash of a proxy-call that will be made in the future."] # [doc = ""] # [doc = "This must be called some number of blocks before the corresponding `proxy` is attempted"] # [doc = "if the delay associated with the proxy relationship is greater than zero."] # [doc = ""] # [doc = "No more than `MaxPending` announcements may be made at any one time."] # [doc = ""] # [doc = "This will take a deposit of `AnnouncementDepositFactor` as well as"] # [doc = "`AnnouncementDepositBase` if there are no other pending announcements."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ and a proxy of `real`."] # [doc = ""] # [doc = "Parameters:"] # [doc = "- `real`: The account that the proxy will make a call on behalf of."] # [doc = "- `call_hash`: The hash of the call to be made by the `real` account."] pub fn announce (& self , real : types :: announce :: Real , call_hash : types :: announce :: CallHash ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: Announce > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Proxy" , "announce" , types :: Announce { real , call_hash , } , [105u8 , 218u8 , 232u8 , 82u8 , 80u8 , 10u8 , 11u8 , 1u8 , 93u8 , 241u8 , 121u8 , 198u8 , 167u8 , 218u8 , 95u8 , 15u8 , 75u8 , 122u8 , 155u8 , 233u8 , 10u8 , 175u8 , 145u8 , 73u8 , 214u8 , 230u8 , 67u8 , 107u8 , 23u8 , 239u8 , 69u8 , 240u8 ,]) } # [doc = "Remove a given announcement."] # [doc = ""] # [doc = "May be called by a proxy account to remove a call they previously announced and return"] # [doc = "the deposit."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "Parameters:"] # [doc = "- `real`: The account that the proxy will make a call on behalf of."] # [doc = "- `call_hash`: The hash of the call to be made by the `real` account."] pub fn remove_announcement (& self , real : types :: remove_announcement :: Real , call_hash : types :: remove_announcement :: CallHash ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: RemoveAnnouncement > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Proxy" , "remove_announcement" , types :: RemoveAnnouncement { real , call_hash , } , [40u8 , 237u8 , 179u8 , 128u8 , 201u8 , 183u8 , 20u8 , 47u8 , 99u8 , 182u8 , 81u8 , 31u8 , 27u8 , 212u8 , 133u8 , 36u8 , 8u8 , 248u8 , 57u8 , 230u8 , 138u8 , 80u8 , 241u8 , 147u8 , 69u8 , 236u8 , 156u8 , 167u8 , 205u8 , 49u8 , 60u8 , 16u8 ,]) } # [doc = "Remove the given announcement of a delegate."] # [doc = ""] # [doc = "May be called by a target (proxied) account to remove a call that one of their delegates"] # [doc = "(`delegate`) has announced they want to execute. The deposit is returned."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "Parameters:"] # [doc = "- `delegate`: The account that previously announced the call."] # [doc = "- `call_hash`: The hash of the call to be made."] pub fn reject_announcement (& self , delegate : types :: reject_announcement :: Delegate , call_hash : types :: reject_announcement :: CallHash ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: RejectAnnouncement > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Proxy" , "reject_announcement" , types :: RejectAnnouncement { delegate , call_hash , } , [150u8 , 178u8 , 49u8 , 160u8 , 211u8 , 75u8 , 58u8 , 228u8 , 121u8 , 253u8 , 167u8 , 72u8 , 68u8 , 105u8 , 159u8 , 52u8 , 41u8 , 155u8 , 92u8 , 26u8 , 169u8 , 177u8 , 102u8 , 36u8 , 1u8 , 47u8 , 87u8 , 189u8 , 223u8 , 238u8 , 244u8 , 110u8 ,]) } # [doc = "Dispatch the given `call` from an account that the sender is authorized for through"] # [doc = "`add_proxy`."] # [doc = ""] # [doc = "Removes any corresponding announcement(s)."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "Parameters:"] # [doc = "- `real`: The account that the proxy will make a call on behalf of."] # [doc = "- `force_proxy_type`: Specify the exact proxy type to be used and checked for this call."] # [doc = "- `call`: The call to be made by the `real` account."] pub fn proxy_announced (& self , delegate : types :: proxy_announced :: Delegate , real : types :: proxy_announced :: Real , force_proxy_type : types :: proxy_announced :: ForceProxyType , call : types :: proxy_announced :: Call ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: ProxyAnnounced > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Proxy" , "proxy_announced" , types :: ProxyAnnounced { delegate , real , force_proxy_type , call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box :: new (call) , } , [3u8 , 3u8 , 47u8 , 98u8 , 214u8 , 153u8 , 22u8 , 8u8 , 150u8 , 251u8 , 136u8 , 70u8 , 184u8 , 8u8 , 127u8 , 183u8 , 170u8 , 115u8 , 196u8 , 7u8 , 15u8 , 194u8 , 85u8 , 184u8 , 103u8 , 80u8 , 40u8 , 74u8 , 49u8 , 194u8 , 240u8 , 228u8 ,]) } } } # [doc = "The `Event` enum of this pallet"] pub type Event = runtime_types :: pallet_proxy :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "A proxy was executed correctly, with the given."] pub struct ProxyExecuted { pub result : proxy_executed :: Result , } pub mod proxy_executed { use super :: runtime_types ; pub type Result = :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for ProxyExecuted { const PALLET : & 'static str = "Proxy" ; const EVENT : & 'static str = "ProxyExecuted" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "A pure account has been created by new proxy with given"] # [doc = "disambiguation index and proxy type."] pub struct PureCreated { pub pure : pure_created :: Pure , pub who : pure_created :: Who , pub proxy_type : pure_created :: ProxyType , pub disambiguation_index : pure_created :: DisambiguationIndex , } pub mod pure_created { use super :: runtime_types ; pub type Pure = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Who = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type ProxyType = runtime_types :: node_subtensor_runtime :: ProxyType ; pub type DisambiguationIndex = :: core :: primitive :: u16 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for PureCreated { const PALLET : & 'static str = "Proxy" ; const EVENT : & 'static str = "PureCreated" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "An announcement was placed to make a call in the future."] pub struct Announced { pub real : announced :: Real , pub proxy : announced :: Proxy , pub call_hash : announced :: CallHash , } pub mod announced { use super :: runtime_types ; pub type Real = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Proxy = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type CallHash = :: subxt :: ext :: subxt_core :: utils :: H256 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Announced { const PALLET : & 'static str = "Proxy" ; const EVENT : & 'static str = "Announced" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "A proxy was added."] pub struct ProxyAdded { pub delegator : proxy_added :: Delegator , pub delegatee : proxy_added :: Delegatee , pub proxy_type : proxy_added :: ProxyType , pub delay : proxy_added :: Delay , } pub mod proxy_added { use super :: runtime_types ; pub type Delegator = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Delegatee = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type ProxyType = runtime_types :: node_subtensor_runtime :: ProxyType ; pub type Delay = :: core :: primitive :: u32 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for ProxyAdded { const PALLET : & 'static str = "Proxy" ; const EVENT : & 'static str = "ProxyAdded" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "A proxy was removed."] pub struct ProxyRemoved { pub delegator : proxy_removed :: Delegator , pub delegatee : proxy_removed :: Delegatee , pub proxy_type : proxy_removed :: ProxyType , pub delay : proxy_removed :: Delay , } pub mod proxy_removed { use super :: runtime_types ; pub type Delegator = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Delegatee = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type ProxyType = runtime_types :: node_subtensor_runtime :: ProxyType ; pub type Delay = :: core :: primitive :: u32 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for ProxyRemoved { const PALLET : & 'static str = "Proxy" ; const EVENT : & 'static str = "ProxyRemoved" ; } } pub mod storage { use super :: runtime_types ; pub mod types { use super :: runtime_types ; pub mod proxies { use super :: runtime_types ; pub type Proxies = (runtime_types :: bounded_collections :: bounded_vec :: BoundedVec < runtime_types :: pallet_proxy :: ProxyDefinition < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , runtime_types :: node_subtensor_runtime :: ProxyType , :: core :: primitive :: u32 > > , :: core :: primitive :: u64 ,) ; pub type Param0 = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } pub mod announcements { use super :: runtime_types ; pub type Announcements = (runtime_types :: bounded_collections :: bounded_vec :: BoundedVec < runtime_types :: pallet_proxy :: Announcement < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , :: subxt :: ext :: subxt_core :: utils :: H256 , :: core :: primitive :: u32 > > , :: core :: primitive :: u64 ,) ; pub type Param0 = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } } pub struct StorageApi ; impl StorageApi { # [doc = " The set of account proxies. Maps the account which has delegated to the accounts"] # [doc = " which are being delegated to, together with the amount held on deposit."] pub fn proxies_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: proxies :: Proxies , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Proxy" , "Proxies" , () , [145u8 , 245u8 , 225u8 , 233u8 , 121u8 , 205u8 , 226u8 , 26u8 , 163u8 , 96u8 , 211u8 , 186u8 , 16u8 , 85u8 , 137u8 , 49u8 , 9u8 , 18u8 , 181u8 , 148u8 , 16u8 , 138u8 , 138u8 , 101u8 , 108u8 , 12u8 , 170u8 , 232u8 , 125u8 , 251u8 , 253u8 , 251u8 ,]) } # [doc = " The set of account proxies. Maps the account which has delegated to the accounts"] # [doc = " which are being delegated to, together with the amount held on deposit."] pub fn proxies (& self , _0 : impl :: core :: borrow :: Borrow < types :: proxies :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: proxies :: Param0 > , types :: proxies :: Proxies , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Proxy" , "Proxies" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [145u8 , 245u8 , 225u8 , 233u8 , 121u8 , 205u8 , 226u8 , 26u8 , 163u8 , 96u8 , 211u8 , 186u8 , 16u8 , 85u8 , 137u8 , 49u8 , 9u8 , 18u8 , 181u8 , 148u8 , 16u8 , 138u8 , 138u8 , 101u8 , 108u8 , 12u8 , 170u8 , 232u8 , 125u8 , 251u8 , 253u8 , 251u8 ,]) } # [doc = " The announcements made by the proxy (key)."] pub fn announcements_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: announcements :: Announcements , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Proxy" , "Announcements" , () , [251u8 , 80u8 , 94u8 , 70u8 , 96u8 , 57u8 , 22u8 , 10u8 , 63u8 , 93u8 , 186u8 , 160u8 , 55u8 , 117u8 , 39u8 , 125u8 , 210u8 , 52u8 , 117u8 , 94u8 , 24u8 , 109u8 , 217u8 , 55u8 , 2u8 , 30u8 , 8u8 , 177u8 , 56u8 , 155u8 , 71u8 , 227u8 ,]) } # [doc = " The announcements made by the proxy (key)."] pub fn announcements (& self , _0 : impl :: core :: borrow :: Borrow < types :: announcements :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: announcements :: Param0 > , types :: announcements :: Announcements , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Proxy" , "Announcements" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [251u8 , 80u8 , 94u8 , 70u8 , 96u8 , 57u8 , 22u8 , 10u8 , 63u8 , 93u8 , 186u8 , 160u8 , 55u8 , 117u8 , 39u8 , 125u8 , 210u8 , 52u8 , 117u8 , 94u8 , 24u8 , 109u8 , 217u8 , 55u8 , 2u8 , 30u8 , 8u8 , 177u8 , 56u8 , 155u8 , 71u8 , 227u8 ,]) } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi ; impl ConstantsApi { # [doc = " The base amount of currency needed to reserve for creating a proxy."] # [doc = ""] # [doc = " This is held for an additional storage item whose value size is"] # [doc = " `sizeof(Balance)` bytes and whose key size is `sizeof(AccountId)` bytes."] pub fn proxy_deposit_base (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u64 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Proxy" , "ProxyDepositBase" , [128u8 , 214u8 , 205u8 , 242u8 , 181u8 , 142u8 , 124u8 , 231u8 , 190u8 , 146u8 , 59u8 , 226u8 , 157u8 , 101u8 , 103u8 , 117u8 , 249u8 , 65u8 , 18u8 , 191u8 , 103u8 , 119u8 , 53u8 , 85u8 , 81u8 , 96u8 , 220u8 , 42u8 , 184u8 , 239u8 , 42u8 , 246u8 ,]) } # [doc = " The amount of currency needed per proxy added."] # [doc = ""] # [doc = " This is held for adding 32 bytes plus an instance of `ProxyType` more into a"] # [doc = " pre-existing storage value. Thus, when configuring `ProxyDepositFactor` one should take"] # [doc = " into account `32 + proxy_type.encode().len()` bytes of data."] pub fn proxy_deposit_factor (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u64 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Proxy" , "ProxyDepositFactor" , [128u8 , 214u8 , 205u8 , 242u8 , 181u8 , 142u8 , 124u8 , 231u8 , 190u8 , 146u8 , 59u8 , 226u8 , 157u8 , 101u8 , 103u8 , 117u8 , 249u8 , 65u8 , 18u8 , 191u8 , 103u8 , 119u8 , 53u8 , 85u8 , 81u8 , 96u8 , 220u8 , 42u8 , 184u8 , 239u8 , 42u8 , 246u8 ,]) } # [doc = " The maximum amount of proxies allowed for a single account."] pub fn max_proxies (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u32 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Proxy" , "MaxProxies" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " The maximum amount of time-delayed announcements that are allowed to be pending."] pub fn max_pending (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u32 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Proxy" , "MaxPending" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " The base amount of currency needed to reserve for creating an announcement."] # [doc = ""] # [doc = " This is held when a new storage item holding a `Balance` is created (typically 16"] # [doc = " bytes)."] pub fn announcement_deposit_base (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u64 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Proxy" , "AnnouncementDepositBase" , [128u8 , 214u8 , 205u8 , 242u8 , 181u8 , 142u8 , 124u8 , 231u8 , 190u8 , 146u8 , 59u8 , 226u8 , 157u8 , 101u8 , 103u8 , 117u8 , 249u8 , 65u8 , 18u8 , 191u8 , 103u8 , 119u8 , 53u8 , 85u8 , 81u8 , 96u8 , 220u8 , 42u8 , 184u8 , 239u8 , 42u8 , 246u8 ,]) } # [doc = " The amount of currency needed per announcement made."] # [doc = ""] # [doc = " This is held for adding an `AccountId`, `Hash` and `BlockNumber` (typically 68 bytes)"] # [doc = " into a pre-existing storage value."] pub fn announcement_deposit_factor (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u64 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Proxy" , "AnnouncementDepositFactor" , [128u8 , 214u8 , 205u8 , 242u8 , 181u8 , 142u8 , 124u8 , 231u8 , 190u8 , 146u8 , 59u8 , 226u8 , 157u8 , 101u8 , 103u8 , 117u8 , 249u8 , 65u8 , 18u8 , 191u8 , 103u8 , 119u8 , 53u8 , 85u8 , 81u8 , 96u8 , 220u8 , 42u8 , 184u8 , 239u8 , 42u8 , 246u8 ,]) } } } } pub mod registry { use super :: root_mod ; use super :: runtime_types ; # [doc = "The `Error` enum of this pallet."] pub type Error = runtime_types :: pallet_registry :: pallet :: Error ; # [doc = "Contains a variant per dispatchable extrinsic that this pallet has."] pub type Call = runtime_types :: pallet_registry :: pallet :: Call ; pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; pub mod types { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Register an identity for an account. This will overwrite any existing identity."] pub struct SetIdentity { pub identified : set_identity :: Identified , pub info : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < set_identity :: Info > , } pub mod set_identity { use super :: runtime_types ; pub type Identified = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Info = runtime_types :: pallet_registry :: types :: IdentityInfo ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SetIdentity { const PALLET : & 'static str = "Registry" ; const CALL : & 'static str = "set_identity" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Clear the identity of an account."] pub struct ClearIdentity { pub identified : clear_identity :: Identified , } pub mod clear_identity { use super :: runtime_types ; pub type Identified = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for ClearIdentity { const PALLET : & 'static str = "Registry" ; const CALL : & 'static str = "clear_identity" ; } } pub struct TransactionApi ; impl TransactionApi { # [doc = "Register an identity for an account. This will overwrite any existing identity."] pub fn set_identity (& self , identified : types :: set_identity :: Identified , info : types :: set_identity :: Info ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SetIdentity > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Registry" , "set_identity" , types :: SetIdentity { identified , info : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box :: new (info) , } , [255u8 , 222u8 , 188u8 , 128u8 , 170u8 , 119u8 , 134u8 , 170u8 , 42u8 , 31u8 , 3u8 , 8u8 , 53u8 , 100u8 , 198u8 , 14u8 , 115u8 , 29u8 , 228u8 , 90u8 , 39u8 , 182u8 , 215u8 , 189u8 , 29u8 , 111u8 , 230u8 , 253u8 , 89u8 , 109u8 , 191u8 , 220u8 ,]) } # [doc = "Clear the identity of an account."] pub fn clear_identity (& self , identified : types :: clear_identity :: Identified ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: ClearIdentity > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Registry" , "clear_identity" , types :: ClearIdentity { identified , } , [216u8 , 203u8 , 30u8 , 205u8 , 153u8 , 152u8 , 123u8 , 37u8 , 208u8 , 167u8 , 25u8 , 221u8 , 243u8 , 138u8 , 31u8 , 222u8 , 64u8 , 207u8 , 68u8 , 74u8 , 131u8 , 236u8 , 156u8 , 9u8 , 30u8 , 190u8 , 66u8 , 119u8 , 161u8 , 154u8 , 5u8 , 65u8 ,]) } } } # [doc = "The `Event` enum of this pallet"] pub type Event = runtime_types :: pallet_registry :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Emitted when a user registers an identity"] pub struct IdentitySet { pub who : identity_set :: Who , } pub mod identity_set { use super :: runtime_types ; pub type Who = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for IdentitySet { const PALLET : & 'static str = "Registry" ; const EVENT : & 'static str = "IdentitySet" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Emitted when a user dissolves an identity"] pub struct IdentityDissolved { pub who : identity_dissolved :: Who , } pub mod identity_dissolved { use super :: runtime_types ; pub type Who = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for IdentityDissolved { const PALLET : & 'static str = "Registry" ; const EVENT : & 'static str = "IdentityDissolved" ; } } pub mod storage { use super :: runtime_types ; pub mod types { use super :: runtime_types ; pub mod identity_of { use super :: runtime_types ; pub type IdentityOf = runtime_types :: pallet_registry :: types :: Registration < :: core :: primitive :: u64 > ; pub type Param0 = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } } pub struct StorageApi ; impl StorageApi { # [doc = " Identity data by account"] pub fn identity_of_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: identity_of :: IdentityOf , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Registry" , "IdentityOf" , () , [234u8 , 187u8 , 56u8 , 218u8 , 135u8 , 79u8 , 50u8 , 159u8 , 20u8 , 10u8 , 131u8 , 167u8 , 135u8 , 236u8 , 19u8 , 176u8 , 113u8 , 194u8 , 115u8 , 138u8 , 0u8 , 184u8 , 178u8 , 245u8 , 255u8 , 85u8 , 51u8 , 140u8 , 11u8 , 143u8 , 218u8 , 217u8 ,]) } # [doc = " Identity data by account"] pub fn identity_of (& self , _0 : impl :: core :: borrow :: Borrow < types :: identity_of :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: identity_of :: Param0 > , types :: identity_of :: IdentityOf , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Registry" , "IdentityOf" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [234u8 , 187u8 , 56u8 , 218u8 , 135u8 , 79u8 , 50u8 , 159u8 , 20u8 , 10u8 , 131u8 , 167u8 , 135u8 , 236u8 , 19u8 , 176u8 , 113u8 , 194u8 , 115u8 , 138u8 , 0u8 , 184u8 , 178u8 , 245u8 , 255u8 , 85u8 , 51u8 , 140u8 , 11u8 , 143u8 , 218u8 , 217u8 ,]) } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi ; impl ConstantsApi { # [doc = " Configuration fields"] # [doc = " Maximum user-configured additional fields"] pub fn max_additional_fields (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u32 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Registry" , "MaxAdditionalFields" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " The amount held on deposit for a registered identity"] pub fn initial_deposit (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u64 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Registry" , "InitialDeposit" , [128u8 , 214u8 , 205u8 , 242u8 , 181u8 , 142u8 , 124u8 , 231u8 , 190u8 , 146u8 , 59u8 , 226u8 , 157u8 , 101u8 , 103u8 , 117u8 , 249u8 , 65u8 , 18u8 , 191u8 , 103u8 , 119u8 , 53u8 , 85u8 , 81u8 , 96u8 , 220u8 , 42u8 , 184u8 , 239u8 , 42u8 , 246u8 ,]) } # [doc = " The amount held on deposit per additional field for a registered identity."] pub fn field_deposit (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u64 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Registry" , "FieldDeposit" , [128u8 , 214u8 , 205u8 , 242u8 , 181u8 , 142u8 , 124u8 , 231u8 , 190u8 , 146u8 , 59u8 , 226u8 , 157u8 , 101u8 , 103u8 , 117u8 , 249u8 , 65u8 , 18u8 , 191u8 , 103u8 , 119u8 , 53u8 , 85u8 , 81u8 , 96u8 , 220u8 , 42u8 , 184u8 , 239u8 , 42u8 , 246u8 ,]) } } } } pub mod commitments { use super :: root_mod ; use super :: runtime_types ; # [doc = "The `Error` enum of this pallet."] pub type Error = runtime_types :: pallet_commitments :: pallet :: Error ; # [doc = "Contains a variant per dispatchable extrinsic that this pallet has."] pub type Call = runtime_types :: pallet_commitments :: pallet :: Call ; pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; pub mod types { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Set the commitment for a given netuid"] pub struct SetCommitment { pub netuid : set_commitment :: Netuid , pub info : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < set_commitment :: Info > , } pub mod set_commitment { use super :: runtime_types ; pub type Netuid = :: core :: primitive :: u16 ; pub type Info = runtime_types :: pallet_commitments :: types :: CommitmentInfo ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SetCommitment { const PALLET : & 'static str = "Commitments" ; const CALL : & 'static str = "set_commitment" ; } } pub struct TransactionApi ; impl TransactionApi { # [doc = "Set the commitment for a given netuid"] pub fn set_commitment (& self , netuid : types :: set_commitment :: Netuid , info : types :: set_commitment :: Info ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SetCommitment > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Commitments" , "set_commitment" , types :: SetCommitment { netuid , info : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box :: new (info) , } , [115u8 , 251u8 , 123u8 , 54u8 , 4u8 , 188u8 , 245u8 , 126u8 , 233u8 , 212u8 , 247u8 , 160u8 , 78u8 , 123u8 , 214u8 , 81u8 , 117u8 , 89u8 , 170u8 , 52u8 , 166u8 , 61u8 , 176u8 , 33u8 , 218u8 , 194u8 , 124u8 , 46u8 , 220u8 , 191u8 , 250u8 , 134u8 ,]) } } } # [doc = "The `Event` enum of this pallet"] pub type Event = runtime_types :: pallet_commitments :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "A commitment was set"] pub struct Commitment { pub netuid : commitment :: Netuid , pub who : commitment :: Who , } pub mod commitment { use super :: runtime_types ; pub type Netuid = :: core :: primitive :: u16 ; pub type Who = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Commitment { const PALLET : & 'static str = "Commitments" ; const EVENT : & 'static str = "Commitment" ; } } pub mod storage { use super :: runtime_types ; pub mod types { use super :: runtime_types ; pub mod commitment_of { use super :: runtime_types ; pub type CommitmentOf = runtime_types :: pallet_commitments :: types :: Registration < :: core :: primitive :: u64 , :: core :: primitive :: u32 > ; pub type Param0 = :: core :: primitive :: u16 ; pub type Param1 = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } pub mod last_commitment { use super :: runtime_types ; pub type LastCommitment = :: core :: primitive :: u32 ; pub type Param0 = :: core :: primitive :: u16 ; pub type Param1 = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } } pub struct StorageApi ; impl StorageApi { # [doc = " Identity data by account"] pub fn commitment_of_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: commitment_of :: CommitmentOf , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Commitments" , "CommitmentOf" , () , [49u8 , 73u8 , 122u8 , 216u8 , 70u8 , 131u8 , 56u8 , 160u8 , 154u8 , 67u8 , 48u8 , 46u8 , 177u8 , 187u8 , 117u8 , 166u8 , 51u8 , 158u8 , 63u8 , 233u8 , 1u8 , 120u8 , 7u8 , 95u8 , 66u8 , 11u8 , 139u8 , 157u8 , 180u8 , 194u8 , 63u8 , 36u8 ,]) } # [doc = " Identity data by account"] pub fn commitment_of_iter1 (& self , _0 : impl :: core :: borrow :: Borrow < types :: commitment_of :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: commitment_of :: Param0 > , types :: commitment_of :: CommitmentOf , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Commitments" , "CommitmentOf" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [49u8 , 73u8 , 122u8 , 216u8 , 70u8 , 131u8 , 56u8 , 160u8 , 154u8 , 67u8 , 48u8 , 46u8 , 177u8 , 187u8 , 117u8 , 166u8 , 51u8 , 158u8 , 63u8 , 233u8 , 1u8 , 120u8 , 7u8 , 95u8 , 66u8 , 11u8 , 139u8 , 157u8 , 180u8 , 194u8 , 63u8 , 36u8 ,]) } # [doc = " Identity data by account"] pub fn commitment_of (& self , _0 : impl :: core :: borrow :: Borrow < types :: commitment_of :: Param0 > , _1 : impl :: core :: borrow :: Borrow < types :: commitment_of :: Param1 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < (:: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: commitment_of :: Param0 > , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: commitment_of :: Param1 > ,) , types :: commitment_of :: CommitmentOf , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Commitments" , "CommitmentOf" , (:: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_1 . borrow ()) ,) , [49u8 , 73u8 , 122u8 , 216u8 , 70u8 , 131u8 , 56u8 , 160u8 , 154u8 , 67u8 , 48u8 , 46u8 , 177u8 , 187u8 , 117u8 , 166u8 , 51u8 , 158u8 , 63u8 , 233u8 , 1u8 , 120u8 , 7u8 , 95u8 , 66u8 , 11u8 , 139u8 , 157u8 , 180u8 , 194u8 , 63u8 , 36u8 ,]) } pub fn last_commitment_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: last_commitment :: LastCommitment , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Commitments" , "LastCommitment" , () , [139u8 , 18u8 , 67u8 , 3u8 , 183u8 , 236u8 , 230u8 , 168u8 , 162u8 , 27u8 , 124u8 , 208u8 , 80u8 , 59u8 , 115u8 , 168u8 , 19u8 , 84u8 , 100u8 , 234u8 , 21u8 , 52u8 , 48u8 , 87u8 , 226u8 , 158u8 , 211u8 , 215u8 , 177u8 , 207u8 , 202u8 , 69u8 ,]) } pub fn last_commitment_iter1 (& self , _0 : impl :: core :: borrow :: Borrow < types :: last_commitment :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: last_commitment :: Param0 > , types :: last_commitment :: LastCommitment , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Commitments" , "LastCommitment" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [139u8 , 18u8 , 67u8 , 3u8 , 183u8 , 236u8 , 230u8 , 168u8 , 162u8 , 27u8 , 124u8 , 208u8 , 80u8 , 59u8 , 115u8 , 168u8 , 19u8 , 84u8 , 100u8 , 234u8 , 21u8 , 52u8 , 48u8 , 87u8 , 226u8 , 158u8 , 211u8 , 215u8 , 177u8 , 207u8 , 202u8 , 69u8 ,]) } pub fn last_commitment (& self , _0 : impl :: core :: borrow :: Borrow < types :: last_commitment :: Param0 > , _1 : impl :: core :: borrow :: Borrow < types :: last_commitment :: Param1 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < (:: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: last_commitment :: Param0 > , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: last_commitment :: Param1 > ,) , types :: last_commitment :: LastCommitment , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Commitments" , "LastCommitment" , (:: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_1 . borrow ()) ,) , [139u8 , 18u8 , 67u8 , 3u8 , 183u8 , 236u8 , 230u8 , 168u8 , 162u8 , 27u8 , 124u8 , 208u8 , 80u8 , 59u8 , 115u8 , 168u8 , 19u8 , 84u8 , 100u8 , 234u8 , 21u8 , 52u8 , 48u8 , 87u8 , 226u8 , 158u8 , 211u8 , 215u8 , 177u8 , 207u8 , 202u8 , 69u8 ,]) } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi ; impl ConstantsApi { # [doc = " The maximum number of additional fields that can be added to a commitment"] pub fn max_fields (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u32 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Commitments" , "MaxFields" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " The amount held on deposit for a registered identity"] pub fn initial_deposit (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u64 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Commitments" , "InitialDeposit" , [128u8 , 214u8 , 205u8 , 242u8 , 181u8 , 142u8 , 124u8 , 231u8 , 190u8 , 146u8 , 59u8 , 226u8 , 157u8 , 101u8 , 103u8 , 117u8 , 249u8 , 65u8 , 18u8 , 191u8 , 103u8 , 119u8 , 53u8 , 85u8 , 81u8 , 96u8 , 220u8 , 42u8 , 184u8 , 239u8 , 42u8 , 246u8 ,]) } # [doc = " The amount held on deposit per additional field for a registered identity."] pub fn field_deposit (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u64 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Commitments" , "FieldDeposit" , [128u8 , 214u8 , 205u8 , 242u8 , 181u8 , 142u8 , 124u8 , 231u8 , 190u8 , 146u8 , 59u8 , 226u8 , 157u8 , 101u8 , 103u8 , 117u8 , 249u8 , 65u8 , 18u8 , 191u8 , 103u8 , 119u8 , 53u8 , 85u8 , 81u8 , 96u8 , 220u8 , 42u8 , 184u8 , 239u8 , 42u8 , 246u8 ,]) } # [doc = " The rate limit for commitments"] pub fn rate_limit (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u32 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Commitments" , "RateLimit" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } } } } pub mod admin_utils { use super :: root_mod ; use super :: runtime_types ; # [doc = "The `Error` enum of this pallet."] pub type Error = runtime_types :: pallet_admin_utils :: pallet :: Error ; # [doc = "Dispatchable functions allows users to interact with the pallet and invoke state changes."] pub type Call = runtime_types :: pallet_admin_utils :: pallet :: Call ; pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; pub mod types { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The extrinsic sets the new authorities for Aura consensus."] # [doc = "It is only callable by the root account."] # [doc = "The extrinsic will call the Aura pallet to change the authorities."] pub struct SwapAuthorities { pub new_authorities : swap_authorities :: NewAuthorities , } pub mod swap_authorities { use super :: runtime_types ; pub type NewAuthorities = runtime_types :: bounded_collections :: bounded_vec :: BoundedVec < runtime_types :: sp_consensus_aura :: sr25519 :: app_sr25519 :: Public > ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SwapAuthorities { const PALLET : & 'static str = "AdminUtils" ; const CALL : & 'static str = "swap_authorities" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The extrinsic sets the default take for the network."] # [doc = "It is only callable by the root account."] # [doc = "The extrinsic will call the Subtensor pallet to set the default take."] pub struct SudoSetDefaultTake { pub default_take : sudo_set_default_take :: DefaultTake , } pub mod sudo_set_default_take { use super :: runtime_types ; pub type DefaultTake = :: core :: primitive :: u16 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SudoSetDefaultTake { const PALLET : & 'static str = "AdminUtils" ; const CALL : & 'static str = "sudo_set_default_take" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The extrinsic sets the transaction rate limit for the network."] # [doc = "It is only callable by the root account."] # [doc = "The extrinsic will call the Subtensor pallet to set the transaction rate limit."] pub struct SudoSetTxRateLimit { pub tx_rate_limit : sudo_set_tx_rate_limit :: TxRateLimit , } pub mod sudo_set_tx_rate_limit { use super :: runtime_types ; pub type TxRateLimit = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SudoSetTxRateLimit { const PALLET : & 'static str = "AdminUtils" ; const CALL : & 'static str = "sudo_set_tx_rate_limit" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The extrinsic sets the serving rate limit for a subnet."] # [doc = "It is only callable by the root account or subnet owner."] # [doc = "The extrinsic will call the Subtensor pallet to set the serving rate limit."] pub struct SudoSetServingRateLimit { pub netuid : sudo_set_serving_rate_limit :: Netuid , pub serving_rate_limit : sudo_set_serving_rate_limit :: ServingRateLimit , } pub mod sudo_set_serving_rate_limit { use super :: runtime_types ; pub type Netuid = :: core :: primitive :: u16 ; pub type ServingRateLimit = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SudoSetServingRateLimit { const PALLET : & 'static str = "AdminUtils" ; const CALL : & 'static str = "sudo_set_serving_rate_limit" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The extrinsic sets the minimum difficulty for a subnet."] # [doc = "It is only callable by the root account or subnet owner."] # [doc = "The extrinsic will call the Subtensor pallet to set the minimum difficulty."] pub struct SudoSetMinDifficulty { pub netuid : sudo_set_min_difficulty :: Netuid , pub min_difficulty : sudo_set_min_difficulty :: MinDifficulty , } pub mod sudo_set_min_difficulty { use super :: runtime_types ; pub type Netuid = :: core :: primitive :: u16 ; pub type MinDifficulty = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SudoSetMinDifficulty { const PALLET : & 'static str = "AdminUtils" ; const CALL : & 'static str = "sudo_set_min_difficulty" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The extrinsic sets the maximum difficulty for a subnet."] # [doc = "It is only callable by the root account or subnet owner."] # [doc = "The extrinsic will call the Subtensor pallet to set the maximum difficulty."] pub struct SudoSetMaxDifficulty { pub netuid : sudo_set_max_difficulty :: Netuid , pub max_difficulty : sudo_set_max_difficulty :: MaxDifficulty , } pub mod sudo_set_max_difficulty { use super :: runtime_types ; pub type Netuid = :: core :: primitive :: u16 ; pub type MaxDifficulty = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SudoSetMaxDifficulty { const PALLET : & 'static str = "AdminUtils" ; const CALL : & 'static str = "sudo_set_max_difficulty" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The extrinsic sets the weights version key for a subnet."] # [doc = "It is only callable by the root account or subnet owner."] # [doc = "The extrinsic will call the Subtensor pallet to set the weights version key."] pub struct SudoSetWeightsVersionKey { pub netuid : sudo_set_weights_version_key :: Netuid , pub weights_version_key : sudo_set_weights_version_key :: WeightsVersionKey , } pub mod sudo_set_weights_version_key { use super :: runtime_types ; pub type Netuid = :: core :: primitive :: u16 ; pub type WeightsVersionKey = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SudoSetWeightsVersionKey { const PALLET : & 'static str = "AdminUtils" ; const CALL : & 'static str = "sudo_set_weights_version_key" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The extrinsic sets the weights set rate limit for a subnet."] # [doc = "It is only callable by the root account or subnet owner."] # [doc = "The extrinsic will call the Subtensor pallet to set the weights set rate limit."] pub struct SudoSetWeightsSetRateLimit { pub netuid : sudo_set_weights_set_rate_limit :: Netuid , pub weights_set_rate_limit : sudo_set_weights_set_rate_limit :: WeightsSetRateLimit , } pub mod sudo_set_weights_set_rate_limit { use super :: runtime_types ; pub type Netuid = :: core :: primitive :: u16 ; pub type WeightsSetRateLimit = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SudoSetWeightsSetRateLimit { const PALLET : & 'static str = "AdminUtils" ; const CALL : & 'static str = "sudo_set_weights_set_rate_limit" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The extrinsic sets the adjustment interval for a subnet."] # [doc = "It is only callable by the root account, not changeable by the subnet owner."] # [doc = "The extrinsic will call the Subtensor pallet to set the adjustment interval."] pub struct SudoSetAdjustmentInterval { pub netuid : sudo_set_adjustment_interval :: Netuid , pub adjustment_interval : sudo_set_adjustment_interval :: AdjustmentInterval , } pub mod sudo_set_adjustment_interval { use super :: runtime_types ; pub type Netuid = :: core :: primitive :: u16 ; pub type AdjustmentInterval = :: core :: primitive :: u16 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SudoSetAdjustmentInterval { const PALLET : & 'static str = "AdminUtils" ; const CALL : & 'static str = "sudo_set_adjustment_interval" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The extrinsic sets the adjustment alpha for a subnet."] # [doc = "It is only callable by the root account or subnet owner."] # [doc = "The extrinsic will call the Subtensor pallet to set the adjustment alpha."] pub struct SudoSetAdjustmentAlpha { pub netuid : sudo_set_adjustment_alpha :: Netuid , pub adjustment_alpha : sudo_set_adjustment_alpha :: AdjustmentAlpha , } pub mod sudo_set_adjustment_alpha { use super :: runtime_types ; pub type Netuid = :: core :: primitive :: u16 ; pub type AdjustmentAlpha = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SudoSetAdjustmentAlpha { const PALLET : & 'static str = "AdminUtils" ; const CALL : & 'static str = "sudo_set_adjustment_alpha" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The extrinsic sets the adjustment beta for a subnet."] # [doc = "It is only callable by the root account or subnet owner."] # [doc = "The extrinsic will call the Subtensor pallet to set the adjustment beta."] pub struct SudoSetMaxWeightLimit { pub netuid : sudo_set_max_weight_limit :: Netuid , pub max_weight_limit : sudo_set_max_weight_limit :: MaxWeightLimit , } pub mod sudo_set_max_weight_limit { use super :: runtime_types ; pub type Netuid = :: core :: primitive :: u16 ; pub type MaxWeightLimit = :: core :: primitive :: u16 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SudoSetMaxWeightLimit { const PALLET : & 'static str = "AdminUtils" ; const CALL : & 'static str = "sudo_set_max_weight_limit" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The extrinsic sets the immunity period for a subnet."] # [doc = "It is only callable by the root account or subnet owner."] # [doc = "The extrinsic will call the Subtensor pallet to set the immunity period."] pub struct SudoSetImmunityPeriod { pub netuid : sudo_set_immunity_period :: Netuid , pub immunity_period : sudo_set_immunity_period :: ImmunityPeriod , } pub mod sudo_set_immunity_period { use super :: runtime_types ; pub type Netuid = :: core :: primitive :: u16 ; pub type ImmunityPeriod = :: core :: primitive :: u16 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SudoSetImmunityPeriod { const PALLET : & 'static str = "AdminUtils" ; const CALL : & 'static str = "sudo_set_immunity_period" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The extrinsic sets the minimum allowed weights for a subnet."] # [doc = "It is only callable by the root account or subnet owner."] # [doc = "The extrinsic will call the Subtensor pallet to set the minimum allowed weights."] pub struct SudoSetMinAllowedWeights { pub netuid : sudo_set_min_allowed_weights :: Netuid , pub min_allowed_weights : sudo_set_min_allowed_weights :: MinAllowedWeights , } pub mod sudo_set_min_allowed_weights { use super :: runtime_types ; pub type Netuid = :: core :: primitive :: u16 ; pub type MinAllowedWeights = :: core :: primitive :: u16 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SudoSetMinAllowedWeights { const PALLET : & 'static str = "AdminUtils" ; const CALL : & 'static str = "sudo_set_min_allowed_weights" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The extrinsic sets the maximum allowed UIDs for a subnet."] # [doc = "It is only callable by the root account."] # [doc = "The extrinsic will call the Subtensor pallet to set the maximum allowed UIDs for a subnet."] pub struct SudoSetMaxAllowedUids { pub netuid : sudo_set_max_allowed_uids :: Netuid , pub max_allowed_uids : sudo_set_max_allowed_uids :: MaxAllowedUids , } pub mod sudo_set_max_allowed_uids { use super :: runtime_types ; pub type Netuid = :: core :: primitive :: u16 ; pub type MaxAllowedUids = :: core :: primitive :: u16 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SudoSetMaxAllowedUids { const PALLET : & 'static str = "AdminUtils" ; const CALL : & 'static str = "sudo_set_max_allowed_uids" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The extrinsic sets the kappa for a subnet."] # [doc = "It is only callable by the root account or subnet owner."] # [doc = "The extrinsic will call the Subtensor pallet to set the kappa."] pub struct SudoSetKappa { pub netuid : sudo_set_kappa :: Netuid , pub kappa : sudo_set_kappa :: Kappa , } pub mod sudo_set_kappa { use super :: runtime_types ; pub type Netuid = :: core :: primitive :: u16 ; pub type Kappa = :: core :: primitive :: u16 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SudoSetKappa { const PALLET : & 'static str = "AdminUtils" ; const CALL : & 'static str = "sudo_set_kappa" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The extrinsic sets the rho for a subnet."] # [doc = "It is only callable by the root account or subnet owner."] # [doc = "The extrinsic will call the Subtensor pallet to set the rho."] pub struct SudoSetRho { pub netuid : sudo_set_rho :: Netuid , pub rho : sudo_set_rho :: Rho , } pub mod sudo_set_rho { use super :: runtime_types ; pub type Netuid = :: core :: primitive :: u16 ; pub type Rho = :: core :: primitive :: u16 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SudoSetRho { const PALLET : & 'static str = "AdminUtils" ; const CALL : & 'static str = "sudo_set_rho" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The extrinsic sets the activity cutoff for a subnet."] # [doc = "It is only callable by the root account or subnet owner."] # [doc = "The extrinsic will call the Subtensor pallet to set the activity cutoff."] pub struct SudoSetActivityCutoff { pub netuid : sudo_set_activity_cutoff :: Netuid , pub activity_cutoff : sudo_set_activity_cutoff :: ActivityCutoff , } pub mod sudo_set_activity_cutoff { use super :: runtime_types ; pub type Netuid = :: core :: primitive :: u16 ; pub type ActivityCutoff = :: core :: primitive :: u16 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SudoSetActivityCutoff { const PALLET : & 'static str = "AdminUtils" ; const CALL : & 'static str = "sudo_set_activity_cutoff" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The extrinsic sets the network registration allowed for a subnet."] # [doc = "It is only callable by the root account or subnet owner."] # [doc = "The extrinsic will call the Subtensor pallet to set the network registration allowed."] pub struct SudoSetNetworkRegistrationAllowed { pub netuid : sudo_set_network_registration_allowed :: Netuid , pub registration_allowed : sudo_set_network_registration_allowed :: RegistrationAllowed , } pub mod sudo_set_network_registration_allowed { use super :: runtime_types ; pub type Netuid = :: core :: primitive :: u16 ; pub type RegistrationAllowed = :: core :: primitive :: bool ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SudoSetNetworkRegistrationAllowed { const PALLET : & 'static str = "AdminUtils" ; const CALL : & 'static str = "sudo_set_network_registration_allowed" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The extrinsic sets the network PoW registration allowed for a subnet."] # [doc = "It is only callable by the root account or subnet owner."] # [doc = "The extrinsic will call the Subtensor pallet to set the network PoW registration allowed."] pub struct SudoSetNetworkPowRegistrationAllowed { pub netuid : sudo_set_network_pow_registration_allowed :: Netuid , pub registration_allowed : sudo_set_network_pow_registration_allowed :: RegistrationAllowed , } pub mod sudo_set_network_pow_registration_allowed { use super :: runtime_types ; pub type Netuid = :: core :: primitive :: u16 ; pub type RegistrationAllowed = :: core :: primitive :: bool ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SudoSetNetworkPowRegistrationAllowed { const PALLET : & 'static str = "AdminUtils" ; const CALL : & 'static str = "sudo_set_network_pow_registration_allowed" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The extrinsic sets the target registrations per interval for a subnet."] # [doc = "It is only callable by the root account."] # [doc = "The extrinsic will call the Subtensor pallet to set the target registrations per interval."] pub struct SudoSetTargetRegistrationsPerInterval { pub netuid : sudo_set_target_registrations_per_interval :: Netuid , pub target_registrations_per_interval : sudo_set_target_registrations_per_interval :: TargetRegistrationsPerInterval , } pub mod sudo_set_target_registrations_per_interval { use super :: runtime_types ; pub type Netuid = :: core :: primitive :: u16 ; pub type TargetRegistrationsPerInterval = :: core :: primitive :: u16 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SudoSetTargetRegistrationsPerInterval { const PALLET : & 'static str = "AdminUtils" ; const CALL : & 'static str = "sudo_set_target_registrations_per_interval" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The extrinsic sets the minimum burn for a subnet."] # [doc = "It is only callable by the root account or subnet owner."] # [doc = "The extrinsic will call the Subtensor pallet to set the minimum burn."] pub struct SudoSetMinBurn { pub netuid : sudo_set_min_burn :: Netuid , pub min_burn : sudo_set_min_burn :: MinBurn , } pub mod sudo_set_min_burn { use super :: runtime_types ; pub type Netuid = :: core :: primitive :: u16 ; pub type MinBurn = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SudoSetMinBurn { const PALLET : & 'static str = "AdminUtils" ; const CALL : & 'static str = "sudo_set_min_burn" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The extrinsic sets the maximum burn for a subnet."] # [doc = "It is only callable by the root account or subnet owner."] # [doc = "The extrinsic will call the Subtensor pallet to set the maximum burn."] pub struct SudoSetMaxBurn { pub netuid : sudo_set_max_burn :: Netuid , pub max_burn : sudo_set_max_burn :: MaxBurn , } pub mod sudo_set_max_burn { use super :: runtime_types ; pub type Netuid = :: core :: primitive :: u16 ; pub type MaxBurn = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SudoSetMaxBurn { const PALLET : & 'static str = "AdminUtils" ; const CALL : & 'static str = "sudo_set_max_burn" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The extrinsic sets the difficulty for a subnet."] # [doc = "It is only callable by the root account or subnet owner."] # [doc = "The extrinsic will call the Subtensor pallet to set the difficulty."] pub struct SudoSetDifficulty { pub netuid : sudo_set_difficulty :: Netuid , pub difficulty : sudo_set_difficulty :: Difficulty , } pub mod sudo_set_difficulty { use super :: runtime_types ; pub type Netuid = :: core :: primitive :: u16 ; pub type Difficulty = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SudoSetDifficulty { const PALLET : & 'static str = "AdminUtils" ; const CALL : & 'static str = "sudo_set_difficulty" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The extrinsic sets the maximum allowed validators for a subnet."] # [doc = "It is only callable by the root account."] # [doc = "The extrinsic will call the Subtensor pallet to set the maximum allowed validators."] pub struct SudoSetMaxAllowedValidators { pub netuid : sudo_set_max_allowed_validators :: Netuid , pub max_allowed_validators : sudo_set_max_allowed_validators :: MaxAllowedValidators , } pub mod sudo_set_max_allowed_validators { use super :: runtime_types ; pub type Netuid = :: core :: primitive :: u16 ; pub type MaxAllowedValidators = :: core :: primitive :: u16 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SudoSetMaxAllowedValidators { const PALLET : & 'static str = "AdminUtils" ; const CALL : & 'static str = "sudo_set_max_allowed_validators" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The extrinsic sets the bonds moving average for a subnet."] # [doc = "It is only callable by the root account or subnet owner."] # [doc = "The extrinsic will call the Subtensor pallet to set the bonds moving average."] pub struct SudoSetBondsMovingAverage { pub netuid : sudo_set_bonds_moving_average :: Netuid , pub bonds_moving_average : sudo_set_bonds_moving_average :: BondsMovingAverage , } pub mod sudo_set_bonds_moving_average { use super :: runtime_types ; pub type Netuid = :: core :: primitive :: u16 ; pub type BondsMovingAverage = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SudoSetBondsMovingAverage { const PALLET : & 'static str = "AdminUtils" ; const CALL : & 'static str = "sudo_set_bonds_moving_average" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The extrinsic sets the maximum registrations per block for a subnet."] # [doc = "It is only callable by the root account."] # [doc = "The extrinsic will call the Subtensor pallet to set the maximum registrations per block."] pub struct SudoSetMaxRegistrationsPerBlock { pub netuid : sudo_set_max_registrations_per_block :: Netuid , pub max_registrations_per_block : sudo_set_max_registrations_per_block :: MaxRegistrationsPerBlock , } pub mod sudo_set_max_registrations_per_block { use super :: runtime_types ; pub type Netuid = :: core :: primitive :: u16 ; pub type MaxRegistrationsPerBlock = :: core :: primitive :: u16 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SudoSetMaxRegistrationsPerBlock { const PALLET : & 'static str = "AdminUtils" ; const CALL : & 'static str = "sudo_set_max_registrations_per_block" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The extrinsic sets the subnet owner cut for a subnet."] # [doc = "It is only callable by the root account."] # [doc = "The extrinsic will call the Subtensor pallet to set the subnet owner cut."] pub struct SudoSetSubnetOwnerCut { pub subnet_owner_cut : sudo_set_subnet_owner_cut :: SubnetOwnerCut , } pub mod sudo_set_subnet_owner_cut { use super :: runtime_types ; pub type SubnetOwnerCut = :: core :: primitive :: u16 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SudoSetSubnetOwnerCut { const PALLET : & 'static str = "AdminUtils" ; const CALL : & 'static str = "sudo_set_subnet_owner_cut" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The extrinsic sets the network rate limit for the network."] # [doc = "It is only callable by the root account."] # [doc = "The extrinsic will call the Subtensor pallet to set the network rate limit."] pub struct SudoSetNetworkRateLimit { pub rate_limit : sudo_set_network_rate_limit :: RateLimit , } pub mod sudo_set_network_rate_limit { use super :: runtime_types ; pub type RateLimit = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SudoSetNetworkRateLimit { const PALLET : & 'static str = "AdminUtils" ; const CALL : & 'static str = "sudo_set_network_rate_limit" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The extrinsic sets the tempo for a subnet."] # [doc = "It is only callable by the root account."] # [doc = "The extrinsic will call the Subtensor pallet to set the tempo."] pub struct SudoSetTempo { pub netuid : sudo_set_tempo :: Netuid , pub tempo : sudo_set_tempo :: Tempo , } pub mod sudo_set_tempo { use super :: runtime_types ; pub type Netuid = :: core :: primitive :: u16 ; pub type Tempo = :: core :: primitive :: u16 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SudoSetTempo { const PALLET : & 'static str = "AdminUtils" ; const CALL : & 'static str = "sudo_set_tempo" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The extrinsic sets the total issuance for the network."] # [doc = "It is only callable by the root account."] # [doc = "The extrinsic will call the Subtensor pallet to set the issuance for the network."] pub struct SudoSetTotalIssuance { pub total_issuance : sudo_set_total_issuance :: TotalIssuance , } pub mod sudo_set_total_issuance { use super :: runtime_types ; pub type TotalIssuance = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SudoSetTotalIssuance { const PALLET : & 'static str = "AdminUtils" ; const CALL : & 'static str = "sudo_set_total_issuance" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The extrinsic sets the immunity period for the network."] # [doc = "It is only callable by the root account."] # [doc = "The extrinsic will call the Subtensor pallet to set the immunity period for the network."] pub struct SudoSetNetworkImmunityPeriod { pub immunity_period : sudo_set_network_immunity_period :: ImmunityPeriod , } pub mod sudo_set_network_immunity_period { use super :: runtime_types ; pub type ImmunityPeriod = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SudoSetNetworkImmunityPeriod { const PALLET : & 'static str = "AdminUtils" ; const CALL : & 'static str = "sudo_set_network_immunity_period" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The extrinsic sets the min lock cost for the network."] # [doc = "It is only callable by the root account."] # [doc = "The extrinsic will call the Subtensor pallet to set the min lock cost for the network."] pub struct SudoSetNetworkMinLockCost { pub lock_cost : sudo_set_network_min_lock_cost :: LockCost , } pub mod sudo_set_network_min_lock_cost { use super :: runtime_types ; pub type LockCost = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SudoSetNetworkMinLockCost { const PALLET : & 'static str = "AdminUtils" ; const CALL : & 'static str = "sudo_set_network_min_lock_cost" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The extrinsic sets the subnet limit for the network."] # [doc = "It is only callable by the root account."] # [doc = "The extrinsic will call the Subtensor pallet to set the subnet limit."] pub struct SudoSetSubnetLimit { pub max_subnets : sudo_set_subnet_limit :: MaxSubnets , } pub mod sudo_set_subnet_limit { use super :: runtime_types ; pub type MaxSubnets = :: core :: primitive :: u16 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SudoSetSubnetLimit { const PALLET : & 'static str = "AdminUtils" ; const CALL : & 'static str = "sudo_set_subnet_limit" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The extrinsic sets the lock reduction interval for the network."] # [doc = "It is only callable by the root account."] # [doc = "The extrinsic will call the Subtensor pallet to set the lock reduction interval."] pub struct SudoSetLockReductionInterval { pub interval : sudo_set_lock_reduction_interval :: Interval , } pub mod sudo_set_lock_reduction_interval { use super :: runtime_types ; pub type Interval = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SudoSetLockReductionInterval { const PALLET : & 'static str = "AdminUtils" ; const CALL : & 'static str = "sudo_set_lock_reduction_interval" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The extrinsic sets the recycled RAO for a subnet."] # [doc = "It is only callable by the root account."] # [doc = "The extrinsic will call the Subtensor pallet to set the recycled RAO."] pub struct SudoSetRaoRecycled { pub netuid : sudo_set_rao_recycled :: Netuid , pub rao_recycled : sudo_set_rao_recycled :: RaoRecycled , } pub mod sudo_set_rao_recycled { use super :: runtime_types ; pub type Netuid = :: core :: primitive :: u16 ; pub type RaoRecycled = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SudoSetRaoRecycled { const PALLET : & 'static str = "AdminUtils" ; const CALL : & 'static str = "sudo_set_rao_recycled" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The extrinsic sets the weights min stake."] # [doc = "It is only callable by the root account."] # [doc = "The extrinsic will call the Subtensor pallet to set the weights min stake."] pub struct SudoSetWeightsMinStake { pub min_stake : sudo_set_weights_min_stake :: MinStake , } pub mod sudo_set_weights_min_stake { use super :: runtime_types ; pub type MinStake = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SudoSetWeightsMinStake { const PALLET : & 'static str = "AdminUtils" ; const CALL : & 'static str = "sudo_set_weights_min_stake" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The extrinsic sets the minimum stake required for nominators."] # [doc = "It is only callable by the root account."] # [doc = "The extrinsic will call the Subtensor pallet to set the minimum stake required for nominators."] pub struct SudoSetNominatorMinRequiredStake { pub min_stake : sudo_set_nominator_min_required_stake :: MinStake , } pub mod sudo_set_nominator_min_required_stake { use super :: runtime_types ; pub type MinStake = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SudoSetNominatorMinRequiredStake { const PALLET : & 'static str = "AdminUtils" ; const CALL : & 'static str = "sudo_set_nominator_min_required_stake" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The extrinsic sets the rate limit for delegate take transactions."] # [doc = "It is only callable by the root account."] # [doc = "The extrinsic will call the Subtensor pallet to set the rate limit for delegate take transactions."] pub struct SudoSetTxDelegateTakeRateLimit { pub tx_rate_limit : sudo_set_tx_delegate_take_rate_limit :: TxRateLimit , } pub mod sudo_set_tx_delegate_take_rate_limit { use super :: runtime_types ; pub type TxRateLimit = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SudoSetTxDelegateTakeRateLimit { const PALLET : & 'static str = "AdminUtils" ; const CALL : & 'static str = "sudo_set_tx_delegate_take_rate_limit" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The extrinsic sets the minimum delegate take."] # [doc = "It is only callable by the root account."] # [doc = "The extrinsic will call the Subtensor pallet to set the minimum delegate take."] pub struct SudoSetMinDelegateTake { pub take : sudo_set_min_delegate_take :: Take , } pub mod sudo_set_min_delegate_take { use super :: runtime_types ; pub type Take = :: core :: primitive :: u16 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SudoSetMinDelegateTake { const PALLET : & 'static str = "AdminUtils" ; const CALL : & 'static str = "sudo_set_min_delegate_take" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The extrinsic sets the target stake per interval."] # [doc = "It is only callable by the root account."] # [doc = "The extrinsic will call the Subtensor pallet to set target stake per interval."] pub struct SudoSetTargetStakesPerInterval { pub target_stakes_per_interval : sudo_set_target_stakes_per_interval :: TargetStakesPerInterval , } pub mod sudo_set_target_stakes_per_interval { use super :: runtime_types ; pub type TargetStakesPerInterval = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SudoSetTargetStakesPerInterval { const PALLET : & 'static str = "AdminUtils" ; const CALL : & 'static str = "sudo_set_target_stakes_per_interval" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The extrinsic sets the commit/reveal interval for a subnet."] # [doc = "It is only callable by the root account or subnet owner."] # [doc = "The extrinsic will call the Subtensor pallet to set the interval."] pub struct SudoSetCommitRevealWeightsInterval { pub netuid : sudo_set_commit_reveal_weights_interval :: Netuid , pub interval : sudo_set_commit_reveal_weights_interval :: Interval , } pub mod sudo_set_commit_reveal_weights_interval { use super :: runtime_types ; pub type Netuid = :: core :: primitive :: u16 ; pub type Interval = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SudoSetCommitRevealWeightsInterval { const PALLET : & 'static str = "AdminUtils" ; const CALL : & 'static str = "sudo_set_commit_reveal_weights_interval" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The extrinsic enabled/disables commit/reaveal for a given subnet."] # [doc = "It is only callable by the root account or subnet owner."] # [doc = "The extrinsic will call the Subtensor pallet to set the value."] pub struct SudoSetCommitRevealWeightsEnabled { pub netuid : sudo_set_commit_reveal_weights_enabled :: Netuid , pub enabled : sudo_set_commit_reveal_weights_enabled :: Enabled , } pub mod sudo_set_commit_reveal_weights_enabled { use super :: runtime_types ; pub type Netuid = :: core :: primitive :: u16 ; pub type Enabled = :: core :: primitive :: bool ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SudoSetCommitRevealWeightsEnabled { const PALLET : & 'static str = "AdminUtils" ; const CALL : & 'static str = "sudo_set_commit_reveal_weights_enabled" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Enables or disables Liquid Alpha for a given subnet."] # [doc = ""] # [doc = "# Parameters"] # [doc = "- `origin`: The origin of the call, which must be the root account or subnet owner."] # [doc = "- `netuid`: The unique identifier for the subnet."] # [doc = "- `enabled`: A boolean flag to enable or disable Liquid Alpha."] # [doc = ""] # [doc = "# Weight"] # [doc = "This function has a fixed weight of 0 and is classified as an operational transaction that does not incur any fees."] pub struct SudoSetLiquidAlphaEnabled { pub netuid : sudo_set_liquid_alpha_enabled :: Netuid , pub enabled : sudo_set_liquid_alpha_enabled :: Enabled , } pub mod sudo_set_liquid_alpha_enabled { use super :: runtime_types ; pub type Netuid = :: core :: primitive :: u16 ; pub type Enabled = :: core :: primitive :: bool ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SudoSetLiquidAlphaEnabled { const PALLET : & 'static str = "AdminUtils" ; const CALL : & 'static str = "sudo_set_liquid_alpha_enabled" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Sets values for liquid alpha"] pub struct SudoSetAlphaValues { pub netuid : sudo_set_alpha_values :: Netuid , pub alpha_low : sudo_set_alpha_values :: AlphaLow , pub alpha_high : sudo_set_alpha_values :: AlphaHigh , } pub mod sudo_set_alpha_values { use super :: runtime_types ; pub type Netuid = :: core :: primitive :: u16 ; pub type AlphaLow = :: core :: primitive :: u16 ; pub type AlphaHigh = :: core :: primitive :: u16 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SudoSetAlphaValues { const PALLET : & 'static str = "AdminUtils" ; const CALL : & 'static str = "sudo_set_alpha_values" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Sets the hotkey emission tempo."] # [doc = ""] # [doc = "This extrinsic allows the root account to set the hotkey emission tempo, which determines"] # [doc = "the number of blocks before a hotkey drains accumulated emissions through to nominator staking accounts."] # [doc = ""] # [doc = "# Arguments"] # [doc = "* `origin` - The origin of the call, which must be the root account."] # [doc = "* `emission_tempo` - The new emission tempo value to set."] # [doc = ""] # [doc = "# Emits"] # [doc = "* `Event::HotkeyEmissionTempoSet` - When the hotkey emission tempo is successfully set."] # [doc = ""] # [doc = "# Errors"] # [doc = "* `DispatchError::BadOrigin` - If the origin is not the root account."] pub struct SudoSetHotkeyEmissionTempo { pub emission_tempo : sudo_set_hotkey_emission_tempo :: EmissionTempo , } pub mod sudo_set_hotkey_emission_tempo { use super :: runtime_types ; pub type EmissionTempo = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SudoSetHotkeyEmissionTempo { const PALLET : & 'static str = "AdminUtils" ; const CALL : & 'static str = "sudo_set_hotkey_emission_tempo" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Sets the maximum stake allowed for a specific network."] # [doc = ""] # [doc = "This function allows the root account to set the maximum stake for a given network."] # [doc = "It updates the network's maximum stake value and logs the change."] # [doc = ""] # [doc = "# Arguments"] # [doc = ""] # [doc = "* `origin` - The origin of the call, which must be the root account."] # [doc = "* `netuid` - The unique identifier of the network."] # [doc = "* `max_stake` - The new maximum stake value to set."] # [doc = ""] # [doc = "# Returns"] # [doc = ""] # [doc = "Returns `Ok(())` if the operation is successful, or an error if it fails."] # [doc = ""] # [doc = "# Example"] # [doc = ""] # [doc = ""] # [doc = "# Notes"] # [doc = ""] # [doc = "- This function can only be called by the root account."] # [doc = "- The `netuid` should correspond to an existing network."] # [doc = ""] # [doc = "# TODO"] # [doc = ""] pub struct SudoSetNetworkMaxStake { pub netuid : sudo_set_network_max_stake :: Netuid , pub max_stake : sudo_set_network_max_stake :: MaxStake , } pub mod sudo_set_network_max_stake { use super :: runtime_types ; pub type Netuid = :: core :: primitive :: u16 ; pub type MaxStake = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SudoSetNetworkMaxStake { const PALLET : & 'static str = "AdminUtils" ; const CALL : & 'static str = "sudo_set_network_max_stake" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Sets the duration of the coldkey swap schedule."] # [doc = ""] # [doc = "This extrinsic allows the root account to set the duration for the coldkey swap schedule."] # [doc = "The coldkey swap schedule determines how long it takes for a coldkey swap operation to complete."] # [doc = ""] # [doc = "# Arguments"] # [doc = "* `origin` - The origin of the call, which must be the root account."] # [doc = "* `duration` - The new duration for the coldkey swap schedule, in number of blocks."] # [doc = ""] # [doc = "# Errors"] # [doc = "* `BadOrigin` - If the caller is not the root account."] # [doc = ""] # [doc = "# Weight"] # [doc = "Weight is handled by the `#[pallet::weight]` attribute."] pub struct SudoSetColdkeySwapScheduleDuration { pub duration : sudo_set_coldkey_swap_schedule_duration :: Duration , } pub mod sudo_set_coldkey_swap_schedule_duration { use super :: runtime_types ; pub type Duration = :: core :: primitive :: u32 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SudoSetColdkeySwapScheduleDuration { const PALLET : & 'static str = "AdminUtils" ; const CALL : & 'static str = "sudo_set_coldkey_swap_schedule_duration" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Sets the duration of the dissolve network schedule."] # [doc = ""] # [doc = "This extrinsic allows the root account to set the duration for the dissolve network schedule."] # [doc = "The dissolve network schedule determines how long it takes for a network dissolution operation to complete."] # [doc = ""] # [doc = "# Arguments"] # [doc = "* `origin` - The origin of the call, which must be the root account."] # [doc = "* `duration` - The new duration for the dissolve network schedule, in number of blocks."] # [doc = ""] # [doc = "# Errors"] # [doc = "* `BadOrigin` - If the caller is not the root account."] # [doc = ""] # [doc = "# Weight"] # [doc = "Weight is handled by the `#[pallet::weight]` attribute."] pub struct SudoSetDissolveNetworkScheduleDuration { pub duration : sudo_set_dissolve_network_schedule_duration :: Duration , } pub mod sudo_set_dissolve_network_schedule_duration { use super :: runtime_types ; pub type Duration = :: core :: primitive :: u32 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SudoSetDissolveNetworkScheduleDuration { const PALLET : & 'static str = "AdminUtils" ; const CALL : & 'static str = "sudo_set_dissolve_network_schedule_duration" ; } } pub struct TransactionApi ; impl TransactionApi { # [doc = "The extrinsic sets the new authorities for Aura consensus."] # [doc = "It is only callable by the root account."] # [doc = "The extrinsic will call the Aura pallet to change the authorities."] pub fn swap_authorities (& self , new_authorities : types :: swap_authorities :: NewAuthorities ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SwapAuthorities > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("AdminUtils" , "swap_authorities" , types :: SwapAuthorities { new_authorities , } , [209u8 , 171u8 , 135u8 , 198u8 , 103u8 , 209u8 , 217u8 , 32u8 , 125u8 , 109u8 , 206u8 , 190u8 , 252u8 , 34u8 , 107u8 , 31u8 , 127u8 , 174u8 , 86u8 , 139u8 , 78u8 , 100u8 , 198u8 , 247u8 , 176u8 , 163u8 , 14u8 , 21u8 , 222u8 , 21u8 , 184u8 , 145u8 ,]) } # [doc = "The extrinsic sets the default take for the network."] # [doc = "It is only callable by the root account."] # [doc = "The extrinsic will call the Subtensor pallet to set the default take."] pub fn sudo_set_default_take (& self , default_take : types :: sudo_set_default_take :: DefaultTake ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SudoSetDefaultTake > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("AdminUtils" , "sudo_set_default_take" , types :: SudoSetDefaultTake { default_take , } , [20u8 , 46u8 , 121u8 , 192u8 , 232u8 , 72u8 , 1u8 , 150u8 , 114u8 , 185u8 , 165u8 , 156u8 , 92u8 , 214u8 , 142u8 , 98u8 , 119u8 , 133u8 , 26u8 , 226u8 , 76u8 , 209u8 , 95u8 , 186u8 , 147u8 , 191u8 , 164u8 , 248u8 , 6u8 , 65u8 , 64u8 , 191u8 ,]) } # [doc = "The extrinsic sets the transaction rate limit for the network."] # [doc = "It is only callable by the root account."] # [doc = "The extrinsic will call the Subtensor pallet to set the transaction rate limit."] pub fn sudo_set_tx_rate_limit (& self , tx_rate_limit : types :: sudo_set_tx_rate_limit :: TxRateLimit ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SudoSetTxRateLimit > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("AdminUtils" , "sudo_set_tx_rate_limit" , types :: SudoSetTxRateLimit { tx_rate_limit , } , [199u8 , 37u8 , 33u8 , 84u8 , 249u8 , 149u8 , 136u8 , 131u8 , 137u8 , 100u8 , 230u8 , 52u8 , 9u8 , 112u8 , 245u8 , 250u8 , 51u8 , 181u8 , 76u8 , 192u8 , 150u8 , 249u8 , 128u8 , 232u8 , 52u8 , 41u8 , 177u8 , 114u8 , 8u8 , 44u8 , 255u8 , 119u8 ,]) } # [doc = "The extrinsic sets the serving rate limit for a subnet."] # [doc = "It is only callable by the root account or subnet owner."] # [doc = "The extrinsic will call the Subtensor pallet to set the serving rate limit."] pub fn sudo_set_serving_rate_limit (& self , netuid : types :: sudo_set_serving_rate_limit :: Netuid , serving_rate_limit : types :: sudo_set_serving_rate_limit :: ServingRateLimit ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SudoSetServingRateLimit > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("AdminUtils" , "sudo_set_serving_rate_limit" , types :: SudoSetServingRateLimit { netuid , serving_rate_limit , } , [29u8 , 43u8 , 79u8 , 187u8 , 65u8 , 190u8 , 80u8 , 41u8 , 51u8 , 255u8 , 205u8 , 47u8 , 189u8 , 13u8 , 45u8 , 255u8 , 79u8 , 95u8 , 48u8 , 153u8 , 218u8 , 18u8 , 241u8 , 248u8 , 37u8 , 94u8 , 29u8 , 229u8 , 130u8 , 34u8 , 253u8 , 125u8 ,]) } # [doc = "The extrinsic sets the minimum difficulty for a subnet."] # [doc = "It is only callable by the root account or subnet owner."] # [doc = "The extrinsic will call the Subtensor pallet to set the minimum difficulty."] pub fn sudo_set_min_difficulty (& self , netuid : types :: sudo_set_min_difficulty :: Netuid , min_difficulty : types :: sudo_set_min_difficulty :: MinDifficulty ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SudoSetMinDifficulty > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("AdminUtils" , "sudo_set_min_difficulty" , types :: SudoSetMinDifficulty { netuid , min_difficulty , } , [36u8 , 75u8 , 246u8 , 131u8 , 174u8 , 93u8 , 25u8 , 154u8 , 144u8 , 125u8 , 6u8 , 202u8 , 103u8 , 77u8 , 88u8 , 189u8 , 148u8 , 125u8 , 184u8 , 103u8 , 96u8 , 147u8 , 96u8 , 203u8 , 109u8 , 122u8 , 21u8 , 164u8 , 46u8 , 51u8 , 234u8 , 3u8 ,]) } # [doc = "The extrinsic sets the maximum difficulty for a subnet."] # [doc = "It is only callable by the root account or subnet owner."] # [doc = "The extrinsic will call the Subtensor pallet to set the maximum difficulty."] pub fn sudo_set_max_difficulty (& self , netuid : types :: sudo_set_max_difficulty :: Netuid , max_difficulty : types :: sudo_set_max_difficulty :: MaxDifficulty ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SudoSetMaxDifficulty > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("AdminUtils" , "sudo_set_max_difficulty" , types :: SudoSetMaxDifficulty { netuid , max_difficulty , } , [247u8 , 167u8 , 239u8 , 82u8 , 41u8 , 50u8 , 244u8 , 3u8 , 94u8 , 66u8 , 187u8 , 44u8 , 6u8 , 115u8 , 161u8 , 197u8 , 185u8 , 146u8 , 196u8 , 175u8 , 232u8 , 42u8 , 231u8 , 226u8 , 9u8 , 40u8 , 115u8 , 35u8 , 40u8 , 59u8 , 227u8 , 159u8 ,]) } # [doc = "The extrinsic sets the weights version key for a subnet."] # [doc = "It is only callable by the root account or subnet owner."] # [doc = "The extrinsic will call the Subtensor pallet to set the weights version key."] pub fn sudo_set_weights_version_key (& self , netuid : types :: sudo_set_weights_version_key :: Netuid , weights_version_key : types :: sudo_set_weights_version_key :: WeightsVersionKey ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SudoSetWeightsVersionKey > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("AdminUtils" , "sudo_set_weights_version_key" , types :: SudoSetWeightsVersionKey { netuid , weights_version_key , } , [111u8 , 223u8 , 231u8 , 18u8 , 142u8 , 144u8 , 186u8 , 87u8 , 183u8 , 92u8 , 12u8 , 151u8 , 204u8 , 11u8 , 53u8 , 135u8 , 9u8 , 167u8 , 135u8 , 172u8 , 232u8 , 136u8 , 103u8 , 248u8 , 178u8 , 207u8 , 40u8 , 169u8 , 191u8 , 22u8 , 177u8 , 193u8 ,]) } # [doc = "The extrinsic sets the weights set rate limit for a subnet."] # [doc = "It is only callable by the root account or subnet owner."] # [doc = "The extrinsic will call the Subtensor pallet to set the weights set rate limit."] pub fn sudo_set_weights_set_rate_limit (& self , netuid : types :: sudo_set_weights_set_rate_limit :: Netuid , weights_set_rate_limit : types :: sudo_set_weights_set_rate_limit :: WeightsSetRateLimit ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SudoSetWeightsSetRateLimit > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("AdminUtils" , "sudo_set_weights_set_rate_limit" , types :: SudoSetWeightsSetRateLimit { netuid , weights_set_rate_limit , } , [208u8 , 189u8 , 207u8 , 207u8 , 173u8 , 44u8 , 136u8 , 125u8 , 108u8 , 147u8 , 240u8 , 45u8 , 159u8 , 129u8 , 162u8 , 87u8 , 204u8 , 248u8 , 79u8 , 14u8 , 34u8 , 193u8 , 72u8 , 119u8 , 154u8 , 32u8 , 63u8 , 123u8 , 48u8 , 10u8 , 107u8 , 16u8 ,]) } # [doc = "The extrinsic sets the adjustment interval for a subnet."] # [doc = "It is only callable by the root account, not changeable by the subnet owner."] # [doc = "The extrinsic will call the Subtensor pallet to set the adjustment interval."] pub fn sudo_set_adjustment_interval (& self , netuid : types :: sudo_set_adjustment_interval :: Netuid , adjustment_interval : types :: sudo_set_adjustment_interval :: AdjustmentInterval ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SudoSetAdjustmentInterval > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("AdminUtils" , "sudo_set_adjustment_interval" , types :: SudoSetAdjustmentInterval { netuid , adjustment_interval , } , [167u8 , 14u8 , 61u8 , 114u8 , 173u8 , 242u8 , 209u8 , 221u8 , 233u8 , 144u8 , 106u8 , 175u8 , 105u8 , 46u8 , 242u8 , 178u8 , 48u8 , 55u8 , 136u8 , 173u8 , 161u8 , 115u8 , 6u8 , 87u8 , 124u8 , 213u8 , 101u8 , 112u8 , 233u8 , 120u8 , 130u8 , 47u8 ,]) } # [doc = "The extrinsic sets the adjustment alpha for a subnet."] # [doc = "It is only callable by the root account or subnet owner."] # [doc = "The extrinsic will call the Subtensor pallet to set the adjustment alpha."] pub fn sudo_set_adjustment_alpha (& self , netuid : types :: sudo_set_adjustment_alpha :: Netuid , adjustment_alpha : types :: sudo_set_adjustment_alpha :: AdjustmentAlpha ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SudoSetAdjustmentAlpha > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("AdminUtils" , "sudo_set_adjustment_alpha" , types :: SudoSetAdjustmentAlpha { netuid , adjustment_alpha , } , [84u8 , 151u8 , 85u8 , 94u8 , 49u8 , 2u8 , 238u8 , 226u8 , 27u8 , 139u8 , 122u8 , 25u8 , 175u8 , 162u8 , 163u8 , 251u8 , 17u8 , 50u8 , 117u8 , 85u8 , 201u8 , 174u8 , 235u8 , 135u8 , 174u8 , 106u8 , 239u8 , 209u8 , 120u8 , 114u8 , 217u8 , 214u8 ,]) } # [doc = "The extrinsic sets the adjustment beta for a subnet."] # [doc = "It is only callable by the root account or subnet owner."] # [doc = "The extrinsic will call the Subtensor pallet to set the adjustment beta."] pub fn sudo_set_max_weight_limit (& self , netuid : types :: sudo_set_max_weight_limit :: Netuid , max_weight_limit : types :: sudo_set_max_weight_limit :: MaxWeightLimit ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SudoSetMaxWeightLimit > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("AdminUtils" , "sudo_set_max_weight_limit" , types :: SudoSetMaxWeightLimit { netuid , max_weight_limit , } , [120u8 , 54u8 , 253u8 , 8u8 , 133u8 , 139u8 , 51u8 , 116u8 , 60u8 , 173u8 , 44u8 , 25u8 , 146u8 , 181u8 , 12u8 , 14u8 , 196u8 , 118u8 , 180u8 , 229u8 , 57u8 , 133u8 , 198u8 , 219u8 , 97u8 , 189u8 , 116u8 , 183u8 , 154u8 , 128u8 , 15u8 , 177u8 ,]) } # [doc = "The extrinsic sets the immunity period for a subnet."] # [doc = "It is only callable by the root account or subnet owner."] # [doc = "The extrinsic will call the Subtensor pallet to set the immunity period."] pub fn sudo_set_immunity_period (& self , netuid : types :: sudo_set_immunity_period :: Netuid , immunity_period : types :: sudo_set_immunity_period :: ImmunityPeriod ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SudoSetImmunityPeriod > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("AdminUtils" , "sudo_set_immunity_period" , types :: SudoSetImmunityPeriod { netuid , immunity_period , } , [128u8 , 74u8 , 247u8 , 44u8 , 254u8 , 25u8 , 45u8 , 123u8 , 171u8 , 72u8 , 81u8 , 82u8 , 174u8 , 105u8 , 181u8 , 91u8 , 175u8 , 51u8 , 107u8 , 222u8 , 11u8 , 25u8 , 9u8 , 226u8 , 4u8 , 32u8 , 49u8 , 63u8 , 59u8 , 32u8 , 9u8 , 189u8 ,]) } # [doc = "The extrinsic sets the minimum allowed weights for a subnet."] # [doc = "It is only callable by the root account or subnet owner."] # [doc = "The extrinsic will call the Subtensor pallet to set the minimum allowed weights."] pub fn sudo_set_min_allowed_weights (& self , netuid : types :: sudo_set_min_allowed_weights :: Netuid , min_allowed_weights : types :: sudo_set_min_allowed_weights :: MinAllowedWeights ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SudoSetMinAllowedWeights > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("AdminUtils" , "sudo_set_min_allowed_weights" , types :: SudoSetMinAllowedWeights { netuid , min_allowed_weights , } , [27u8 , 73u8 , 15u8 , 199u8 , 177u8 , 128u8 , 254u8 , 102u8 , 28u8 , 132u8 , 47u8 , 244u8 , 20u8 , 57u8 , 7u8 , 7u8 , 209u8 , 19u8 , 130u8 , 178u8 , 40u8 , 130u8 , 65u8 , 5u8 , 107u8 , 78u8 , 216u8 , 54u8 , 163u8 , 49u8 , 35u8 , 78u8 ,]) } # [doc = "The extrinsic sets the maximum allowed UIDs for a subnet."] # [doc = "It is only callable by the root account."] # [doc = "The extrinsic will call the Subtensor pallet to set the maximum allowed UIDs for a subnet."] pub fn sudo_set_max_allowed_uids (& self , netuid : types :: sudo_set_max_allowed_uids :: Netuid , max_allowed_uids : types :: sudo_set_max_allowed_uids :: MaxAllowedUids ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SudoSetMaxAllowedUids > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("AdminUtils" , "sudo_set_max_allowed_uids" , types :: SudoSetMaxAllowedUids { netuid , max_allowed_uids , } , [231u8 , 110u8 , 75u8 , 66u8 , 160u8 , 211u8 , 212u8 , 120u8 , 24u8 , 204u8 , 147u8 , 44u8 , 230u8 , 135u8 , 143u8 , 231u8 , 142u8 , 22u8 , 220u8 , 107u8 , 12u8 , 224u8 , 206u8 , 117u8 , 203u8 , 36u8 , 233u8 , 159u8 , 60u8 , 126u8 , 0u8 , 148u8 ,]) } # [doc = "The extrinsic sets the kappa for a subnet."] # [doc = "It is only callable by the root account or subnet owner."] # [doc = "The extrinsic will call the Subtensor pallet to set the kappa."] pub fn sudo_set_kappa (& self , netuid : types :: sudo_set_kappa :: Netuid , kappa : types :: sudo_set_kappa :: Kappa ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SudoSetKappa > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("AdminUtils" , "sudo_set_kappa" , types :: SudoSetKappa { netuid , kappa , } , [38u8 , 246u8 , 140u8 , 183u8 , 207u8 , 121u8 , 74u8 , 45u8 , 74u8 , 208u8 , 89u8 , 136u8 , 65u8 , 164u8 , 132u8 , 211u8 , 225u8 , 188u8 , 219u8 , 3u8 , 68u8 , 68u8 , 208u8 , 224u8 , 135u8 , 105u8 , 39u8 , 181u8 , 84u8 , 78u8 , 255u8 , 187u8 ,]) } # [doc = "The extrinsic sets the rho for a subnet."] # [doc = "It is only callable by the root account or subnet owner."] # [doc = "The extrinsic will call the Subtensor pallet to set the rho."] pub fn sudo_set_rho (& self , netuid : types :: sudo_set_rho :: Netuid , rho : types :: sudo_set_rho :: Rho ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SudoSetRho > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("AdminUtils" , "sudo_set_rho" , types :: SudoSetRho { netuid , rho , } , [247u8 , 201u8 , 129u8 , 7u8 , 140u8 , 8u8 , 44u8 , 187u8 , 145u8 , 159u8 , 173u8 , 106u8 , 243u8 , 66u8 , 226u8 , 229u8 , 119u8 , 59u8 , 102u8 , 130u8 , 226u8 , 228u8 , 76u8 , 160u8 , 0u8 , 118u8 , 217u8 , 103u8 , 36u8 , 73u8 , 72u8 , 25u8 ,]) } # [doc = "The extrinsic sets the activity cutoff for a subnet."] # [doc = "It is only callable by the root account or subnet owner."] # [doc = "The extrinsic will call the Subtensor pallet to set the activity cutoff."] pub fn sudo_set_activity_cutoff (& self , netuid : types :: sudo_set_activity_cutoff :: Netuid , activity_cutoff : types :: sudo_set_activity_cutoff :: ActivityCutoff ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SudoSetActivityCutoff > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("AdminUtils" , "sudo_set_activity_cutoff" , types :: SudoSetActivityCutoff { netuid , activity_cutoff , } , [104u8 , 183u8 , 86u8 , 79u8 , 165u8 , 85u8 , 250u8 , 180u8 , 34u8 , 235u8 , 64u8 , 160u8 , 192u8 , 143u8 , 218u8 , 84u8 , 65u8 , 8u8 , 102u8 , 183u8 , 250u8 , 1u8 , 171u8 , 190u8 , 131u8 , 210u8 , 136u8 , 157u8 , 115u8 , 144u8 , 41u8 , 252u8 ,]) } # [doc = "The extrinsic sets the network registration allowed for a subnet."] # [doc = "It is only callable by the root account or subnet owner."] # [doc = "The extrinsic will call the Subtensor pallet to set the network registration allowed."] pub fn sudo_set_network_registration_allowed (& self , netuid : types :: sudo_set_network_registration_allowed :: Netuid , registration_allowed : types :: sudo_set_network_registration_allowed :: RegistrationAllowed ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SudoSetNetworkRegistrationAllowed > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("AdminUtils" , "sudo_set_network_registration_allowed" , types :: SudoSetNetworkRegistrationAllowed { netuid , registration_allowed , } , [21u8 , 19u8 , 90u8 , 214u8 , 44u8 , 12u8 , 34u8 , 154u8 , 195u8 , 31u8 , 158u8 , 78u8 , 86u8 , 6u8 , 195u8 , 72u8 , 203u8 , 151u8 , 35u8 , 137u8 , 211u8 , 134u8 , 36u8 , 19u8 , 54u8 , 29u8 , 198u8 , 63u8 , 244u8 , 143u8 , 23u8 , 49u8 ,]) } # [doc = "The extrinsic sets the network PoW registration allowed for a subnet."] # [doc = "It is only callable by the root account or subnet owner."] # [doc = "The extrinsic will call the Subtensor pallet to set the network PoW registration allowed."] pub fn sudo_set_network_pow_registration_allowed (& self , netuid : types :: sudo_set_network_pow_registration_allowed :: Netuid , registration_allowed : types :: sudo_set_network_pow_registration_allowed :: RegistrationAllowed ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SudoSetNetworkPowRegistrationAllowed > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("AdminUtils" , "sudo_set_network_pow_registration_allowed" , types :: SudoSetNetworkPowRegistrationAllowed { netuid , registration_allowed , } , [6u8 , 22u8 , 194u8 , 96u8 , 105u8 , 253u8 , 75u8 , 119u8 , 84u8 , 113u8 , 20u8 , 156u8 , 206u8 , 1u8 , 185u8 , 181u8 , 50u8 , 177u8 , 144u8 , 72u8 , 88u8 , 179u8 , 139u8 , 82u8 , 127u8 , 146u8 , 37u8 , 209u8 , 85u8 , 45u8 , 6u8 , 110u8 ,]) } # [doc = "The extrinsic sets the target registrations per interval for a subnet."] # [doc = "It is only callable by the root account."] # [doc = "The extrinsic will call the Subtensor pallet to set the target registrations per interval."] pub fn sudo_set_target_registrations_per_interval (& self , netuid : types :: sudo_set_target_registrations_per_interval :: Netuid , target_registrations_per_interval : types :: sudo_set_target_registrations_per_interval :: TargetRegistrationsPerInterval ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SudoSetTargetRegistrationsPerInterval > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("AdminUtils" , "sudo_set_target_registrations_per_interval" , types :: SudoSetTargetRegistrationsPerInterval { netuid , target_registrations_per_interval , } , [10u8 , 181u8 , 63u8 , 81u8 , 249u8 , 102u8 , 123u8 , 158u8 , 153u8 , 17u8 , 103u8 , 169u8 , 67u8 , 218u8 , 209u8 , 100u8 , 35u8 , 128u8 , 199u8 , 192u8 , 33u8 , 132u8 , 246u8 , 45u8 , 26u8 , 93u8 , 217u8 , 44u8 , 229u8 , 99u8 , 115u8 , 163u8 ,]) } # [doc = "The extrinsic sets the minimum burn for a subnet."] # [doc = "It is only callable by the root account or subnet owner."] # [doc = "The extrinsic will call the Subtensor pallet to set the minimum burn."] pub fn sudo_set_min_burn (& self , netuid : types :: sudo_set_min_burn :: Netuid , min_burn : types :: sudo_set_min_burn :: MinBurn ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SudoSetMinBurn > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("AdminUtils" , "sudo_set_min_burn" , types :: SudoSetMinBurn { netuid , min_burn , } , [39u8 , 205u8 , 135u8 , 231u8 , 239u8 , 14u8 , 206u8 , 154u8 , 11u8 , 23u8 , 136u8 , 38u8 , 231u8 , 204u8 , 93u8 , 14u8 , 135u8 , 177u8 , 230u8 , 85u8 , 229u8 , 132u8 , 47u8 , 161u8 , 2u8 , 44u8 , 234u8 , 67u8 , 7u8 , 186u8 , 26u8 , 194u8 ,]) } # [doc = "The extrinsic sets the maximum burn for a subnet."] # [doc = "It is only callable by the root account or subnet owner."] # [doc = "The extrinsic will call the Subtensor pallet to set the maximum burn."] pub fn sudo_set_max_burn (& self , netuid : types :: sudo_set_max_burn :: Netuid , max_burn : types :: sudo_set_max_burn :: MaxBurn ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SudoSetMaxBurn > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("AdminUtils" , "sudo_set_max_burn" , types :: SudoSetMaxBurn { netuid , max_burn , } , [148u8 , 250u8 , 58u8 , 11u8 , 129u8 , 254u8 , 179u8 , 252u8 , 145u8 , 7u8 , 188u8 , 191u8 , 240u8 , 62u8 , 82u8 , 187u8 , 208u8 , 165u8 , 17u8 , 60u8 , 78u8 , 44u8 , 92u8 , 116u8 , 182u8 , 115u8 , 6u8 , 248u8 , 156u8 , 12u8 , 36u8 , 233u8 ,]) } # [doc = "The extrinsic sets the difficulty for a subnet."] # [doc = "It is only callable by the root account or subnet owner."] # [doc = "The extrinsic will call the Subtensor pallet to set the difficulty."] pub fn sudo_set_difficulty (& self , netuid : types :: sudo_set_difficulty :: Netuid , difficulty : types :: sudo_set_difficulty :: Difficulty ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SudoSetDifficulty > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("AdminUtils" , "sudo_set_difficulty" , types :: SudoSetDifficulty { netuid , difficulty , } , [170u8 , 244u8 , 171u8 , 250u8 , 20u8 , 230u8 , 59u8 , 184u8 , 1u8 , 145u8 , 114u8 , 127u8 , 244u8 , 54u8 , 53u8 , 208u8 , 128u8 , 168u8 , 168u8 , 73u8 , 144u8 , 5u8 , 125u8 , 128u8 , 165u8 , 245u8 , 77u8 , 51u8 , 132u8 , 72u8 , 177u8 , 67u8 ,]) } # [doc = "The extrinsic sets the maximum allowed validators for a subnet."] # [doc = "It is only callable by the root account."] # [doc = "The extrinsic will call the Subtensor pallet to set the maximum allowed validators."] pub fn sudo_set_max_allowed_validators (& self , netuid : types :: sudo_set_max_allowed_validators :: Netuid , max_allowed_validators : types :: sudo_set_max_allowed_validators :: MaxAllowedValidators ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SudoSetMaxAllowedValidators > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("AdminUtils" , "sudo_set_max_allowed_validators" , types :: SudoSetMaxAllowedValidators { netuid , max_allowed_validators , } , [168u8 , 63u8 , 121u8 , 5u8 , 59u8 , 103u8 , 224u8 , 178u8 , 73u8 , 5u8 , 41u8 , 18u8 , 91u8 , 161u8 , 167u8 , 98u8 , 197u8 , 94u8 , 115u8 , 232u8 , 124u8 , 40u8 , 149u8 , 130u8 , 219u8 , 133u8 , 163u8 , 90u8 , 127u8 , 36u8 , 116u8 , 56u8 ,]) } # [doc = "The extrinsic sets the bonds moving average for a subnet."] # [doc = "It is only callable by the root account or subnet owner."] # [doc = "The extrinsic will call the Subtensor pallet to set the bonds moving average."] pub fn sudo_set_bonds_moving_average (& self , netuid : types :: sudo_set_bonds_moving_average :: Netuid , bonds_moving_average : types :: sudo_set_bonds_moving_average :: BondsMovingAverage ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SudoSetBondsMovingAverage > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("AdminUtils" , "sudo_set_bonds_moving_average" , types :: SudoSetBondsMovingAverage { netuid , bonds_moving_average , } , [197u8 , 228u8 , 187u8 , 217u8 , 129u8 , 241u8 , 28u8 , 86u8 , 3u8 , 118u8 , 108u8 , 85u8 , 27u8 , 210u8 , 96u8 , 62u8 , 112u8 , 36u8 , 120u8 , 18u8 , 5u8 , 21u8 , 177u8 , 202u8 , 237u8 , 156u8 , 15u8 , 239u8 , 135u8 , 128u8 , 123u8 , 80u8 ,]) } # [doc = "The extrinsic sets the maximum registrations per block for a subnet."] # [doc = "It is only callable by the root account."] # [doc = "The extrinsic will call the Subtensor pallet to set the maximum registrations per block."] pub fn sudo_set_max_registrations_per_block (& self , netuid : types :: sudo_set_max_registrations_per_block :: Netuid , max_registrations_per_block : types :: sudo_set_max_registrations_per_block :: MaxRegistrationsPerBlock ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SudoSetMaxRegistrationsPerBlock > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("AdminUtils" , "sudo_set_max_registrations_per_block" , types :: SudoSetMaxRegistrationsPerBlock { netuid , max_registrations_per_block , } , [27u8 , 218u8 , 137u8 , 67u8 , 16u8 , 49u8 , 10u8 , 209u8 , 94u8 , 73u8 , 20u8 , 154u8 , 251u8 , 241u8 , 75u8 , 157u8 , 29u8 , 56u8 , 47u8 , 104u8 , 105u8 , 13u8 , 190u8 , 83u8 , 197u8 , 206u8 , 81u8 , 205u8 , 149u8 , 157u8 , 68u8 , 214u8 ,]) } # [doc = "The extrinsic sets the subnet owner cut for a subnet."] # [doc = "It is only callable by the root account."] # [doc = "The extrinsic will call the Subtensor pallet to set the subnet owner cut."] pub fn sudo_set_subnet_owner_cut (& self , subnet_owner_cut : types :: sudo_set_subnet_owner_cut :: SubnetOwnerCut ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SudoSetSubnetOwnerCut > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("AdminUtils" , "sudo_set_subnet_owner_cut" , types :: SudoSetSubnetOwnerCut { subnet_owner_cut , } , [132u8 , 55u8 , 182u8 , 19u8 , 106u8 , 89u8 , 17u8 , 245u8 , 176u8 , 85u8 , 108u8 , 251u8 , 178u8 , 248u8 , 58u8 , 149u8 , 239u8 , 181u8 , 123u8 , 10u8 , 133u8 , 163u8 , 162u8 , 41u8 , 111u8 , 136u8 , 175u8 , 214u8 , 224u8 , 246u8 , 49u8 , 182u8 ,]) } # [doc = "The extrinsic sets the network rate limit for the network."] # [doc = "It is only callable by the root account."] # [doc = "The extrinsic will call the Subtensor pallet to set the network rate limit."] pub fn sudo_set_network_rate_limit (& self , rate_limit : types :: sudo_set_network_rate_limit :: RateLimit ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SudoSetNetworkRateLimit > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("AdminUtils" , "sudo_set_network_rate_limit" , types :: SudoSetNetworkRateLimit { rate_limit , } , [80u8 , 205u8 , 15u8 , 103u8 , 120u8 , 112u8 , 59u8 , 176u8 , 98u8 , 107u8 , 133u8 , 117u8 , 120u8 , 30u8 , 177u8 , 32u8 , 30u8 , 34u8 , 165u8 , 160u8 , 26u8 , 54u8 , 16u8 , 16u8 , 163u8 , 0u8 , 2u8 , 162u8 , 101u8 , 243u8 , 139u8 , 229u8 ,]) } # [doc = "The extrinsic sets the tempo for a subnet."] # [doc = "It is only callable by the root account."] # [doc = "The extrinsic will call the Subtensor pallet to set the tempo."] pub fn sudo_set_tempo (& self , netuid : types :: sudo_set_tempo :: Netuid , tempo : types :: sudo_set_tempo :: Tempo ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SudoSetTempo > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("AdminUtils" , "sudo_set_tempo" , types :: SudoSetTempo { netuid , tempo , } , [247u8 , 138u8 , 12u8 , 190u8 , 212u8 , 116u8 , 202u8 , 23u8 , 211u8 , 97u8 , 119u8 , 181u8 , 146u8 , 75u8 , 46u8 , 220u8 , 22u8 , 204u8 , 141u8 , 52u8 , 88u8 , 214u8 , 135u8 , 182u8 , 164u8 , 193u8 , 45u8 , 15u8 , 241u8 , 66u8 , 54u8 , 228u8 ,]) } # [doc = "The extrinsic sets the total issuance for the network."] # [doc = "It is only callable by the root account."] # [doc = "The extrinsic will call the Subtensor pallet to set the issuance for the network."] pub fn sudo_set_total_issuance (& self , total_issuance : types :: sudo_set_total_issuance :: TotalIssuance ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SudoSetTotalIssuance > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("AdminUtils" , "sudo_set_total_issuance" , types :: SudoSetTotalIssuance { total_issuance , } , [162u8 , 217u8 , 167u8 , 184u8 , 244u8 , 145u8 , 154u8 , 111u8 , 124u8 , 51u8 , 153u8 , 120u8 , 116u8 , 138u8 , 202u8 , 230u8 , 217u8 , 194u8 , 159u8 , 73u8 , 219u8 , 147u8 , 240u8 , 85u8 , 20u8 , 72u8 , 48u8 , 190u8 , 120u8 , 4u8 , 132u8 , 189u8 ,]) } # [doc = "The extrinsic sets the immunity period for the network."] # [doc = "It is only callable by the root account."] # [doc = "The extrinsic will call the Subtensor pallet to set the immunity period for the network."] pub fn sudo_set_network_immunity_period (& self , immunity_period : types :: sudo_set_network_immunity_period :: ImmunityPeriod ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SudoSetNetworkImmunityPeriod > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("AdminUtils" , "sudo_set_network_immunity_period" , types :: SudoSetNetworkImmunityPeriod { immunity_period , } , [197u8 , 175u8 , 164u8 , 18u8 , 236u8 , 31u8 , 34u8 , 133u8 , 149u8 , 203u8 , 9u8 , 43u8 , 172u8 , 248u8 , 165u8 , 68u8 , 77u8 , 243u8 , 60u8 , 88u8 , 124u8 , 67u8 , 165u8 , 231u8 , 47u8 , 26u8 , 92u8 , 32u8 , 242u8 , 13u8 , 150u8 , 230u8 ,]) } # [doc = "The extrinsic sets the min lock cost for the network."] # [doc = "It is only callable by the root account."] # [doc = "The extrinsic will call the Subtensor pallet to set the min lock cost for the network."] pub fn sudo_set_network_min_lock_cost (& self , lock_cost : types :: sudo_set_network_min_lock_cost :: LockCost ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SudoSetNetworkMinLockCost > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("AdminUtils" , "sudo_set_network_min_lock_cost" , types :: SudoSetNetworkMinLockCost { lock_cost , } , [189u8 , 57u8 , 157u8 , 251u8 , 196u8 , 232u8 , 67u8 , 90u8 , 55u8 , 145u8 , 212u8 , 174u8 , 101u8 , 242u8 , 233u8 , 222u8 , 64u8 , 194u8 , 61u8 , 159u8 , 110u8 , 244u8 , 170u8 , 227u8 , 26u8 , 183u8 , 126u8 , 206u8 , 149u8 , 47u8 , 103u8 , 54u8 ,]) } # [doc = "The extrinsic sets the subnet limit for the network."] # [doc = "It is only callable by the root account."] # [doc = "The extrinsic will call the Subtensor pallet to set the subnet limit."] pub fn sudo_set_subnet_limit (& self , max_subnets : types :: sudo_set_subnet_limit :: MaxSubnets ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SudoSetSubnetLimit > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("AdminUtils" , "sudo_set_subnet_limit" , types :: SudoSetSubnetLimit { max_subnets , } , [25u8 , 217u8 , 173u8 , 189u8 , 91u8 , 60u8 , 174u8 , 105u8 , 65u8 , 140u8 , 218u8 , 197u8 , 188u8 , 203u8 , 41u8 , 4u8 , 140u8 , 16u8 , 9u8 , 20u8 , 199u8 , 17u8 , 45u8 , 38u8 , 179u8 , 254u8 , 105u8 , 187u8 , 76u8 , 139u8 , 50u8 , 166u8 ,]) } # [doc = "The extrinsic sets the lock reduction interval for the network."] # [doc = "It is only callable by the root account."] # [doc = "The extrinsic will call the Subtensor pallet to set the lock reduction interval."] pub fn sudo_set_lock_reduction_interval (& self , interval : types :: sudo_set_lock_reduction_interval :: Interval ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SudoSetLockReductionInterval > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("AdminUtils" , "sudo_set_lock_reduction_interval" , types :: SudoSetLockReductionInterval { interval , } , [221u8 , 171u8 , 225u8 , 229u8 , 131u8 , 163u8 , 89u8 , 4u8 , 118u8 , 105u8 , 118u8 , 208u8 , 70u8 , 30u8 , 56u8 , 43u8 , 254u8 , 99u8 , 219u8 , 252u8 , 185u8 , 104u8 , 248u8 , 199u8 , 101u8 , 97u8 , 65u8 , 203u8 , 25u8 , 137u8 , 34u8 , 11u8 ,]) } # [doc = "The extrinsic sets the recycled RAO for a subnet."] # [doc = "It is only callable by the root account."] # [doc = "The extrinsic will call the Subtensor pallet to set the recycled RAO."] pub fn sudo_set_rao_recycled (& self , netuid : types :: sudo_set_rao_recycled :: Netuid , rao_recycled : types :: sudo_set_rao_recycled :: RaoRecycled ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SudoSetRaoRecycled > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("AdminUtils" , "sudo_set_rao_recycled" , types :: SudoSetRaoRecycled { netuid , rao_recycled , } , [207u8 , 226u8 , 150u8 , 214u8 , 192u8 , 206u8 , 215u8 , 101u8 , 222u8 , 190u8 , 18u8 , 204u8 , 21u8 , 137u8 , 102u8 , 155u8 , 247u8 , 19u8 , 46u8 , 142u8 , 113u8 , 226u8 , 102u8 , 110u8 , 186u8 , 35u8 , 5u8 , 18u8 , 182u8 , 144u8 , 7u8 , 198u8 ,]) } # [doc = "The extrinsic sets the weights min stake."] # [doc = "It is only callable by the root account."] # [doc = "The extrinsic will call the Subtensor pallet to set the weights min stake."] pub fn sudo_set_weights_min_stake (& self , min_stake : types :: sudo_set_weights_min_stake :: MinStake ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SudoSetWeightsMinStake > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("AdminUtils" , "sudo_set_weights_min_stake" , types :: SudoSetWeightsMinStake { min_stake , } , [134u8 , 161u8 , 132u8 , 255u8 , 154u8 , 224u8 , 128u8 , 129u8 , 79u8 , 152u8 , 89u8 , 215u8 , 10u8 , 96u8 , 220u8 , 236u8 , 189u8 , 123u8 , 141u8 , 239u8 , 205u8 , 82u8 , 67u8 , 200u8 , 87u8 , 117u8 , 243u8 , 26u8 , 20u8 , 67u8 , 25u8 , 147u8 ,]) } # [doc = "The extrinsic sets the minimum stake required for nominators."] # [doc = "It is only callable by the root account."] # [doc = "The extrinsic will call the Subtensor pallet to set the minimum stake required for nominators."] pub fn sudo_set_nominator_min_required_stake (& self , min_stake : types :: sudo_set_nominator_min_required_stake :: MinStake ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SudoSetNominatorMinRequiredStake > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("AdminUtils" , "sudo_set_nominator_min_required_stake" , types :: SudoSetNominatorMinRequiredStake { min_stake , } , [52u8 , 138u8 , 94u8 , 243u8 , 75u8 , 152u8 , 41u8 , 87u8 , 240u8 , 38u8 , 95u8 , 95u8 , 195u8 , 26u8 , 194u8 , 2u8 , 61u8 , 66u8 , 215u8 , 188u8 , 102u8 , 124u8 , 81u8 , 138u8 , 108u8 , 241u8 , 152u8 , 54u8 , 148u8 , 204u8 , 33u8 , 193u8 ,]) } # [doc = "The extrinsic sets the rate limit for delegate take transactions."] # [doc = "It is only callable by the root account."] # [doc = "The extrinsic will call the Subtensor pallet to set the rate limit for delegate take transactions."] pub fn sudo_set_tx_delegate_take_rate_limit (& self , tx_rate_limit : types :: sudo_set_tx_delegate_take_rate_limit :: TxRateLimit ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SudoSetTxDelegateTakeRateLimit > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("AdminUtils" , "sudo_set_tx_delegate_take_rate_limit" , types :: SudoSetTxDelegateTakeRateLimit { tx_rate_limit , } , [125u8 , 86u8 , 21u8 , 0u8 , 119u8 , 226u8 , 173u8 , 244u8 , 139u8 , 192u8 , 238u8 , 238u8 , 36u8 , 45u8 , 63u8 , 40u8 , 222u8 , 209u8 , 96u8 , 74u8 , 155u8 , 180u8 , 128u8 , 160u8 , 154u8 , 147u8 , 119u8 , 178u8 , 133u8 , 65u8 , 6u8 , 251u8 ,]) } # [doc = "The extrinsic sets the minimum delegate take."] # [doc = "It is only callable by the root account."] # [doc = "The extrinsic will call the Subtensor pallet to set the minimum delegate take."] pub fn sudo_set_min_delegate_take (& self , take : types :: sudo_set_min_delegate_take :: Take ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SudoSetMinDelegateTake > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("AdminUtils" , "sudo_set_min_delegate_take" , types :: SudoSetMinDelegateTake { take , } , [32u8 , 246u8 , 17u8 , 76u8 , 122u8 , 253u8 , 253u8 , 35u8 , 170u8 , 237u8 , 51u8 , 106u8 , 51u8 , 184u8 , 137u8 , 227u8 , 101u8 , 227u8 , 224u8 , 112u8 , 28u8 , 60u8 , 62u8 , 165u8 , 14u8 , 209u8 , 74u8 , 157u8 , 52u8 , 166u8 , 52u8 , 238u8 ,]) } # [doc = "The extrinsic sets the target stake per interval."] # [doc = "It is only callable by the root account."] # [doc = "The extrinsic will call the Subtensor pallet to set target stake per interval."] pub fn sudo_set_target_stakes_per_interval (& self , target_stakes_per_interval : types :: sudo_set_target_stakes_per_interval :: TargetStakesPerInterval ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SudoSetTargetStakesPerInterval > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("AdminUtils" , "sudo_set_target_stakes_per_interval" , types :: SudoSetTargetStakesPerInterval { target_stakes_per_interval , } , [229u8 , 22u8 , 41u8 , 127u8 , 93u8 , 67u8 , 45u8 , 128u8 , 0u8 , 84u8 , 76u8 , 94u8 , 174u8 , 143u8 , 136u8 , 116u8 , 76u8 , 213u8 , 173u8 , 246u8 , 56u8 , 239u8 , 116u8 , 21u8 , 210u8 , 198u8 , 6u8 , 127u8 , 182u8 , 8u8 , 34u8 , 79u8 ,]) } # [doc = "The extrinsic sets the commit/reveal interval for a subnet."] # [doc = "It is only callable by the root account or subnet owner."] # [doc = "The extrinsic will call the Subtensor pallet to set the interval."] pub fn sudo_set_commit_reveal_weights_interval (& self , netuid : types :: sudo_set_commit_reveal_weights_interval :: Netuid , interval : types :: sudo_set_commit_reveal_weights_interval :: Interval ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SudoSetCommitRevealWeightsInterval > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("AdminUtils" , "sudo_set_commit_reveal_weights_interval" , types :: SudoSetCommitRevealWeightsInterval { netuid , interval , } , [210u8 , 74u8 , 26u8 , 27u8 , 184u8 , 236u8 , 169u8 , 182u8 , 228u8 , 184u8 , 30u8 , 170u8 , 224u8 , 240u8 , 251u8 , 220u8 , 147u8 , 188u8 , 160u8 , 149u8 , 137u8 , 146u8 , 58u8 , 166u8 , 165u8 , 105u8 , 112u8 , 133u8 , 74u8 , 142u8 , 100u8 , 109u8 ,]) } # [doc = "The extrinsic enabled/disables commit/reaveal for a given subnet."] # [doc = "It is only callable by the root account or subnet owner."] # [doc = "The extrinsic will call the Subtensor pallet to set the value."] pub fn sudo_set_commit_reveal_weights_enabled (& self , netuid : types :: sudo_set_commit_reveal_weights_enabled :: Netuid , enabled : types :: sudo_set_commit_reveal_weights_enabled :: Enabled ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SudoSetCommitRevealWeightsEnabled > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("AdminUtils" , "sudo_set_commit_reveal_weights_enabled" , types :: SudoSetCommitRevealWeightsEnabled { netuid , enabled , } , [100u8 , 156u8 , 214u8 , 108u8 , 188u8 , 232u8 , 181u8 , 31u8 , 116u8 , 58u8 , 182u8 , 165u8 , 116u8 , 253u8 , 112u8 , 89u8 , 50u8 , 80u8 , 234u8 , 230u8 , 194u8 , 38u8 , 191u8 , 56u8 , 122u8 , 183u8 , 196u8 , 246u8 , 197u8 , 234u8 , 157u8 , 58u8 ,]) } # [doc = "Enables or disables Liquid Alpha for a given subnet."] # [doc = ""] # [doc = "# Parameters"] # [doc = "- `origin`: The origin of the call, which must be the root account or subnet owner."] # [doc = "- `netuid`: The unique identifier for the subnet."] # [doc = "- `enabled`: A boolean flag to enable or disable Liquid Alpha."] # [doc = ""] # [doc = "# Weight"] # [doc = "This function has a fixed weight of 0 and is classified as an operational transaction that does not incur any fees."] pub fn sudo_set_liquid_alpha_enabled (& self , netuid : types :: sudo_set_liquid_alpha_enabled :: Netuid , enabled : types :: sudo_set_liquid_alpha_enabled :: Enabled ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SudoSetLiquidAlphaEnabled > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("AdminUtils" , "sudo_set_liquid_alpha_enabled" , types :: SudoSetLiquidAlphaEnabled { netuid , enabled , } , [242u8 , 8u8 , 226u8 , 26u8 , 57u8 , 134u8 , 135u8 , 70u8 , 116u8 , 96u8 , 123u8 , 109u8 , 177u8 , 0u8 , 154u8 , 52u8 , 66u8 , 33u8 , 239u8 , 8u8 , 70u8 , 30u8 , 183u8 , 55u8 , 193u8 , 89u8 , 44u8 , 193u8 , 149u8 , 225u8 , 17u8 , 58u8 ,]) } # [doc = "Sets values for liquid alpha"] pub fn sudo_set_alpha_values (& self , netuid : types :: sudo_set_alpha_values :: Netuid , alpha_low : types :: sudo_set_alpha_values :: AlphaLow , alpha_high : types :: sudo_set_alpha_values :: AlphaHigh ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SudoSetAlphaValues > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("AdminUtils" , "sudo_set_alpha_values" , types :: SudoSetAlphaValues { netuid , alpha_low , alpha_high , } , [80u8 , 38u8 , 69u8 , 27u8 , 24u8 , 45u8 , 140u8 , 4u8 , 25u8 , 106u8 , 202u8 , 185u8 , 137u8 , 142u8 , 91u8 , 102u8 , 173u8 , 48u8 , 168u8 , 66u8 , 51u8 , 99u8 , 104u8 , 192u8 , 56u8 , 11u8 , 94u8 , 60u8 , 72u8 , 58u8 , 132u8 , 66u8 ,]) } # [doc = "Sets the hotkey emission tempo."] # [doc = ""] # [doc = "This extrinsic allows the root account to set the hotkey emission tempo, which determines"] # [doc = "the number of blocks before a hotkey drains accumulated emissions through to nominator staking accounts."] # [doc = ""] # [doc = "# Arguments"] # [doc = "* `origin` - The origin of the call, which must be the root account."] # [doc = "* `emission_tempo` - The new emission tempo value to set."] # [doc = ""] # [doc = "# Emits"] # [doc = "* `Event::HotkeyEmissionTempoSet` - When the hotkey emission tempo is successfully set."] # [doc = ""] # [doc = "# Errors"] # [doc = "* `DispatchError::BadOrigin` - If the origin is not the root account."] pub fn sudo_set_hotkey_emission_tempo (& self , emission_tempo : types :: sudo_set_hotkey_emission_tempo :: EmissionTempo ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SudoSetHotkeyEmissionTempo > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("AdminUtils" , "sudo_set_hotkey_emission_tempo" , types :: SudoSetHotkeyEmissionTempo { emission_tempo , } , [31u8 , 129u8 , 123u8 , 203u8 , 12u8 , 207u8 , 105u8 , 104u8 , 85u8 , 22u8 , 240u8 , 35u8 , 27u8 , 154u8 , 56u8 , 53u8 , 33u8 , 43u8 , 3u8 , 64u8 , 212u8 , 20u8 , 198u8 , 147u8 , 31u8 , 47u8 , 129u8 , 35u8 , 210u8 , 97u8 , 127u8 , 223u8 ,]) } # [doc = "Sets the maximum stake allowed for a specific network."] # [doc = ""] # [doc = "This function allows the root account to set the maximum stake for a given network."] # [doc = "It updates the network's maximum stake value and logs the change."] # [doc = ""] # [doc = "# Arguments"] # [doc = ""] # [doc = "* `origin` - The origin of the call, which must be the root account."] # [doc = "* `netuid` - The unique identifier of the network."] # [doc = "* `max_stake` - The new maximum stake value to set."] # [doc = ""] # [doc = "# Returns"] # [doc = ""] # [doc = "Returns `Ok(())` if the operation is successful, or an error if it fails."] # [doc = ""] # [doc = "# Example"] # [doc = ""] # [doc = ""] # [doc = "# Notes"] # [doc = ""] # [doc = "- This function can only be called by the root account."] # [doc = "- The `netuid` should correspond to an existing network."] # [doc = ""] # [doc = "# TODO"] # [doc = ""] pub fn sudo_set_network_max_stake (& self , netuid : types :: sudo_set_network_max_stake :: Netuid , max_stake : types :: sudo_set_network_max_stake :: MaxStake ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SudoSetNetworkMaxStake > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("AdminUtils" , "sudo_set_network_max_stake" , types :: SudoSetNetworkMaxStake { netuid , max_stake , } , [69u8 , 67u8 , 125u8 , 102u8 , 98u8 , 128u8 , 26u8 , 151u8 , 122u8 , 88u8 , 203u8 , 76u8 , 34u8 , 22u8 , 250u8 , 176u8 , 175u8 , 209u8 , 38u8 , 230u8 , 95u8 , 180u8 , 61u8 , 201u8 , 108u8 , 14u8 , 91u8 , 188u8 , 107u8 , 3u8 , 43u8 , 54u8 ,]) } # [doc = "Sets the duration of the coldkey swap schedule."] # [doc = ""] # [doc = "This extrinsic allows the root account to set the duration for the coldkey swap schedule."] # [doc = "The coldkey swap schedule determines how long it takes for a coldkey swap operation to complete."] # [doc = ""] # [doc = "# Arguments"] # [doc = "* `origin` - The origin of the call, which must be the root account."] # [doc = "* `duration` - The new duration for the coldkey swap schedule, in number of blocks."] # [doc = ""] # [doc = "# Errors"] # [doc = "* `BadOrigin` - If the caller is not the root account."] # [doc = ""] # [doc = "# Weight"] # [doc = "Weight is handled by the `#[pallet::weight]` attribute."] pub fn sudo_set_coldkey_swap_schedule_duration (& self , duration : types :: sudo_set_coldkey_swap_schedule_duration :: Duration ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SudoSetColdkeySwapScheduleDuration > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("AdminUtils" , "sudo_set_coldkey_swap_schedule_duration" , types :: SudoSetColdkeySwapScheduleDuration { duration , } , [199u8 , 201u8 , 247u8 , 19u8 , 96u8 , 161u8 , 154u8 , 250u8 , 35u8 , 223u8 , 124u8 , 42u8 , 248u8 , 27u8 , 33u8 , 92u8 , 156u8 , 4u8 , 124u8 , 167u8 , 119u8 , 192u8 , 3u8 , 185u8 , 2u8 , 128u8 , 216u8 , 52u8 , 203u8 , 168u8 , 16u8 , 15u8 ,]) } # [doc = "Sets the duration of the dissolve network schedule."] # [doc = ""] # [doc = "This extrinsic allows the root account to set the duration for the dissolve network schedule."] # [doc = "The dissolve network schedule determines how long it takes for a network dissolution operation to complete."] # [doc = ""] # [doc = "# Arguments"] # [doc = "* `origin` - The origin of the call, which must be the root account."] # [doc = "* `duration` - The new duration for the dissolve network schedule, in number of blocks."] # [doc = ""] # [doc = "# Errors"] # [doc = "* `BadOrigin` - If the caller is not the root account."] # [doc = ""] # [doc = "# Weight"] # [doc = "Weight is handled by the `#[pallet::weight]` attribute."] pub fn sudo_set_dissolve_network_schedule_duration (& self , duration : types :: sudo_set_dissolve_network_schedule_duration :: Duration ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SudoSetDissolveNetworkScheduleDuration > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("AdminUtils" , "sudo_set_dissolve_network_schedule_duration" , types :: SudoSetDissolveNetworkScheduleDuration { duration , } , [149u8 , 251u8 , 253u8 , 178u8 , 31u8 , 46u8 , 195u8 , 105u8 , 168u8 , 36u8 , 24u8 , 10u8 , 184u8 , 27u8 , 101u8 , 94u8 , 14u8 , 204u8 , 207u8 , 236u8 , 84u8 , 171u8 , 34u8 , 39u8 , 103u8 , 150u8 , 25u8 , 76u8 , 141u8 , 152u8 , 56u8 , 142u8 ,]) } } } # [doc = "The `Event` enum of this pallet"] pub type Event = runtime_types :: pallet_admin_utils :: pallet :: Event ; pub mod events { use super :: runtime_types ; } } pub mod safe_mode { use super :: root_mod ; use super :: runtime_types ; # [doc = "The `Error` enum of this pallet."] pub type Error = runtime_types :: pallet_safe_mode :: pallet :: Error ; # [doc = "Contains a variant per dispatchable extrinsic that this pallet has."] pub type Call = runtime_types :: pallet_safe_mode :: pallet :: Call ; pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; pub mod types { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Enter safe-mode permissionlessly for [`Config::EnterDuration`] blocks."] # [doc = ""] # [doc = "Reserves [`Config::EnterDepositAmount`] from the caller's account."] # [doc = "Emits an [`Event::Entered`] event on success."] # [doc = "Errors with [`Error::Entered`] if the safe-mode is already entered."] # [doc = "Errors with [`Error::NotConfigured`] if the deposit amount is `None`."] pub struct Enter ; impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for Enter { const PALLET : & 'static str = "SafeMode" ; const CALL : & 'static str = "enter" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Enter safe-mode by force for a per-origin configured number of blocks."] # [doc = ""] # [doc = "Emits an [`Event::Entered`] event on success."] # [doc = "Errors with [`Error::Entered`] if the safe-mode is already entered."] # [doc = ""] # [doc = "Can only be called by the [`Config::ForceEnterOrigin`] origin."] pub struct ForceEnter ; impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for ForceEnter { const PALLET : & 'static str = "SafeMode" ; const CALL : & 'static str = "force_enter" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Extend the safe-mode permissionlessly for [`Config::ExtendDuration`] blocks."] # [doc = ""] # [doc = "This accumulates on top of the current remaining duration."] # [doc = "Reserves [`Config::ExtendDepositAmount`] from the caller's account."] # [doc = "Emits an [`Event::Extended`] event on success."] # [doc = "Errors with [`Error::Exited`] if the safe-mode is entered."] # [doc = "Errors with [`Error::NotConfigured`] if the deposit amount is `None`."] # [doc = ""] # [doc = "This may be called by any signed origin with [`Config::ExtendDepositAmount`] free"] # [doc = "currency to reserve. This call can be disabled for all origins by configuring"] # [doc = "[`Config::ExtendDepositAmount`] to `None`."] pub struct Extend ; impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for Extend { const PALLET : & 'static str = "SafeMode" ; const CALL : & 'static str = "extend" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Extend the safe-mode by force for a per-origin configured number of blocks."] # [doc = ""] # [doc = "Emits an [`Event::Extended`] event on success."] # [doc = "Errors with [`Error::Exited`] if the safe-mode is inactive."] # [doc = ""] # [doc = "Can only be called by the [`Config::ForceExtendOrigin`] origin."] pub struct ForceExtend ; impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for ForceExtend { const PALLET : & 'static str = "SafeMode" ; const CALL : & 'static str = "force_extend" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Exit safe-mode by force."] # [doc = ""] # [doc = "Emits an [`Event::Exited`] with [`ExitReason::Force`] event on success."] # [doc = "Errors with [`Error::Exited`] if the safe-mode is inactive."] # [doc = ""] # [doc = "Note: `safe-mode` will be automatically deactivated by [`Pallet::on_initialize`] hook"] # [doc = "after the block height is greater than the [`EnteredUntil`] storage item."] # [doc = "Emits an [`Event::Exited`] with [`ExitReason::Timeout`] event when deactivated in the"] # [doc = "hook."] pub struct ForceExit ; impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for ForceExit { const PALLET : & 'static str = "SafeMode" ; const CALL : & 'static str = "force_exit" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Slash a deposit for an account that entered or extended safe-mode at a given"] # [doc = "historical block."] # [doc = ""] # [doc = "This can only be called while safe-mode is entered."] # [doc = ""] # [doc = "Emits a [`Event::DepositSlashed`] event on success."] # [doc = "Errors with [`Error::Entered`] if safe-mode is entered."] # [doc = ""] # [doc = "Can only be called by the [`Config::ForceDepositOrigin`] origin."] pub struct ForceSlashDeposit { pub account : force_slash_deposit :: Account , pub block : force_slash_deposit :: Block , } pub mod force_slash_deposit { use super :: runtime_types ; pub type Account = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Block = :: core :: primitive :: u32 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for ForceSlashDeposit { const PALLET : & 'static str = "SafeMode" ; const CALL : & 'static str = "force_slash_deposit" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Permissionlessly release a deposit for an account that entered safe-mode at a"] # [doc = "given historical block."] # [doc = ""] # [doc = "The call can be completely disabled by setting [`Config::ReleaseDelay`] to `None`."] # [doc = "This cannot be called while safe-mode is entered and not until"] # [doc = "[`Config::ReleaseDelay`] blocks have passed since safe-mode was entered."] # [doc = ""] # [doc = "Emits a [`Event::DepositReleased`] event on success."] # [doc = "Errors with [`Error::Entered`] if the safe-mode is entered."] # [doc = "Errors with [`Error::CannotReleaseYet`] if [`Config::ReleaseDelay`] block have not"] # [doc = "passed since safe-mode was entered. Errors with [`Error::NoDeposit`] if the payee has no"] # [doc = "reserved currency at the block specified."] pub struct ReleaseDeposit { pub account : release_deposit :: Account , pub block : release_deposit :: Block , } pub mod release_deposit { use super :: runtime_types ; pub type Account = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Block = :: core :: primitive :: u32 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for ReleaseDeposit { const PALLET : & 'static str = "SafeMode" ; const CALL : & 'static str = "release_deposit" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Force to release a deposit for an account that entered safe-mode at a given"] # [doc = "historical block."] # [doc = ""] # [doc = "This can be called while safe-mode is still entered."] # [doc = ""] # [doc = "Emits a [`Event::DepositReleased`] event on success."] # [doc = "Errors with [`Error::Entered`] if safe-mode is entered."] # [doc = "Errors with [`Error::NoDeposit`] if the payee has no reserved currency at the"] # [doc = "specified block."] # [doc = ""] # [doc = "Can only be called by the [`Config::ForceDepositOrigin`] origin."] pub struct ForceReleaseDeposit { pub account : force_release_deposit :: Account , pub block : force_release_deposit :: Block , } pub mod force_release_deposit { use super :: runtime_types ; pub type Account = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Block = :: core :: primitive :: u32 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for ForceReleaseDeposit { const PALLET : & 'static str = "SafeMode" ; const CALL : & 'static str = "force_release_deposit" ; } } pub struct TransactionApi ; impl TransactionApi { # [doc = "Enter safe-mode permissionlessly for [`Config::EnterDuration`] blocks."] # [doc = ""] # [doc = "Reserves [`Config::EnterDepositAmount`] from the caller's account."] # [doc = "Emits an [`Event::Entered`] event on success."] # [doc = "Errors with [`Error::Entered`] if the safe-mode is already entered."] # [doc = "Errors with [`Error::NotConfigured`] if the deposit amount is `None`."] pub fn enter (& self ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: Enter > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("SafeMode" , "enter" , types :: Enter { } , [143u8 , 123u8 , 102u8 , 22u8 , 143u8 , 240u8 , 102u8 , 20u8 , 99u8 , 56u8 , 137u8 , 160u8 , 145u8 , 237u8 , 239u8 , 13u8 , 116u8 , 150u8 , 190u8 , 85u8 , 39u8 , 235u8 , 252u8 , 175u8 , 118u8 , 60u8 , 231u8 , 161u8 , 61u8 , 100u8 , 140u8 , 15u8 ,]) } # [doc = "Enter safe-mode by force for a per-origin configured number of blocks."] # [doc = ""] # [doc = "Emits an [`Event::Entered`] event on success."] # [doc = "Errors with [`Error::Entered`] if the safe-mode is already entered."] # [doc = ""] # [doc = "Can only be called by the [`Config::ForceEnterOrigin`] origin."] pub fn force_enter (& self ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: ForceEnter > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("SafeMode" , "force_enter" , types :: ForceEnter { } , [226u8 , 76u8 , 165u8 , 0u8 , 74u8 , 155u8 , 226u8 , 0u8 , 184u8 , 63u8 , 229u8 , 216u8 , 13u8 , 44u8 , 211u8 , 141u8 , 82u8 , 33u8 , 38u8 , 220u8 , 228u8 , 13u8 , 105u8 , 40u8 , 3u8 , 101u8 , 98u8 , 149u8 , 169u8 , 196u8 , 135u8 , 108u8 ,]) } # [doc = "Extend the safe-mode permissionlessly for [`Config::ExtendDuration`] blocks."] # [doc = ""] # [doc = "This accumulates on top of the current remaining duration."] # [doc = "Reserves [`Config::ExtendDepositAmount`] from the caller's account."] # [doc = "Emits an [`Event::Extended`] event on success."] # [doc = "Errors with [`Error::Exited`] if the safe-mode is entered."] # [doc = "Errors with [`Error::NotConfigured`] if the deposit amount is `None`."] # [doc = ""] # [doc = "This may be called by any signed origin with [`Config::ExtendDepositAmount`] free"] # [doc = "currency to reserve. This call can be disabled for all origins by configuring"] # [doc = "[`Config::ExtendDepositAmount`] to `None`."] pub fn extend (& self ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: Extend > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("SafeMode" , "extend" , types :: Extend { } , [197u8 , 120u8 , 159u8 , 140u8 , 252u8 , 237u8 , 41u8 , 35u8 , 158u8 , 68u8 , 143u8 , 99u8 , 156u8 , 153u8 , 190u8 , 6u8 , 220u8 , 153u8 , 207u8 , 98u8 , 126u8 , 27u8 , 29u8 , 118u8 , 77u8 , 69u8 , 135u8 , 20u8 , 66u8 , 170u8 , 240u8 , 129u8 ,]) } # [doc = "Extend the safe-mode by force for a per-origin configured number of blocks."] # [doc = ""] # [doc = "Emits an [`Event::Extended`] event on success."] # [doc = "Errors with [`Error::Exited`] if the safe-mode is inactive."] # [doc = ""] # [doc = "Can only be called by the [`Config::ForceExtendOrigin`] origin."] pub fn force_extend (& self ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: ForceExtend > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("SafeMode" , "force_extend" , types :: ForceExtend { } , [117u8 , 88u8 , 218u8 , 135u8 , 217u8 , 109u8 , 142u8 , 56u8 , 165u8 , 247u8 , 37u8 , 236u8 , 158u8 , 153u8 , 199u8 , 154u8 , 70u8 , 17u8 , 19u8 , 225u8 , 184u8 , 126u8 , 169u8 , 246u8 , 187u8 , 96u8 , 124u8 , 117u8 , 3u8 , 122u8 , 185u8 , 255u8 ,]) } # [doc = "Exit safe-mode by force."] # [doc = ""] # [doc = "Emits an [`Event::Exited`] with [`ExitReason::Force`] event on success."] # [doc = "Errors with [`Error::Exited`] if the safe-mode is inactive."] # [doc = ""] # [doc = "Note: `safe-mode` will be automatically deactivated by [`Pallet::on_initialize`] hook"] # [doc = "after the block height is greater than the [`EnteredUntil`] storage item."] # [doc = "Emits an [`Event::Exited`] with [`ExitReason::Timeout`] event when deactivated in the"] # [doc = "hook."] pub fn force_exit (& self ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: ForceExit > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("SafeMode" , "force_exit" , types :: ForceExit { } , [150u8 , 4u8 , 38u8 , 204u8 , 101u8 , 158u8 , 83u8 , 108u8 , 144u8 , 146u8 , 91u8 , 227u8 , 118u8 , 59u8 , 39u8 , 160u8 , 157u8 , 68u8 , 241u8 , 12u8 , 42u8 , 108u8 , 196u8 , 221u8 , 241u8 , 61u8 , 142u8 , 140u8 , 174u8 , 224u8 , 33u8 , 213u8 ,]) } # [doc = "Slash a deposit for an account that entered or extended safe-mode at a given"] # [doc = "historical block."] # [doc = ""] # [doc = "This can only be called while safe-mode is entered."] # [doc = ""] # [doc = "Emits a [`Event::DepositSlashed`] event on success."] # [doc = "Errors with [`Error::Entered`] if safe-mode is entered."] # [doc = ""] # [doc = "Can only be called by the [`Config::ForceDepositOrigin`] origin."] pub fn force_slash_deposit (& self , account : types :: force_slash_deposit :: Account , block : types :: force_slash_deposit :: Block ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: ForceSlashDeposit > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("SafeMode" , "force_slash_deposit" , types :: ForceSlashDeposit { account , block , } , [185u8 , 154u8 , 173u8 , 77u8 , 150u8 , 104u8 , 220u8 , 14u8 , 65u8 , 197u8 , 253u8 , 145u8 , 112u8 , 189u8 , 99u8 , 45u8 , 138u8 , 120u8 , 94u8 , 112u8 , 183u8 , 205u8 , 206u8 , 14u8 , 74u8 , 9u8 , 156u8 , 76u8 , 159u8 , 37u8 , 88u8 , 96u8 ,]) } # [doc = "Permissionlessly release a deposit for an account that entered safe-mode at a"] # [doc = "given historical block."] # [doc = ""] # [doc = "The call can be completely disabled by setting [`Config::ReleaseDelay`] to `None`."] # [doc = "This cannot be called while safe-mode is entered and not until"] # [doc = "[`Config::ReleaseDelay`] blocks have passed since safe-mode was entered."] # [doc = ""] # [doc = "Emits a [`Event::DepositReleased`] event on success."] # [doc = "Errors with [`Error::Entered`] if the safe-mode is entered."] # [doc = "Errors with [`Error::CannotReleaseYet`] if [`Config::ReleaseDelay`] block have not"] # [doc = "passed since safe-mode was entered. Errors with [`Error::NoDeposit`] if the payee has no"] # [doc = "reserved currency at the block specified."] pub fn release_deposit (& self , account : types :: release_deposit :: Account , block : types :: release_deposit :: Block ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: ReleaseDeposit > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("SafeMode" , "release_deposit" , types :: ReleaseDeposit { account , block , } , [79u8 , 18u8 , 165u8 , 136u8 , 30u8 , 45u8 , 169u8 , 102u8 , 195u8 , 112u8 , 252u8 , 42u8 , 52u8 , 65u8 , 93u8 , 168u8 , 40u8 , 180u8 , 234u8 , 248u8 , 20u8 , 157u8 , 147u8 , 84u8 , 89u8 , 168u8 , 219u8 , 160u8 , 193u8 , 170u8 , 95u8 , 20u8 ,]) } # [doc = "Force to release a deposit for an account that entered safe-mode at a given"] # [doc = "historical block."] # [doc = ""] # [doc = "This can be called while safe-mode is still entered."] # [doc = ""] # [doc = "Emits a [`Event::DepositReleased`] event on success."] # [doc = "Errors with [`Error::Entered`] if safe-mode is entered."] # [doc = "Errors with [`Error::NoDeposit`] if the payee has no reserved currency at the"] # [doc = "specified block."] # [doc = ""] # [doc = "Can only be called by the [`Config::ForceDepositOrigin`] origin."] pub fn force_release_deposit (& self , account : types :: force_release_deposit :: Account , block : types :: force_release_deposit :: Block ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: ForceReleaseDeposit > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("SafeMode" , "force_release_deposit" , types :: ForceReleaseDeposit { account , block , } , [32u8 , 21u8 , 194u8 , 117u8 , 164u8 , 105u8 , 175u8 , 6u8 , 77u8 , 183u8 , 153u8 , 93u8 , 76u8 , 102u8 , 49u8 , 232u8 , 124u8 , 27u8 , 90u8 , 189u8 , 75u8 , 76u8 , 6u8 , 144u8 , 232u8 , 51u8 , 152u8 , 207u8 , 122u8 , 162u8 , 232u8 , 236u8 ,]) } } } # [doc = "The `Event` enum of this pallet"] pub type Event = runtime_types :: pallet_safe_mode :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The safe-mode was entered until inclusively this block."] pub struct Entered { pub until : entered :: Until , } pub mod entered { use super :: runtime_types ; pub type Until = :: core :: primitive :: u32 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Entered { const PALLET : & 'static str = "SafeMode" ; const EVENT : & 'static str = "Entered" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The safe-mode was extended until inclusively this block."] pub struct Extended { pub until : extended :: Until , } pub mod extended { use super :: runtime_types ; pub type Until = :: core :: primitive :: u32 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Extended { const PALLET : & 'static str = "SafeMode" ; const EVENT : & 'static str = "Extended" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Exited the safe-mode for a specific reason."] pub struct Exited { pub reason : exited :: Reason , } pub mod exited { use super :: runtime_types ; pub type Reason = runtime_types :: pallet_safe_mode :: pallet :: ExitReason ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Exited { const PALLET : & 'static str = "SafeMode" ; const EVENT : & 'static str = "Exited" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "An account reserved funds for either entering or extending the safe-mode."] pub struct DepositPlaced { pub account : deposit_placed :: Account , pub amount : deposit_placed :: Amount , } pub mod deposit_placed { use super :: runtime_types ; pub type Account = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Amount = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for DepositPlaced { const PALLET : & 'static str = "SafeMode" ; const EVENT : & 'static str = "DepositPlaced" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "An account had a reserve released that was reserved."] pub struct DepositReleased { pub account : deposit_released :: Account , pub amount : deposit_released :: Amount , } pub mod deposit_released { use super :: runtime_types ; pub type Account = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Amount = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for DepositReleased { const PALLET : & 'static str = "SafeMode" ; const EVENT : & 'static str = "DepositReleased" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "An account had reserve slashed that was reserved."] pub struct DepositSlashed { pub account : deposit_slashed :: Account , pub amount : deposit_slashed :: Amount , } pub mod deposit_slashed { use super :: runtime_types ; pub type Account = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Amount = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for DepositSlashed { const PALLET : & 'static str = "SafeMode" ; const EVENT : & 'static str = "DepositSlashed" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Could not hold funds for entering or extending the safe-mode."] # [doc = ""] # [doc = "This error comes from the underlying `Currency`."] pub struct CannotDeposit ; impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for CannotDeposit { const PALLET : & 'static str = "SafeMode" ; const EVENT : & 'static str = "CannotDeposit" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Could not release funds for entering or extending the safe-mode."] # [doc = ""] # [doc = "This error comes from the underlying `Currency`."] pub struct CannotRelease ; impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for CannotRelease { const PALLET : & 'static str = "SafeMode" ; const EVENT : & 'static str = "CannotRelease" ; } } pub mod storage { use super :: runtime_types ; pub mod types { use super :: runtime_types ; pub mod entered_until { use super :: runtime_types ; pub type EnteredUntil = :: core :: primitive :: u32 ; } pub mod deposits { use super :: runtime_types ; pub type Deposits = :: core :: primitive :: u64 ; pub type Param0 = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Param1 = :: core :: primitive :: u32 ; } } pub struct StorageApi ; impl StorageApi { # [doc = " Contains the last block number that the safe-mode will remain entered in."] # [doc = ""] # [doc = "  Set to `None` when safe-mode is exited."] # [doc = ""] # [doc = " Safe-mode is automatically exited when the current block number exceeds this value."] pub fn entered_until (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: entered_until :: EnteredUntil , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SafeMode" , "EnteredUntil" , () , [149u8 , 83u8 , 42u8 , 40u8 , 74u8 , 142u8 , 60u8 , 30u8 , 84u8 , 16u8 , 188u8 , 31u8 , 142u8 , 15u8 , 123u8 , 243u8 , 224u8 , 219u8 , 21u8 , 109u8 , 199u8 , 124u8 , 169u8 , 154u8 , 35u8 , 198u8 , 136u8 , 36u8 , 202u8 , 218u8 , 15u8 , 107u8 ,]) } # [doc = " Holds the reserve that was taken from an account at a specific block number."] # [doc = ""] # [doc = " This helps governance to have an overview of outstanding deposits that should be returned or"] # [doc = " slashed."] pub fn deposits_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: deposits :: Deposits , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SafeMode" , "Deposits" , () , [176u8 , 188u8 , 87u8 , 205u8 , 141u8 , 232u8 , 186u8 , 203u8 , 180u8 , 156u8 , 184u8 , 200u8 , 6u8 , 114u8 , 214u8 , 126u8 , 136u8 , 106u8 , 101u8 , 42u8 , 25u8 , 127u8 , 61u8 , 171u8 , 50u8 , 143u8 , 221u8 , 176u8 , 245u8 , 232u8 , 30u8 , 3u8 ,]) } # [doc = " Holds the reserve that was taken from an account at a specific block number."] # [doc = ""] # [doc = " This helps governance to have an overview of outstanding deposits that should be returned or"] # [doc = " slashed."] pub fn deposits_iter1 (& self , _0 : impl :: core :: borrow :: Borrow < types :: deposits :: Param0 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: deposits :: Param0 > , types :: deposits :: Deposits , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SafeMode" , "Deposits" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , [176u8 , 188u8 , 87u8 , 205u8 , 141u8 , 232u8 , 186u8 , 203u8 , 180u8 , 156u8 , 184u8 , 200u8 , 6u8 , 114u8 , 214u8 , 126u8 , 136u8 , 106u8 , 101u8 , 42u8 , 25u8 , 127u8 , 61u8 , 171u8 , 50u8 , 143u8 , 221u8 , 176u8 , 245u8 , 232u8 , 30u8 , 3u8 ,]) } # [doc = " Holds the reserve that was taken from an account at a specific block number."] # [doc = ""] # [doc = " This helps governance to have an overview of outstanding deposits that should be returned or"] # [doc = " slashed."] pub fn deposits (& self , _0 : impl :: core :: borrow :: Borrow < types :: deposits :: Param0 > , _1 : impl :: core :: borrow :: Borrow < types :: deposits :: Param1 > ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < (:: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: deposits :: Param0 > , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: deposits :: Param1 > ,) , types :: deposits :: Deposits , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SafeMode" , "Deposits" , (:: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0 . borrow ()) , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_1 . borrow ()) ,) , [176u8 , 188u8 , 87u8 , 205u8 , 141u8 , 232u8 , 186u8 , 203u8 , 180u8 , 156u8 , 184u8 , 200u8 , 6u8 , 114u8 , 214u8 , 126u8 , 136u8 , 106u8 , 101u8 , 42u8 , 25u8 , 127u8 , 61u8 , 171u8 , 50u8 , 143u8 , 221u8 , 176u8 , 245u8 , 232u8 , 30u8 , 3u8 ,]) } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi ; impl ConstantsApi { # [doc = " For how many blocks the safe-mode will be entered by [`Pallet::enter`]."] pub fn enter_duration (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u32 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("SafeMode" , "EnterDuration" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " For how many blocks the safe-mode can be extended by each [`Pallet::extend`] call."] # [doc = ""] # [doc = " This does not impose a hard limit as the safe-mode can be extended multiple times."] pub fn extend_duration (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u32 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("SafeMode" , "ExtendDuration" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " The amount that will be reserved upon calling [`Pallet::enter`]."] # [doc = ""] # [doc = " `None` disallows permissionlessly enabling the safe-mode and is a sane default."] pub fn enter_deposit_amount (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: option :: Option < :: core :: primitive :: u64 > > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("SafeMode" , "EnterDepositAmount" , [168u8 , 195u8 , 60u8 , 101u8 , 150u8 , 188u8 , 3u8 , 22u8 , 134u8 , 165u8 , 250u8 , 47u8 , 9u8 , 0u8 , 181u8 , 183u8 , 7u8 , 152u8 , 106u8 , 159u8 , 190u8 , 186u8 , 130u8 , 13u8 , 63u8 , 147u8 , 58u8 , 206u8 , 19u8 , 64u8 , 206u8 , 233u8 ,]) } # [doc = " The amount that will be reserved upon calling [`Pallet::extend`]."] # [doc = ""] # [doc = " `None` disallows permissionlessly extending the safe-mode and is a sane default."] pub fn extend_deposit_amount (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: option :: Option < :: core :: primitive :: u64 > > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("SafeMode" , "ExtendDepositAmount" , [168u8 , 195u8 , 60u8 , 101u8 , 150u8 , 188u8 , 3u8 , 22u8 , 134u8 , 165u8 , 250u8 , 47u8 , 9u8 , 0u8 , 181u8 , 183u8 , 7u8 , 152u8 , 106u8 , 159u8 , 190u8 , 186u8 , 130u8 , 13u8 , 63u8 , 147u8 , 58u8 , 206u8 , 19u8 , 64u8 , 206u8 , 233u8 ,]) } # [doc = " The minimal duration a deposit will remain reserved after safe-mode is entered or"] # [doc = " extended, unless [`Pallet::force_release_deposit`] is successfully called sooner."] # [doc = ""] # [doc = " Every deposit is tied to a specific activation or extension, thus each deposit can be"] # [doc = " released independently after the delay for it has passed."] # [doc = ""] # [doc = " `None` disallows permissionlessly releasing the safe-mode deposits and is a sane"] # [doc = " default."] pub fn release_delay (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: option :: Option < :: core :: primitive :: u32 > > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("SafeMode" , "ReleaseDelay" , [111u8 , 234u8 , 140u8 , 193u8 , 117u8 , 12u8 , 156u8 , 42u8 , 108u8 , 165u8 , 55u8 , 45u8 , 64u8 , 14u8 , 126u8 , 168u8 , 240u8 , 34u8 , 185u8 , 106u8 , 152u8 , 134u8 , 255u8 , 67u8 , 57u8 , 132u8 , 69u8 , 70u8 , 8u8 , 41u8 , 19u8 , 90u8 ,]) } } } } pub mod runtime_types { use super :: runtime_types ; pub mod bounded_collections { use super :: runtime_types ; pub mod bounded_vec { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct BoundedVec < _0 > (pub :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < _0 > ,) ; } pub mod weak_bounded_vec { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct WeakBoundedVec < _0 > (pub :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < _0 > ,) ; } } pub mod finality_grandpa { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct Equivocation < _0 , _1 , _2 > { pub round_number : :: core :: primitive :: u64 , pub identity : _0 , pub first : (_1 , _2 ,) , pub second : (_1 , _2 ,) , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct Precommit < _0 , _1 > { pub target_hash : _0 , pub target_number : _1 , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct Prevote < _0 , _1 > { pub target_hash : _0 , pub target_number : _1 , } } pub mod frame_metadata_hash_extension { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct CheckMetadataHash { pub mode : runtime_types :: frame_metadata_hash_extension :: Mode , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum Mode { # [codec (index = 0)] Disabled , # [codec (index = 1)] Enabled , } } pub mod frame_support { use super :: runtime_types ; pub mod dispatch { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum DispatchClass { # [codec (index = 0)] Normal , # [codec (index = 1)] Operational , # [codec (index = 2)] Mandatory , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct DispatchInfo { pub weight : runtime_types :: sp_weights :: weight_v2 :: Weight , pub class : runtime_types :: frame_support :: dispatch :: DispatchClass , pub pays_fee : runtime_types :: frame_support :: dispatch :: Pays , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum Pays { # [codec (index = 0)] Yes , # [codec (index = 1)] No , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct PerDispatchClass < _0 > { pub normal : _0 , pub operational : _0 , pub mandatory : _0 , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum RawOrigin < _0 > { # [codec (index = 0)] Root , # [codec (index = 1)] Signed (_0 ,) , # [codec (index = 2)] None , } } pub mod traits { use super :: runtime_types ; pub mod preimages { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum Bounded < _0 , _1 > { # [codec (index = 0)] Legacy { hash : :: subxt :: ext :: subxt_core :: utils :: H256 , } , # [codec (index = 1)] Inline (runtime_types :: bounded_collections :: bounded_vec :: BoundedVec < :: core :: primitive :: u8 > ,) , # [codec (index = 2)] Lookup { hash : :: subxt :: ext :: subxt_core :: utils :: H256 , len : :: core :: primitive :: u32 , } , __Ignore (:: core :: marker :: PhantomData < (_0 , _1) >) , } } pub mod tokens { use super :: runtime_types ; pub mod fungible { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: CompactAs , :: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct HoldConsideration (pub :: core :: primitive :: u64 ,) ; } pub mod misc { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum BalanceStatus { # [codec (index = 0)] Free , # [codec (index = 1)] Reserved , } } } } } pub mod frame_system { use super :: runtime_types ; pub mod extensions { use super :: runtime_types ; pub mod check_genesis { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct CheckGenesis ; } pub mod check_mortality { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct CheckMortality (pub runtime_types :: sp_runtime :: generic :: era :: Era ,) ; } pub mod check_non_zero_sender { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct CheckNonZeroSender ; } pub mod check_spec_version { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct CheckSpecVersion ; } pub mod check_tx_version { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct CheckTxVersion ; } pub mod check_weight { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct CheckWeight ; } } pub mod limits { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct BlockLength { pub max : runtime_types :: frame_support :: dispatch :: PerDispatchClass < :: core :: primitive :: u32 > , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct BlockWeights { pub base_block : runtime_types :: sp_weights :: weight_v2 :: Weight , pub max_block : runtime_types :: sp_weights :: weight_v2 :: Weight , pub per_class : runtime_types :: frame_support :: dispatch :: PerDispatchClass < runtime_types :: frame_system :: limits :: WeightsPerClass > , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct WeightsPerClass { pub base_extrinsic : runtime_types :: sp_weights :: weight_v2 :: Weight , pub max_extrinsic : :: core :: option :: Option < runtime_types :: sp_weights :: weight_v2 :: Weight > , pub max_total : :: core :: option :: Option < runtime_types :: sp_weights :: weight_v2 :: Weight > , pub reserved : :: core :: option :: Option < runtime_types :: sp_weights :: weight_v2 :: Weight > , } } pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Contains a variant per dispatchable extrinsic that this pallet has."] pub enum Call { # [codec (index = 0)] # [doc = "Make some on-chain remark."] # [doc = ""] # [doc = "Can be executed by every `origin`."] remark { remark : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 1)] # [doc = "Set the number of pages in the WebAssembly environment's heap."] set_heap_pages { pages : :: core :: primitive :: u64 , } , # [codec (index = 2)] # [doc = "Set the new runtime code."] set_code { code : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 3)] # [doc = "Set the new runtime code without doing any checks of the given `code`."] # [doc = ""] # [doc = "Note that runtime upgrades will not run if this is called with a not-increasing spec"] # [doc = "version!"] set_code_without_checks { code : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 4)] # [doc = "Set some items of storage."] set_storage { items : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < (:: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > , :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ,) > , } , # [codec (index = 5)] # [doc = "Kill some items from storage."] kill_storage { keys : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > > , } , # [codec (index = 6)] # [doc = "Kill all storage items with a key that starts with the given prefix."] # [doc = ""] # [doc = "**NOTE:** We rely on the Root origin to provide us the number of subkeys under"] # [doc = "the prefix we are removing to accurately calculate the weight of this function."] kill_prefix { prefix : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > , subkeys : :: core :: primitive :: u32 , } , # [codec (index = 7)] # [doc = "Make some on-chain remark and emit event."] remark_with_event { remark : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 9)] # [doc = "Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied"] # [doc = "later."] # [doc = ""] # [doc = "This call requires Root origin."] authorize_upgrade { code_hash : :: subxt :: ext :: subxt_core :: utils :: H256 , } , # [codec (index = 10)] # [doc = "Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied"] # [doc = "later."] # [doc = ""] # [doc = "WARNING: This authorizes an upgrade that will take place without any safety checks, for"] # [doc = "example that the spec name remains the same and that the version number increases. Not"] # [doc = "recommended for normal use. Use `authorize_upgrade` instead."] # [doc = ""] # [doc = "This call requires Root origin."] authorize_upgrade_without_checks { code_hash : :: subxt :: ext :: subxt_core :: utils :: H256 , } , # [codec (index = 11)] # [doc = "Provide the preimage (runtime binary) `code` for an upgrade that has been authorized."] # [doc = ""] # [doc = "If the authorization required a version check, this call will ensure the spec name"] # [doc = "remains unchanged and that the spec version has increased."] # [doc = ""] # [doc = "Depending on the runtime's `OnSetCode` configuration, this function may directly apply"] # [doc = "the new `code` in the same block or attempt to schedule the upgrade."] # [doc = ""] # [doc = "All origins are allowed."] apply_authorized_upgrade { code : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > , } , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Error for the System pallet"] pub enum Error { # [codec (index = 0)] # [doc = "The name of specification does not match between the current runtime"] # [doc = "and the new runtime."] InvalidSpecName , # [codec (index = 1)] # [doc = "The specification version is not allowed to decrease between the current runtime"] # [doc = "and the new runtime."] SpecVersionNeedsToIncrease , # [codec (index = 2)] # [doc = "Failed to extract the runtime version from the new runtime."] # [doc = ""] # [doc = "Either calling `Core_version` or decoding `RuntimeVersion` failed."] FailedToExtractRuntimeVersion , # [codec (index = 3)] # [doc = "Suicide called when the account has non-default composite data."] NonDefaultComposite , # [codec (index = 4)] # [doc = "There is a non-zero reference count preventing the account from being purged."] NonZeroRefCount , # [codec (index = 5)] # [doc = "The origin filter prevent the call to be dispatched."] CallFiltered , # [codec (index = 6)] # [doc = "A multi-block migration is ongoing and prevents the current code from being replaced."] MultiBlockMigrationsOngoing , # [codec (index = 7)] # [doc = "No upgrade authorized."] NothingAuthorized , # [codec (index = 8)] # [doc = "The submitted code is not authorized."] Unauthorized , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Event for the System pallet."] pub enum Event { # [codec (index = 0)] # [doc = "An extrinsic completed successfully."] ExtrinsicSuccess { dispatch_info : runtime_types :: frame_support :: dispatch :: DispatchInfo , } , # [codec (index = 1)] # [doc = "An extrinsic failed."] ExtrinsicFailed { dispatch_error : runtime_types :: sp_runtime :: DispatchError , dispatch_info : runtime_types :: frame_support :: dispatch :: DispatchInfo , } , # [codec (index = 2)] # [doc = "`:code` was updated."] CodeUpdated , # [codec (index = 3)] # [doc = "A new account was created."] NewAccount { account : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , } , # [codec (index = 4)] # [doc = "An account was reaped."] KilledAccount { account : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , } , # [codec (index = 5)] # [doc = "On on-chain remark happened."] Remarked { sender : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , hash : :: subxt :: ext :: subxt_core :: utils :: H256 , } , # [codec (index = 6)] # [doc = "An upgrade was authorized."] UpgradeAuthorized { code_hash : :: subxt :: ext :: subxt_core :: utils :: H256 , check_version : :: core :: primitive :: bool , } , } } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct AccountInfo < _0 , _1 > { pub nonce : _0 , pub consumers : :: core :: primitive :: u32 , pub providers : :: core :: primitive :: u32 , pub sufficients : :: core :: primitive :: u32 , pub data : _1 , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct CodeUpgradeAuthorization { pub code_hash : :: subxt :: ext :: subxt_core :: utils :: H256 , pub check_version : :: core :: primitive :: bool , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct EventRecord < _0 , _1 > { pub phase : runtime_types :: frame_system :: Phase , pub event : _0 , pub topics : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < _1 > , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct LastRuntimeUpgradeInfo { # [codec (compact)] pub spec_version : :: core :: primitive :: u32 , pub spec_name : :: subxt :: ext :: subxt_core :: alloc :: string :: String , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum Phase { # [codec (index = 0)] ApplyExtrinsic (:: core :: primitive :: u32 ,) , # [codec (index = 1)] Finalization , # [codec (index = 2)] Initialization , } } pub mod node_subtensor_runtime { use super :: runtime_types ; pub mod check_nonce { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct CheckNonce (# [codec (compact)] pub :: core :: primitive :: u32 ,) ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum OriginCaller { # [codec (index = 0)] system (runtime_types :: frame_support :: dispatch :: RawOrigin < :: subxt :: ext :: subxt_core :: utils :: AccountId32 > ,) , # [codec (index = 8)] Triumvirate (runtime_types :: pallet_collective :: RawOrigin < :: subxt :: ext :: subxt_core :: utils :: AccountId32 > ,) , # [codec (index = 2)] Void (runtime_types :: sp_core :: Void ,) , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum ProxyType { # [codec (index = 0)] Any , # [codec (index = 1)] Owner , # [codec (index = 2)] NonCritical , # [codec (index = 3)] NonTransfer , # [codec (index = 4)] Senate , # [codec (index = 5)] NonFungibile , # [codec (index = 6)] Triumvirate , # [codec (index = 7)] Governance , # [codec (index = 8)] Staking , # [codec (index = 9)] Registration , # [codec (index = 10)] Transfer , # [codec (index = 11)] SmallTransfer , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct Runtime ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum RuntimeCall { # [codec (index = 0)] System (runtime_types :: frame_system :: pallet :: Call ,) , # [codec (index = 2)] Timestamp (runtime_types :: pallet_timestamp :: pallet :: Call ,) , # [codec (index = 4)] Grandpa (runtime_types :: pallet_grandpa :: pallet :: Call ,) , # [codec (index = 5)] Balances (runtime_types :: pallet_balances :: pallet :: Call ,) , # [codec (index = 7)] SubtensorModule (runtime_types :: pallet_subtensor :: pallet :: Call ,) , # [codec (index = 8)] Triumvirate (runtime_types :: pallet_collective :: pallet :: Call ,) , # [codec (index = 9)] TriumvirateMembers (runtime_types :: pallet_membership :: pallet :: Call ,) , # [codec (index = 10)] SenateMembers (runtime_types :: pallet_membership :: pallet :: Call ,) , # [codec (index = 11)] Utility (runtime_types :: pallet_utility :: pallet :: Call ,) , # [codec (index = 12)] Sudo (runtime_types :: pallet_sudo :: pallet :: Call ,) , # [codec (index = 13)] Multisig (runtime_types :: pallet_multisig :: pallet :: Call ,) , # [codec (index = 14)] Preimage (runtime_types :: pallet_preimage :: pallet :: Call ,) , # [codec (index = 15)] Scheduler (runtime_types :: pallet_scheduler :: pallet :: Call ,) , # [codec (index = 16)] Proxy (runtime_types :: pallet_proxy :: pallet :: Call ,) , # [codec (index = 17)] Registry (runtime_types :: pallet_registry :: pallet :: Call ,) , # [codec (index = 18)] Commitments (runtime_types :: pallet_commitments :: pallet :: Call ,) , # [codec (index = 19)] AdminUtils (runtime_types :: pallet_admin_utils :: pallet :: Call ,) , # [codec (index = 20)] SafeMode (runtime_types :: pallet_safe_mode :: pallet :: Call ,) , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum RuntimeError { # [codec (index = 0)] System (runtime_types :: frame_system :: pallet :: Error ,) , # [codec (index = 4)] Grandpa (runtime_types :: pallet_grandpa :: pallet :: Error ,) , # [codec (index = 5)] Balances (runtime_types :: pallet_balances :: pallet :: Error ,) , # [codec (index = 7)] SubtensorModule (runtime_types :: pallet_subtensor :: pallet :: Error ,) , # [codec (index = 8)] Triumvirate (runtime_types :: pallet_collective :: pallet :: Error ,) , # [codec (index = 9)] TriumvirateMembers (runtime_types :: pallet_membership :: pallet :: Error ,) , # [codec (index = 10)] SenateMembers (runtime_types :: pallet_membership :: pallet :: Error ,) , # [codec (index = 11)] Utility (runtime_types :: pallet_utility :: pallet :: Error ,) , # [codec (index = 12)] Sudo (runtime_types :: pallet_sudo :: pallet :: Error ,) , # [codec (index = 13)] Multisig (runtime_types :: pallet_multisig :: pallet :: Error ,) , # [codec (index = 14)] Preimage (runtime_types :: pallet_preimage :: pallet :: Error ,) , # [codec (index = 15)] Scheduler (runtime_types :: pallet_scheduler :: pallet :: Error ,) , # [codec (index = 16)] Proxy (runtime_types :: pallet_proxy :: pallet :: Error ,) , # [codec (index = 17)] Registry (runtime_types :: pallet_registry :: pallet :: Error ,) , # [codec (index = 18)] Commitments (runtime_types :: pallet_commitments :: pallet :: Error ,) , # [codec (index = 19)] AdminUtils (runtime_types :: pallet_admin_utils :: pallet :: Error ,) , # [codec (index = 20)] SafeMode (runtime_types :: pallet_safe_mode :: pallet :: Error ,) , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum RuntimeEvent { # [codec (index = 0)] System (runtime_types :: frame_system :: pallet :: Event ,) , # [codec (index = 4)] Grandpa (runtime_types :: pallet_grandpa :: pallet :: Event ,) , # [codec (index = 5)] Balances (runtime_types :: pallet_balances :: pallet :: Event ,) , # [codec (index = 6)] TransactionPayment (runtime_types :: pallet_transaction_payment :: pallet :: Event ,) , # [codec (index = 7)] SubtensorModule (runtime_types :: pallet_subtensor :: pallet :: Event ,) , # [codec (index = 8)] Triumvirate (runtime_types :: pallet_collective :: pallet :: Event ,) , # [codec (index = 9)] TriumvirateMembers (runtime_types :: pallet_membership :: pallet :: Event ,) , # [codec (index = 10)] SenateMembers (runtime_types :: pallet_membership :: pallet :: Event ,) , # [codec (index = 11)] Utility (runtime_types :: pallet_utility :: pallet :: Event ,) , # [codec (index = 12)] Sudo (runtime_types :: pallet_sudo :: pallet :: Event ,) , # [codec (index = 13)] Multisig (runtime_types :: pallet_multisig :: pallet :: Event ,) , # [codec (index = 14)] Preimage (runtime_types :: pallet_preimage :: pallet :: Event ,) , # [codec (index = 15)] Scheduler (runtime_types :: pallet_scheduler :: pallet :: Event ,) , # [codec (index = 16)] Proxy (runtime_types :: pallet_proxy :: pallet :: Event ,) , # [codec (index = 17)] Registry (runtime_types :: pallet_registry :: pallet :: Event ,) , # [codec (index = 18)] Commitments (runtime_types :: pallet_commitments :: pallet :: Event ,) , # [codec (index = 19)] AdminUtils (runtime_types :: pallet_admin_utils :: pallet :: Event ,) , # [codec (index = 20)] SafeMode (runtime_types :: pallet_safe_mode :: pallet :: Event ,) , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum RuntimeFreezeReason { } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum RuntimeHoldReason { # [codec (index = 14)] Preimage (runtime_types :: pallet_preimage :: pallet :: HoldReason ,) , # [codec (index = 17)] Registry (runtime_types :: pallet_registry :: pallet :: HoldReason ,) , # [codec (index = 20)] SafeMode (runtime_types :: pallet_safe_mode :: pallet :: HoldReason ,) , } } pub mod pallet_admin_utils { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Dispatchable functions allows users to interact with the pallet and invoke state changes."] pub enum Call { # [codec (index = 0)] # [doc = "The extrinsic sets the new authorities for Aura consensus."] # [doc = "It is only callable by the root account."] # [doc = "The extrinsic will call the Aura pallet to change the authorities."] swap_authorities { new_authorities : runtime_types :: bounded_collections :: bounded_vec :: BoundedVec < runtime_types :: sp_consensus_aura :: sr25519 :: app_sr25519 :: Public > , } , # [codec (index = 1)] # [doc = "The extrinsic sets the default take for the network."] # [doc = "It is only callable by the root account."] # [doc = "The extrinsic will call the Subtensor pallet to set the default take."] sudo_set_default_take { default_take : :: core :: primitive :: u16 , } , # [codec (index = 2)] # [doc = "The extrinsic sets the transaction rate limit for the network."] # [doc = "It is only callable by the root account."] # [doc = "The extrinsic will call the Subtensor pallet to set the transaction rate limit."] sudo_set_tx_rate_limit { tx_rate_limit : :: core :: primitive :: u64 , } , # [codec (index = 3)] # [doc = "The extrinsic sets the serving rate limit for a subnet."] # [doc = "It is only callable by the root account or subnet owner."] # [doc = "The extrinsic will call the Subtensor pallet to set the serving rate limit."] sudo_set_serving_rate_limit { netuid : :: core :: primitive :: u16 , serving_rate_limit : :: core :: primitive :: u64 , } , # [codec (index = 4)] # [doc = "The extrinsic sets the minimum difficulty for a subnet."] # [doc = "It is only callable by the root account or subnet owner."] # [doc = "The extrinsic will call the Subtensor pallet to set the minimum difficulty."] sudo_set_min_difficulty { netuid : :: core :: primitive :: u16 , min_difficulty : :: core :: primitive :: u64 , } , # [codec (index = 5)] # [doc = "The extrinsic sets the maximum difficulty for a subnet."] # [doc = "It is only callable by the root account or subnet owner."] # [doc = "The extrinsic will call the Subtensor pallet to set the maximum difficulty."] sudo_set_max_difficulty { netuid : :: core :: primitive :: u16 , max_difficulty : :: core :: primitive :: u64 , } , # [codec (index = 6)] # [doc = "The extrinsic sets the weights version key for a subnet."] # [doc = "It is only callable by the root account or subnet owner."] # [doc = "The extrinsic will call the Subtensor pallet to set the weights version key."] sudo_set_weights_version_key { netuid : :: core :: primitive :: u16 , weights_version_key : :: core :: primitive :: u64 , } , # [codec (index = 7)] # [doc = "The extrinsic sets the weights set rate limit for a subnet."] # [doc = "It is only callable by the root account or subnet owner."] # [doc = "The extrinsic will call the Subtensor pallet to set the weights set rate limit."] sudo_set_weights_set_rate_limit { netuid : :: core :: primitive :: u16 , weights_set_rate_limit : :: core :: primitive :: u64 , } , # [codec (index = 8)] # [doc = "The extrinsic sets the adjustment interval for a subnet."] # [doc = "It is only callable by the root account, not changeable by the subnet owner."] # [doc = "The extrinsic will call the Subtensor pallet to set the adjustment interval."] sudo_set_adjustment_interval { netuid : :: core :: primitive :: u16 , adjustment_interval : :: core :: primitive :: u16 , } , # [codec (index = 9)] # [doc = "The extrinsic sets the adjustment alpha for a subnet."] # [doc = "It is only callable by the root account or subnet owner."] # [doc = "The extrinsic will call the Subtensor pallet to set the adjustment alpha."] sudo_set_adjustment_alpha { netuid : :: core :: primitive :: u16 , adjustment_alpha : :: core :: primitive :: u64 , } , # [codec (index = 12)] # [doc = "The extrinsic sets the adjustment beta for a subnet."] # [doc = "It is only callable by the root account or subnet owner."] # [doc = "The extrinsic will call the Subtensor pallet to set the adjustment beta."] sudo_set_max_weight_limit { netuid : :: core :: primitive :: u16 , max_weight_limit : :: core :: primitive :: u16 , } , # [codec (index = 13)] # [doc = "The extrinsic sets the immunity period for a subnet."] # [doc = "It is only callable by the root account or subnet owner."] # [doc = "The extrinsic will call the Subtensor pallet to set the immunity period."] sudo_set_immunity_period { netuid : :: core :: primitive :: u16 , immunity_period : :: core :: primitive :: u16 , } , # [codec (index = 14)] # [doc = "The extrinsic sets the minimum allowed weights for a subnet."] # [doc = "It is only callable by the root account or subnet owner."] # [doc = "The extrinsic will call the Subtensor pallet to set the minimum allowed weights."] sudo_set_min_allowed_weights { netuid : :: core :: primitive :: u16 , min_allowed_weights : :: core :: primitive :: u16 , } , # [codec (index = 15)] # [doc = "The extrinsic sets the maximum allowed UIDs for a subnet."] # [doc = "It is only callable by the root account."] # [doc = "The extrinsic will call the Subtensor pallet to set the maximum allowed UIDs for a subnet."] sudo_set_max_allowed_uids { netuid : :: core :: primitive :: u16 , max_allowed_uids : :: core :: primitive :: u16 , } , # [codec (index = 16)] # [doc = "The extrinsic sets the kappa for a subnet."] # [doc = "It is only callable by the root account or subnet owner."] # [doc = "The extrinsic will call the Subtensor pallet to set the kappa."] sudo_set_kappa { netuid : :: core :: primitive :: u16 , kappa : :: core :: primitive :: u16 , } , # [codec (index = 17)] # [doc = "The extrinsic sets the rho for a subnet."] # [doc = "It is only callable by the root account or subnet owner."] # [doc = "The extrinsic will call the Subtensor pallet to set the rho."] sudo_set_rho { netuid : :: core :: primitive :: u16 , rho : :: core :: primitive :: u16 , } , # [codec (index = 18)] # [doc = "The extrinsic sets the activity cutoff for a subnet."] # [doc = "It is only callable by the root account or subnet owner."] # [doc = "The extrinsic will call the Subtensor pallet to set the activity cutoff."] sudo_set_activity_cutoff { netuid : :: core :: primitive :: u16 , activity_cutoff : :: core :: primitive :: u16 , } , # [codec (index = 19)] # [doc = "The extrinsic sets the network registration allowed for a subnet."] # [doc = "It is only callable by the root account or subnet owner."] # [doc = "The extrinsic will call the Subtensor pallet to set the network registration allowed."] sudo_set_network_registration_allowed { netuid : :: core :: primitive :: u16 , registration_allowed : :: core :: primitive :: bool , } , # [codec (index = 20)] # [doc = "The extrinsic sets the network PoW registration allowed for a subnet."] # [doc = "It is only callable by the root account or subnet owner."] # [doc = "The extrinsic will call the Subtensor pallet to set the network PoW registration allowed."] sudo_set_network_pow_registration_allowed { netuid : :: core :: primitive :: u16 , registration_allowed : :: core :: primitive :: bool , } , # [codec (index = 21)] # [doc = "The extrinsic sets the target registrations per interval for a subnet."] # [doc = "It is only callable by the root account."] # [doc = "The extrinsic will call the Subtensor pallet to set the target registrations per interval."] sudo_set_target_registrations_per_interval { netuid : :: core :: primitive :: u16 , target_registrations_per_interval : :: core :: primitive :: u16 , } , # [codec (index = 22)] # [doc = "The extrinsic sets the minimum burn for a subnet."] # [doc = "It is only callable by the root account or subnet owner."] # [doc = "The extrinsic will call the Subtensor pallet to set the minimum burn."] sudo_set_min_burn { netuid : :: core :: primitive :: u16 , min_burn : :: core :: primitive :: u64 , } , # [codec (index = 23)] # [doc = "The extrinsic sets the maximum burn for a subnet."] # [doc = "It is only callable by the root account or subnet owner."] # [doc = "The extrinsic will call the Subtensor pallet to set the maximum burn."] sudo_set_max_burn { netuid : :: core :: primitive :: u16 , max_burn : :: core :: primitive :: u64 , } , # [codec (index = 24)] # [doc = "The extrinsic sets the difficulty for a subnet."] # [doc = "It is only callable by the root account or subnet owner."] # [doc = "The extrinsic will call the Subtensor pallet to set the difficulty."] sudo_set_difficulty { netuid : :: core :: primitive :: u16 , difficulty : :: core :: primitive :: u64 , } , # [codec (index = 25)] # [doc = "The extrinsic sets the maximum allowed validators for a subnet."] # [doc = "It is only callable by the root account."] # [doc = "The extrinsic will call the Subtensor pallet to set the maximum allowed validators."] sudo_set_max_allowed_validators { netuid : :: core :: primitive :: u16 , max_allowed_validators : :: core :: primitive :: u16 , } , # [codec (index = 26)] # [doc = "The extrinsic sets the bonds moving average for a subnet."] # [doc = "It is only callable by the root account or subnet owner."] # [doc = "The extrinsic will call the Subtensor pallet to set the bonds moving average."] sudo_set_bonds_moving_average { netuid : :: core :: primitive :: u16 , bonds_moving_average : :: core :: primitive :: u64 , } , # [codec (index = 27)] # [doc = "The extrinsic sets the maximum registrations per block for a subnet."] # [doc = "It is only callable by the root account."] # [doc = "The extrinsic will call the Subtensor pallet to set the maximum registrations per block."] sudo_set_max_registrations_per_block { netuid : :: core :: primitive :: u16 , max_registrations_per_block : :: core :: primitive :: u16 , } , # [codec (index = 28)] # [doc = "The extrinsic sets the subnet owner cut for a subnet."] # [doc = "It is only callable by the root account."] # [doc = "The extrinsic will call the Subtensor pallet to set the subnet owner cut."] sudo_set_subnet_owner_cut { subnet_owner_cut : :: core :: primitive :: u16 , } , # [codec (index = 29)] # [doc = "The extrinsic sets the network rate limit for the network."] # [doc = "It is only callable by the root account."] # [doc = "The extrinsic will call the Subtensor pallet to set the network rate limit."] sudo_set_network_rate_limit { rate_limit : :: core :: primitive :: u64 , } , # [codec (index = 30)] # [doc = "The extrinsic sets the tempo for a subnet."] # [doc = "It is only callable by the root account."] # [doc = "The extrinsic will call the Subtensor pallet to set the tempo."] sudo_set_tempo { netuid : :: core :: primitive :: u16 , tempo : :: core :: primitive :: u16 , } , # [codec (index = 33)] # [doc = "The extrinsic sets the total issuance for the network."] # [doc = "It is only callable by the root account."] # [doc = "The extrinsic will call the Subtensor pallet to set the issuance for the network."] sudo_set_total_issuance { total_issuance : :: core :: primitive :: u64 , } , # [codec (index = 35)] # [doc = "The extrinsic sets the immunity period for the network."] # [doc = "It is only callable by the root account."] # [doc = "The extrinsic will call the Subtensor pallet to set the immunity period for the network."] sudo_set_network_immunity_period { immunity_period : :: core :: primitive :: u64 , } , # [codec (index = 36)] # [doc = "The extrinsic sets the min lock cost for the network."] # [doc = "It is only callable by the root account."] # [doc = "The extrinsic will call the Subtensor pallet to set the min lock cost for the network."] sudo_set_network_min_lock_cost { lock_cost : :: core :: primitive :: u64 , } , # [codec (index = 37)] # [doc = "The extrinsic sets the subnet limit for the network."] # [doc = "It is only callable by the root account."] # [doc = "The extrinsic will call the Subtensor pallet to set the subnet limit."] sudo_set_subnet_limit { max_subnets : :: core :: primitive :: u16 , } , # [codec (index = 38)] # [doc = "The extrinsic sets the lock reduction interval for the network."] # [doc = "It is only callable by the root account."] # [doc = "The extrinsic will call the Subtensor pallet to set the lock reduction interval."] sudo_set_lock_reduction_interval { interval : :: core :: primitive :: u64 , } , # [codec (index = 39)] # [doc = "The extrinsic sets the recycled RAO for a subnet."] # [doc = "It is only callable by the root account."] # [doc = "The extrinsic will call the Subtensor pallet to set the recycled RAO."] sudo_set_rao_recycled { netuid : :: core :: primitive :: u16 , rao_recycled : :: core :: primitive :: u64 , } , # [codec (index = 42)] # [doc = "The extrinsic sets the weights min stake."] # [doc = "It is only callable by the root account."] # [doc = "The extrinsic will call the Subtensor pallet to set the weights min stake."] sudo_set_weights_min_stake { min_stake : :: core :: primitive :: u64 , } , # [codec (index = 43)] # [doc = "The extrinsic sets the minimum stake required for nominators."] # [doc = "It is only callable by the root account."] # [doc = "The extrinsic will call the Subtensor pallet to set the minimum stake required for nominators."] sudo_set_nominator_min_required_stake { min_stake : :: core :: primitive :: u64 , } , # [codec (index = 45)] # [doc = "The extrinsic sets the rate limit for delegate take transactions."] # [doc = "It is only callable by the root account."] # [doc = "The extrinsic will call the Subtensor pallet to set the rate limit for delegate take transactions."] sudo_set_tx_delegate_take_rate_limit { tx_rate_limit : :: core :: primitive :: u64 , } , # [codec (index = 46)] # [doc = "The extrinsic sets the minimum delegate take."] # [doc = "It is only callable by the root account."] # [doc = "The extrinsic will call the Subtensor pallet to set the minimum delegate take."] sudo_set_min_delegate_take { take : :: core :: primitive :: u16 , } , # [codec (index = 47)] # [doc = "The extrinsic sets the target stake per interval."] # [doc = "It is only callable by the root account."] # [doc = "The extrinsic will call the Subtensor pallet to set target stake per interval."] sudo_set_target_stakes_per_interval { target_stakes_per_interval : :: core :: primitive :: u64 , } , # [codec (index = 48)] # [doc = "The extrinsic sets the commit/reveal interval for a subnet."] # [doc = "It is only callable by the root account or subnet owner."] # [doc = "The extrinsic will call the Subtensor pallet to set the interval."] sudo_set_commit_reveal_weights_interval { netuid : :: core :: primitive :: u16 , interval : :: core :: primitive :: u64 , } , # [codec (index = 49)] # [doc = "The extrinsic enabled/disables commit/reaveal for a given subnet."] # [doc = "It is only callable by the root account or subnet owner."] # [doc = "The extrinsic will call the Subtensor pallet to set the value."] sudo_set_commit_reveal_weights_enabled { netuid : :: core :: primitive :: u16 , enabled : :: core :: primitive :: bool , } , # [codec (index = 50)] # [doc = "Enables or disables Liquid Alpha for a given subnet."] # [doc = ""] # [doc = "# Parameters"] # [doc = "- `origin`: The origin of the call, which must be the root account or subnet owner."] # [doc = "- `netuid`: The unique identifier for the subnet."] # [doc = "- `enabled`: A boolean flag to enable or disable Liquid Alpha."] # [doc = ""] # [doc = "# Weight"] # [doc = "This function has a fixed weight of 0 and is classified as an operational transaction that does not incur any fees."] sudo_set_liquid_alpha_enabled { netuid : :: core :: primitive :: u16 , enabled : :: core :: primitive :: bool , } , # [codec (index = 51)] # [doc = "Sets values for liquid alpha"] sudo_set_alpha_values { netuid : :: core :: primitive :: u16 , alpha_low : :: core :: primitive :: u16 , alpha_high : :: core :: primitive :: u16 , } , # [codec (index = 52)] # [doc = "Sets the hotkey emission tempo."] # [doc = ""] # [doc = "This extrinsic allows the root account to set the hotkey emission tempo, which determines"] # [doc = "the number of blocks before a hotkey drains accumulated emissions through to nominator staking accounts."] # [doc = ""] # [doc = "# Arguments"] # [doc = "* `origin` - The origin of the call, which must be the root account."] # [doc = "* `emission_tempo` - The new emission tempo value to set."] # [doc = ""] # [doc = "# Emits"] # [doc = "* `Event::HotkeyEmissionTempoSet` - When the hotkey emission tempo is successfully set."] # [doc = ""] # [doc = "# Errors"] # [doc = "* `DispatchError::BadOrigin` - If the origin is not the root account."] sudo_set_hotkey_emission_tempo { emission_tempo : :: core :: primitive :: u64 , } , # [codec (index = 53)] # [doc = "Sets the maximum stake allowed for a specific network."] # [doc = ""] # [doc = "This function allows the root account to set the maximum stake for a given network."] # [doc = "It updates the network's maximum stake value and logs the change."] # [doc = ""] # [doc = "# Arguments"] # [doc = ""] # [doc = "* `origin` - The origin of the call, which must be the root account."] # [doc = "* `netuid` - The unique identifier of the network."] # [doc = "* `max_stake` - The new maximum stake value to set."] # [doc = ""] # [doc = "# Returns"] # [doc = ""] # [doc = "Returns `Ok(())` if the operation is successful, or an error if it fails."] # [doc = ""] # [doc = "# Example"] # [doc = ""] # [doc = ""] # [doc = "# Notes"] # [doc = ""] # [doc = "- This function can only be called by the root account."] # [doc = "- The `netuid` should correspond to an existing network."] # [doc = ""] # [doc = "# TODO"] # [doc = ""] sudo_set_network_max_stake { netuid : :: core :: primitive :: u16 , max_stake : :: core :: primitive :: u64 , } , # [codec (index = 54)] # [doc = "Sets the duration of the coldkey swap schedule."] # [doc = ""] # [doc = "This extrinsic allows the root account to set the duration for the coldkey swap schedule."] # [doc = "The coldkey swap schedule determines how long it takes for a coldkey swap operation to complete."] # [doc = ""] # [doc = "# Arguments"] # [doc = "* `origin` - The origin of the call, which must be the root account."] # [doc = "* `duration` - The new duration for the coldkey swap schedule, in number of blocks."] # [doc = ""] # [doc = "# Errors"] # [doc = "* `BadOrigin` - If the caller is not the root account."] # [doc = ""] # [doc = "# Weight"] # [doc = "Weight is handled by the `#[pallet::weight]` attribute."] sudo_set_coldkey_swap_schedule_duration { duration : :: core :: primitive :: u32 , } , # [codec (index = 55)] # [doc = "Sets the duration of the dissolve network schedule."] # [doc = ""] # [doc = "This extrinsic allows the root account to set the duration for the dissolve network schedule."] # [doc = "The dissolve network schedule determines how long it takes for a network dissolution operation to complete."] # [doc = ""] # [doc = "# Arguments"] # [doc = "* `origin` - The origin of the call, which must be the root account."] # [doc = "* `duration` - The new duration for the dissolve network schedule, in number of blocks."] # [doc = ""] # [doc = "# Errors"] # [doc = "* `BadOrigin` - If the caller is not the root account."] # [doc = ""] # [doc = "# Weight"] # [doc = "Weight is handled by the `#[pallet::weight]` attribute."] sudo_set_dissolve_network_schedule_duration { duration : :: core :: primitive :: u32 , } , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The `Error` enum of this pallet."] pub enum Error { # [codec (index = 0)] # [doc = "The subnet does not exist, check the netuid parameter"] SubnetDoesNotExist , # [codec (index = 1)] # [doc = "The maximum number of subnet validators must be less than the maximum number of allowed UIDs in the subnet."] MaxValidatorsLargerThanMaxUIds , # [codec (index = 2)] # [doc = "The maximum number of subnet validators must be more than the current number of UIDs already in the subnet."] MaxAllowedUIdsLessThanCurrentUIds , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The `Event` enum of this pallet"] pub enum Event { } } } pub mod pallet_balances { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Contains a variant per dispatchable extrinsic that this pallet has."] pub enum Call { # [codec (index = 0)] # [doc = "Transfer some liquid free balance to another account."] # [doc = ""] # [doc = "`transfer_allow_death` will set the `FreeBalance` of the sender and receiver."] # [doc = "If the sender's account is below the existential deposit as a result"] # [doc = "of the transfer, the account will be reaped."] # [doc = ""] # [doc = "The dispatch origin for this call must be `Signed` by the transactor."] transfer_allow_death { dest : :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > , # [codec (compact)] value : :: core :: primitive :: u64 , } , # [codec (index = 2)] # [doc = "Exactly as `transfer_allow_death`, except the origin must be root and the source account"] # [doc = "may be specified."] force_transfer { source : :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > , dest : :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > , # [codec (compact)] value : :: core :: primitive :: u64 , } , # [codec (index = 3)] # [doc = "Same as the [`transfer_allow_death`] call, but with a check that the transfer will not"] # [doc = "kill the origin account."] # [doc = ""] # [doc = "99% of the time you want [`transfer_allow_death`] instead."] # [doc = ""] # [doc = "[`transfer_allow_death`]: struct.Pallet.html#method.transfer"] transfer_keep_alive { dest : :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > , # [codec (compact)] value : :: core :: primitive :: u64 , } , # [codec (index = 4)] # [doc = "Transfer the entire transferable balance from the caller account."] # [doc = ""] # [doc = "NOTE: This function only attempts to transfer _transferable_ balances. This means that"] # [doc = "any locked, reserved, or existential deposits (when `keep_alive` is `true`), will not be"] # [doc = "transferred by this function. To ensure that this function results in a killed account,"] # [doc = "you might need to prepare the account by removing any reference counters, storage"] # [doc = "deposits, etc..."] # [doc = ""] # [doc = "The dispatch origin of this call must be Signed."] # [doc = ""] # [doc = "- `dest`: The recipient of the transfer."] # [doc = "- `keep_alive`: A boolean to determine if the `transfer_all` operation should send all"] # [doc = "  of the funds the account has, causing the sender account to be killed (false), or"] # [doc = "  transfer everything except at least the existential deposit, which will guarantee to"] # [doc = "  keep the sender account alive (true)."] transfer_all { dest : :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > , keep_alive : :: core :: primitive :: bool , } , # [codec (index = 5)] # [doc = "Unreserve some balance from a user by force."] # [doc = ""] # [doc = "Can only be called by ROOT."] force_unreserve { who : :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > , amount : :: core :: primitive :: u64 , } , # [codec (index = 6)] # [doc = "Upgrade a specified account."] # [doc = ""] # [doc = "- `origin`: Must be `Signed`."] # [doc = "- `who`: The account to be upgraded."] # [doc = ""] # [doc = "This will waive the transaction fee if at least all but 10% of the accounts needed to"] # [doc = "be upgraded. (We let some not have to be upgraded just in order to allow for the"] # [doc = "possibility of churn)."] upgrade_accounts { who : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: subxt :: ext :: subxt_core :: utils :: AccountId32 > , } , # [codec (index = 8)] # [doc = "Set the regular balance of a given account."] # [doc = ""] # [doc = "The dispatch origin for this call is `root`."] force_set_balance { who : :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > , # [codec (compact)] new_free : :: core :: primitive :: u64 , } , # [codec (index = 9)] # [doc = "Adjust the total issuance in a saturating way."] # [doc = ""] # [doc = "Can only be called by root and always needs a positive `delta`."] # [doc = ""] # [doc = "# Example"] force_adjust_total_issuance { direction : runtime_types :: pallet_balances :: types :: AdjustmentDirection , # [codec (compact)] delta : :: core :: primitive :: u64 , } , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The `Error` enum of this pallet."] pub enum Error { # [codec (index = 0)] # [doc = "Vesting balance too high to send value."] VestingBalance , # [codec (index = 1)] # [doc = "Account liquidity restrictions prevent withdrawal."] LiquidityRestrictions , # [codec (index = 2)] # [doc = "Balance too low to send value."] InsufficientBalance , # [codec (index = 3)] # [doc = "Value too low to create account due to existential deposit."] ExistentialDeposit , # [codec (index = 4)] # [doc = "Transfer/payment would kill account."] Expendability , # [codec (index = 5)] # [doc = "A vesting schedule already exists for this account."] ExistingVestingSchedule , # [codec (index = 6)] # [doc = "Beneficiary account must pre-exist."] DeadAccount , # [codec (index = 7)] # [doc = "Number of named reserves exceed `MaxReserves`."] TooManyReserves , # [codec (index = 8)] # [doc = "Number of holds exceed `VariantCountOf<T::RuntimeHoldReason>`."] TooManyHolds , # [codec (index = 9)] # [doc = "Number of freezes exceed `MaxFreezes`."] TooManyFreezes , # [codec (index = 10)] # [doc = "The issuance cannot be modified since it is already deactivated."] IssuanceDeactivated , # [codec (index = 11)] # [doc = "The delta cannot be zero."] DeltaZero , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The `Event` enum of this pallet"] pub enum Event { # [codec (index = 0)] # [doc = "An account was created with some free balance."] Endowed { account : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , free_balance : :: core :: primitive :: u64 , } , # [codec (index = 1)] # [doc = "An account was removed whose balance was non-zero but below ExistentialDeposit,"] # [doc = "resulting in an outright loss."] DustLost { account : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , amount : :: core :: primitive :: u64 , } , # [codec (index = 2)] # [doc = "Transfer succeeded."] Transfer { from : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , to : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , amount : :: core :: primitive :: u64 , } , # [codec (index = 3)] # [doc = "A balance was set by root."] BalanceSet { who : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , free : :: core :: primitive :: u64 , } , # [codec (index = 4)] # [doc = "Some balance was reserved (moved from free to reserved)."] Reserved { who : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , amount : :: core :: primitive :: u64 , } , # [codec (index = 5)] # [doc = "Some balance was unreserved (moved from reserved to free)."] Unreserved { who : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , amount : :: core :: primitive :: u64 , } , # [codec (index = 6)] # [doc = "Some balance was moved from the reserve of the first account to the second account."] # [doc = "Final argument indicates the destination balance type."] ReserveRepatriated { from : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , to : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , amount : :: core :: primitive :: u64 , destination_status : runtime_types :: frame_support :: traits :: tokens :: misc :: BalanceStatus , } , # [codec (index = 7)] # [doc = "Some amount was deposited (e.g. for transaction fees)."] Deposit { who : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , amount : :: core :: primitive :: u64 , } , # [codec (index = 8)] # [doc = "Some amount was withdrawn from the account (e.g. for transaction fees)."] Withdraw { who : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , amount : :: core :: primitive :: u64 , } , # [codec (index = 9)] # [doc = "Some amount was removed from the account (e.g. for misbehavior)."] Slashed { who : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , amount : :: core :: primitive :: u64 , } , # [codec (index = 10)] # [doc = "Some amount was minted into an account."] Minted { who : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , amount : :: core :: primitive :: u64 , } , # [codec (index = 11)] # [doc = "Some amount was burned from an account."] Burned { who : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , amount : :: core :: primitive :: u64 , } , # [codec (index = 12)] # [doc = "Some amount was suspended from an account (it can be restored later)."] Suspended { who : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , amount : :: core :: primitive :: u64 , } , # [codec (index = 13)] # [doc = "Some amount was restored into an account."] Restored { who : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , amount : :: core :: primitive :: u64 , } , # [codec (index = 14)] # [doc = "An account was upgraded."] Upgraded { who : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , } , # [codec (index = 15)] # [doc = "Total issuance was increased by `amount`, creating a credit to be balanced."] Issued { amount : :: core :: primitive :: u64 , } , # [codec (index = 16)] # [doc = "Total issuance was decreased by `amount`, creating a debt to be balanced."] Rescinded { amount : :: core :: primitive :: u64 , } , # [codec (index = 17)] # [doc = "Some balance was locked."] Locked { who : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , amount : :: core :: primitive :: u64 , } , # [codec (index = 18)] # [doc = "Some balance was unlocked."] Unlocked { who : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , amount : :: core :: primitive :: u64 , } , # [codec (index = 19)] # [doc = "Some balance was frozen."] Frozen { who : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , amount : :: core :: primitive :: u64 , } , # [codec (index = 20)] # [doc = "Some balance was thawed."] Thawed { who : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , amount : :: core :: primitive :: u64 , } , # [codec (index = 21)] # [doc = "The `TotalIssuance` was forcefully changed."] TotalIssuanceForced { old : :: core :: primitive :: u64 , new : :: core :: primitive :: u64 , } , } } pub mod types { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct AccountData < _0 > { pub free : _0 , pub reserved : _0 , pub frozen : _0 , pub flags : runtime_types :: pallet_balances :: types :: ExtraFlags , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum AdjustmentDirection { # [codec (index = 0)] Increase , # [codec (index = 1)] Decrease , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct BalanceLock < _0 > { pub id : [:: core :: primitive :: u8 ; 8usize] , pub amount : _0 , pub reasons : runtime_types :: pallet_balances :: types :: Reasons , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: CompactAs , :: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct ExtraFlags (pub :: core :: primitive :: u128 ,) ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct IdAmount < _0 , _1 > { pub id : _0 , pub amount : _1 , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum Reasons { # [codec (index = 0)] Fee , # [codec (index = 1)] Misc , # [codec (index = 2)] All , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct ReserveData < _0 , _1 > { pub id : _0 , pub amount : _1 , } } } pub mod pallet_collective { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Contains a variant per dispatchable extrinsic that this pallet has."] pub enum Call { # [codec (index = 0)] # [doc = "Set the collective's membership."] # [doc = ""] # [doc = "- `new_members`: The new member list. Be nice to the chain and provide it sorted."] # [doc = "- `prime`: The prime member whose vote sets the default."] # [doc = "- `old_count`: The upper bound for the previous number of members in storage. Used for"] # [doc = "  weight estimation."] # [doc = ""] # [doc = "The dispatch of this call must be `SetMembersOrigin`."] # [doc = ""] # [doc = "NOTE: Does not enforce the expected `MaxMembers` limit on the amount of members, but"] # [doc = "      the weight estimations rely on it to estimate dispatchable weight."] # [doc = ""] # [doc = "# WARNING:"] # [doc = ""] # [doc = "The `pallet-collective` can also be managed by logic outside of the pallet through the"] # [doc = "implementation of the trait [`ChangeMembers`]."] # [doc = "Any call to `set_members` must be careful that the member set doesn't get out of sync"] # [doc = "with other logic managing the member set."] # [doc = ""] # [doc = "## Complexity:"] # [doc = "- `O(MP + N)` where:"] # [doc = "  - `M` old-members-count (code- and governance-bounded)"] # [doc = "  - `N` new-members-count (code- and governance-bounded)"] # [doc = "  - `P` proposals-count (code-bounded)"] set_members { new_members : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: subxt :: ext :: subxt_core :: utils :: AccountId32 > , prime : :: core :: option :: Option < :: subxt :: ext :: subxt_core :: utils :: AccountId32 > , old_count : :: core :: primitive :: u32 , } , # [codec (index = 1)] # [doc = "Dispatch a proposal from a member using the `Member` origin."] # [doc = ""] # [doc = "Origin must be a member of the collective."] # [doc = ""] # [doc = "## Complexity:"] # [doc = "- `O(B + M + P)` where:"] # [doc = "- `B` is `proposal` size in bytes (length-fee-bounded)"] # [doc = "- `M` members-count (code-bounded)"] # [doc = "- `P` complexity of dispatching `proposal`"] execute { proposal : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < runtime_types :: node_subtensor_runtime :: RuntimeCall > , # [codec (compact)] length_bound : :: core :: primitive :: u32 , } , # [codec (index = 2)] # [doc = "Add a new proposal to either be voted on or executed directly."] # [doc = ""] # [doc = "Requires the sender to be member."] # [doc = ""] # [doc = "`threshold` determines whether `proposal` is executed directly (`threshold < 2`)"] # [doc = "or put up for voting."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(B + M + P1)` or `O(B + M + P2)` where:"] # [doc = "  - `B` is `proposal` size in bytes (length-fee-bounded)"] # [doc = "  - `M` is members-count (code- and governance-bounded)"] # [doc = "  - branching is influenced by `threshold` where:"] # [doc = "    - `P1` is proposal execution complexity (`threshold < 2`)"] # [doc = "    - `P2` is proposals-count (code-bounded) (`threshold >= 2`)"] propose { proposal : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < runtime_types :: node_subtensor_runtime :: RuntimeCall > , # [codec (compact)] length_bound : :: core :: primitive :: u32 , duration : :: core :: primitive :: u32 , } , # [codec (index = 3)] # [doc = "Add an aye or nay vote for the sender to the given proposal."] # [doc = ""] # [doc = "Requires the sender to be a member."] # [doc = ""] # [doc = "Transaction fees will be waived if the member is voting on any particular proposal"] # [doc = "for the first time and the call is successful. Subsequent vote changes will charge a"] # [doc = "fee."] # [doc = "## Complexity"] # [doc = "- `O(M)` where `M` is members-count (code- and governance-bounded)"] vote { proposal : :: subxt :: ext :: subxt_core :: utils :: H256 , # [codec (compact)] index : :: core :: primitive :: u32 , approve : :: core :: primitive :: bool , } , # [codec (index = 5)] # [doc = "Disapprove a proposal, close, and remove it from the system, regardless of its current"] # [doc = "state."] # [doc = ""] # [doc = "Must be called by the Root origin."] # [doc = ""] # [doc = "Parameters:"] # [doc = "* `proposal_hash`: The hash of the proposal that should be disapproved."] # [doc = ""] # [doc = "## Complexity"] # [doc = "O(P) where P is the number of max proposals"] disapprove_proposal { proposal_hash : :: subxt :: ext :: subxt_core :: utils :: H256 , } , # [codec (index = 6)] # [doc = "Close a vote that is either approved, disapproved or whose voting period has ended."] # [doc = ""] # [doc = "May be called by any signed account in order to finish voting and close the proposal."] # [doc = ""] # [doc = "If called before the end of the voting period it will only close the vote if it is"] # [doc = "has enough votes to be approved or disapproved."] # [doc = ""] # [doc = "If called after the end of the voting period abstentions are counted as rejections"] # [doc = "unless there is a prime member set and the prime member cast an approval."] # [doc = ""] # [doc = "If the close operation completes successfully with disapproval, the transaction fee will"] # [doc = "be waived. Otherwise execution of the approved operation will be charged to the caller."] # [doc = ""] # [doc = "+ `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed"] # [doc = "proposal."] # [doc = "+ `length_bound`: The upper bound for the length of the proposal in storage. Checked via"] # [doc = "`storage::read` so it is `size_of::<u32>() == 4` larger than the pure length."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(B + M + P1 + P2)` where:"] # [doc = "  - `B` is `proposal` size in bytes (length-fee-bounded)"] # [doc = "  - `M` is members-count (code- and governance-bounded)"] # [doc = "  - `P1` is the complexity of `proposal` preimage."] # [doc = "  - `P2` is proposal-count (code-bounded)"] close { proposal_hash : :: subxt :: ext :: subxt_core :: utils :: H256 , # [codec (compact)] index : :: core :: primitive :: u32 , proposal_weight_bound : runtime_types :: sp_weights :: weight_v2 :: Weight , # [codec (compact)] length_bound : :: core :: primitive :: u32 , } , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The `Error` enum of this pallet."] pub enum Error { # [codec (index = 0)] # [doc = "Account is not a member of collective"] NotMember , # [codec (index = 1)] # [doc = "Duplicate proposals not allowed"] DuplicateProposal , # [codec (index = 2)] # [doc = "Proposal must exist"] ProposalNotExists , # [codec (index = 3)] # [doc = "Index mismatched the proposal hash"] IndexMismatchProposalHash , # [codec (index = 4)] # [doc = "Duplicate vote ignored"] DuplicateVote , # [codec (index = 5)] # [doc = "The call to close the proposal was made too early, before the end of the voting"] TooEarlyToCloseProposal , # [codec (index = 6)] # [doc = "There can only be a maximum of `MaxProposals` active proposals."] TooManyActiveProposals , # [codec (index = 7)] # [doc = "The given weight-bound for the proposal was too low."] ProposalWeightLessThanDispatchCallWeight , # [codec (index = 8)] # [doc = "The given length-bound for the proposal was too low."] ProposalLengthBoundLessThanProposalLength , # [codec (index = 9)] # [doc = "The given motion duration for the proposal was too low."] DurationLowerThanConfiguredMotionDuration , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The `Event` enum of this pallet"] pub enum Event { # [codec (index = 0)] # [doc = "A motion (given hash) has been proposed (by given account) with a threshold (given"] # [doc = "`MemberCount`)."] Proposed { account : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , proposal_index : :: core :: primitive :: u32 , proposal_hash : :: subxt :: ext :: subxt_core :: utils :: H256 , threshold : :: core :: primitive :: u32 , } , # [codec (index = 1)] # [doc = "A motion (given hash) has been voted on by given account, leaving"] # [doc = "a tally (yes votes and no votes given respectively as `MemberCount`)."] Voted { account : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , proposal_hash : :: subxt :: ext :: subxt_core :: utils :: H256 , voted : :: core :: primitive :: bool , yes : :: core :: primitive :: u32 , no : :: core :: primitive :: u32 , } , # [codec (index = 2)] # [doc = "A motion was approved by the required threshold."] Approved { proposal_hash : :: subxt :: ext :: subxt_core :: utils :: H256 , } , # [codec (index = 3)] # [doc = "A motion was not approved by the required threshold."] Disapproved { proposal_hash : :: subxt :: ext :: subxt_core :: utils :: H256 , } , # [codec (index = 4)] # [doc = "A motion was executed; result will be `Ok` if it returned without error."] Executed { proposal_hash : :: subxt :: ext :: subxt_core :: utils :: H256 , result : :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > , } , # [codec (index = 5)] # [doc = "A single member did some action; result will be `Ok` if it returned without error."] MemberExecuted { proposal_hash : :: subxt :: ext :: subxt_core :: utils :: H256 , result : :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > , } , # [codec (index = 6)] # [doc = "A proposal was closed because its threshold was reached or after its duration was up."] Closed { proposal_hash : :: subxt :: ext :: subxt_core :: utils :: H256 , yes : :: core :: primitive :: u32 , no : :: core :: primitive :: u32 , } , } } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum RawOrigin < _0 > { # [codec (index = 0)] Members (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) , # [codec (index = 1)] Member (_0 ,) , # [codec (index = 2)] _Phantom , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct Votes < _0 , _1 > { pub index : :: core :: primitive :: u32 , pub threshold : :: core :: primitive :: u32 , pub ayes : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < _0 > , pub nays : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < _0 > , pub end : _1 , } } pub mod pallet_commitments { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Contains a variant per dispatchable extrinsic that this pallet has."] pub enum Call { # [codec (index = 0)] # [doc = "Set the commitment for a given netuid"] set_commitment { netuid : :: core :: primitive :: u16 , info : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < runtime_types :: pallet_commitments :: types :: CommitmentInfo > , } , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The `Error` enum of this pallet."] pub enum Error { # [codec (index = 0)] # [doc = "Account passed too many additional fields to their commitment"] TooManyFieldsInCommitmentInfo , # [codec (index = 1)] # [doc = "Account is not allow to make commitments to the chain"] AccountNotAllowedCommit , # [codec (index = 2)] # [doc = "Account is trying to commit data too fast, rate limit exceeded"] CommitmentSetRateLimitExceeded , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The `Event` enum of this pallet"] pub enum Event { # [codec (index = 0)] # [doc = "A commitment was set"] Commitment { netuid : :: core :: primitive :: u16 , who : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , } , } } pub mod types { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct CommitmentInfo { pub fields : runtime_types :: bounded_collections :: bounded_vec :: BoundedVec < runtime_types :: pallet_commitments :: types :: Data > , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum Data { # [codec (index = 0)] None , # [codec (index = 1)] Raw0 ([:: core :: primitive :: u8 ; 0usize] ,) , # [codec (index = 2)] Raw1 ([:: core :: primitive :: u8 ; 1usize] ,) , # [codec (index = 3)] Raw2 ([:: core :: primitive :: u8 ; 2usize] ,) , # [codec (index = 4)] Raw3 ([:: core :: primitive :: u8 ; 3usize] ,) , # [codec (index = 5)] Raw4 ([:: core :: primitive :: u8 ; 4usize] ,) , # [codec (index = 6)] Raw5 ([:: core :: primitive :: u8 ; 5usize] ,) , # [codec (index = 7)] Raw6 ([:: core :: primitive :: u8 ; 6usize] ,) , # [codec (index = 8)] Raw7 ([:: core :: primitive :: u8 ; 7usize] ,) , # [codec (index = 9)] Raw8 ([:: core :: primitive :: u8 ; 8usize] ,) , # [codec (index = 10)] Raw9 ([:: core :: primitive :: u8 ; 9usize] ,) , # [codec (index = 11)] Raw10 ([:: core :: primitive :: u8 ; 10usize] ,) , # [codec (index = 12)] Raw11 ([:: core :: primitive :: u8 ; 11usize] ,) , # [codec (index = 13)] Raw12 ([:: core :: primitive :: u8 ; 12usize] ,) , # [codec (index = 14)] Raw13 ([:: core :: primitive :: u8 ; 13usize] ,) , # [codec (index = 15)] Raw14 ([:: core :: primitive :: u8 ; 14usize] ,) , # [codec (index = 16)] Raw15 ([:: core :: primitive :: u8 ; 15usize] ,) , # [codec (index = 17)] Raw16 ([:: core :: primitive :: u8 ; 16usize] ,) , # [codec (index = 18)] Raw17 ([:: core :: primitive :: u8 ; 17usize] ,) , # [codec (index = 19)] Raw18 ([:: core :: primitive :: u8 ; 18usize] ,) , # [codec (index = 20)] Raw19 ([:: core :: primitive :: u8 ; 19usize] ,) , # [codec (index = 21)] Raw20 ([:: core :: primitive :: u8 ; 20usize] ,) , # [codec (index = 22)] Raw21 ([:: core :: primitive :: u8 ; 21usize] ,) , # [codec (index = 23)] Raw22 ([:: core :: primitive :: u8 ; 22usize] ,) , # [codec (index = 24)] Raw23 ([:: core :: primitive :: u8 ; 23usize] ,) , # [codec (index = 25)] Raw24 ([:: core :: primitive :: u8 ; 24usize] ,) , # [codec (index = 26)] Raw25 ([:: core :: primitive :: u8 ; 25usize] ,) , # [codec (index = 27)] Raw26 ([:: core :: primitive :: u8 ; 26usize] ,) , # [codec (index = 28)] Raw27 ([:: core :: primitive :: u8 ; 27usize] ,) , # [codec (index = 29)] Raw28 ([:: core :: primitive :: u8 ; 28usize] ,) , # [codec (index = 30)] Raw29 ([:: core :: primitive :: u8 ; 29usize] ,) , # [codec (index = 31)] Raw30 ([:: core :: primitive :: u8 ; 30usize] ,) , # [codec (index = 32)] Raw31 ([:: core :: primitive :: u8 ; 31usize] ,) , # [codec (index = 33)] Raw32 ([:: core :: primitive :: u8 ; 32usize] ,) , # [codec (index = 34)] Raw33 ([:: core :: primitive :: u8 ; 33usize] ,) , # [codec (index = 35)] Raw34 ([:: core :: primitive :: u8 ; 34usize] ,) , # [codec (index = 36)] Raw35 ([:: core :: primitive :: u8 ; 35usize] ,) , # [codec (index = 37)] Raw36 ([:: core :: primitive :: u8 ; 36usize] ,) , # [codec (index = 38)] Raw37 ([:: core :: primitive :: u8 ; 37usize] ,) , # [codec (index = 39)] Raw38 ([:: core :: primitive :: u8 ; 38usize] ,) , # [codec (index = 40)] Raw39 ([:: core :: primitive :: u8 ; 39usize] ,) , # [codec (index = 41)] Raw40 ([:: core :: primitive :: u8 ; 40usize] ,) , # [codec (index = 42)] Raw41 ([:: core :: primitive :: u8 ; 41usize] ,) , # [codec (index = 43)] Raw42 ([:: core :: primitive :: u8 ; 42usize] ,) , # [codec (index = 44)] Raw43 ([:: core :: primitive :: u8 ; 43usize] ,) , # [codec (index = 45)] Raw44 ([:: core :: primitive :: u8 ; 44usize] ,) , # [codec (index = 46)] Raw45 ([:: core :: primitive :: u8 ; 45usize] ,) , # [codec (index = 47)] Raw46 ([:: core :: primitive :: u8 ; 46usize] ,) , # [codec (index = 48)] Raw47 ([:: core :: primitive :: u8 ; 47usize] ,) , # [codec (index = 49)] Raw48 ([:: core :: primitive :: u8 ; 48usize] ,) , # [codec (index = 50)] Raw49 ([:: core :: primitive :: u8 ; 49usize] ,) , # [codec (index = 51)] Raw50 ([:: core :: primitive :: u8 ; 50usize] ,) , # [codec (index = 52)] Raw51 ([:: core :: primitive :: u8 ; 51usize] ,) , # [codec (index = 53)] Raw52 ([:: core :: primitive :: u8 ; 52usize] ,) , # [codec (index = 54)] Raw53 ([:: core :: primitive :: u8 ; 53usize] ,) , # [codec (index = 55)] Raw54 ([:: core :: primitive :: u8 ; 54usize] ,) , # [codec (index = 56)] Raw55 ([:: core :: primitive :: u8 ; 55usize] ,) , # [codec (index = 57)] Raw56 ([:: core :: primitive :: u8 ; 56usize] ,) , # [codec (index = 58)] Raw57 ([:: core :: primitive :: u8 ; 57usize] ,) , # [codec (index = 59)] Raw58 ([:: core :: primitive :: u8 ; 58usize] ,) , # [codec (index = 60)] Raw59 ([:: core :: primitive :: u8 ; 59usize] ,) , # [codec (index = 61)] Raw60 ([:: core :: primitive :: u8 ; 60usize] ,) , # [codec (index = 62)] Raw61 ([:: core :: primitive :: u8 ; 61usize] ,) , # [codec (index = 63)] Raw62 ([:: core :: primitive :: u8 ; 62usize] ,) , # [codec (index = 64)] Raw63 ([:: core :: primitive :: u8 ; 63usize] ,) , # [codec (index = 65)] Raw64 ([:: core :: primitive :: u8 ; 64usize] ,) , # [codec (index = 66)] Raw65 ([:: core :: primitive :: u8 ; 65usize] ,) , # [codec (index = 67)] Raw66 ([:: core :: primitive :: u8 ; 66usize] ,) , # [codec (index = 68)] Raw67 ([:: core :: primitive :: u8 ; 67usize] ,) , # [codec (index = 69)] Raw68 ([:: core :: primitive :: u8 ; 68usize] ,) , # [codec (index = 70)] Raw69 ([:: core :: primitive :: u8 ; 69usize] ,) , # [codec (index = 71)] Raw70 ([:: core :: primitive :: u8 ; 70usize] ,) , # [codec (index = 72)] Raw71 ([:: core :: primitive :: u8 ; 71usize] ,) , # [codec (index = 73)] Raw72 ([:: core :: primitive :: u8 ; 72usize] ,) , # [codec (index = 74)] Raw73 ([:: core :: primitive :: u8 ; 73usize] ,) , # [codec (index = 75)] Raw74 ([:: core :: primitive :: u8 ; 74usize] ,) , # [codec (index = 76)] Raw75 ([:: core :: primitive :: u8 ; 75usize] ,) , # [codec (index = 77)] Raw76 ([:: core :: primitive :: u8 ; 76usize] ,) , # [codec (index = 78)] Raw77 ([:: core :: primitive :: u8 ; 77usize] ,) , # [codec (index = 79)] Raw78 ([:: core :: primitive :: u8 ; 78usize] ,) , # [codec (index = 80)] Raw79 ([:: core :: primitive :: u8 ; 79usize] ,) , # [codec (index = 81)] Raw80 ([:: core :: primitive :: u8 ; 80usize] ,) , # [codec (index = 82)] Raw81 ([:: core :: primitive :: u8 ; 81usize] ,) , # [codec (index = 83)] Raw82 ([:: core :: primitive :: u8 ; 82usize] ,) , # [codec (index = 84)] Raw83 ([:: core :: primitive :: u8 ; 83usize] ,) , # [codec (index = 85)] Raw84 ([:: core :: primitive :: u8 ; 84usize] ,) , # [codec (index = 86)] Raw85 ([:: core :: primitive :: u8 ; 85usize] ,) , # [codec (index = 87)] Raw86 ([:: core :: primitive :: u8 ; 86usize] ,) , # [codec (index = 88)] Raw87 ([:: core :: primitive :: u8 ; 87usize] ,) , # [codec (index = 89)] Raw88 ([:: core :: primitive :: u8 ; 88usize] ,) , # [codec (index = 90)] Raw89 ([:: core :: primitive :: u8 ; 89usize] ,) , # [codec (index = 91)] Raw90 ([:: core :: primitive :: u8 ; 90usize] ,) , # [codec (index = 92)] Raw91 ([:: core :: primitive :: u8 ; 91usize] ,) , # [codec (index = 93)] Raw92 ([:: core :: primitive :: u8 ; 92usize] ,) , # [codec (index = 94)] Raw93 ([:: core :: primitive :: u8 ; 93usize] ,) , # [codec (index = 95)] Raw94 ([:: core :: primitive :: u8 ; 94usize] ,) , # [codec (index = 96)] Raw95 ([:: core :: primitive :: u8 ; 95usize] ,) , # [codec (index = 97)] Raw96 ([:: core :: primitive :: u8 ; 96usize] ,) , # [codec (index = 98)] Raw97 ([:: core :: primitive :: u8 ; 97usize] ,) , # [codec (index = 99)] Raw98 ([:: core :: primitive :: u8 ; 98usize] ,) , # [codec (index = 100)] Raw99 ([:: core :: primitive :: u8 ; 99usize] ,) , # [codec (index = 101)] Raw100 ([:: core :: primitive :: u8 ; 100usize] ,) , # [codec (index = 102)] Raw101 ([:: core :: primitive :: u8 ; 101usize] ,) , # [codec (index = 103)] Raw102 ([:: core :: primitive :: u8 ; 102usize] ,) , # [codec (index = 104)] Raw103 ([:: core :: primitive :: u8 ; 103usize] ,) , # [codec (index = 105)] Raw104 ([:: core :: primitive :: u8 ; 104usize] ,) , # [codec (index = 106)] Raw105 ([:: core :: primitive :: u8 ; 105usize] ,) , # [codec (index = 107)] Raw106 ([:: core :: primitive :: u8 ; 106usize] ,) , # [codec (index = 108)] Raw107 ([:: core :: primitive :: u8 ; 107usize] ,) , # [codec (index = 109)] Raw108 ([:: core :: primitive :: u8 ; 108usize] ,) , # [codec (index = 110)] Raw109 ([:: core :: primitive :: u8 ; 109usize] ,) , # [codec (index = 111)] Raw110 ([:: core :: primitive :: u8 ; 110usize] ,) , # [codec (index = 112)] Raw111 ([:: core :: primitive :: u8 ; 111usize] ,) , # [codec (index = 113)] Raw112 ([:: core :: primitive :: u8 ; 112usize] ,) , # [codec (index = 114)] Raw113 ([:: core :: primitive :: u8 ; 113usize] ,) , # [codec (index = 115)] Raw114 ([:: core :: primitive :: u8 ; 114usize] ,) , # [codec (index = 116)] Raw115 ([:: core :: primitive :: u8 ; 115usize] ,) , # [codec (index = 117)] Raw116 ([:: core :: primitive :: u8 ; 116usize] ,) , # [codec (index = 118)] Raw117 ([:: core :: primitive :: u8 ; 117usize] ,) , # [codec (index = 119)] Raw118 ([:: core :: primitive :: u8 ; 118usize] ,) , # [codec (index = 120)] Raw119 ([:: core :: primitive :: u8 ; 119usize] ,) , # [codec (index = 121)] Raw120 ([:: core :: primitive :: u8 ; 120usize] ,) , # [codec (index = 122)] Raw121 ([:: core :: primitive :: u8 ; 121usize] ,) , # [codec (index = 123)] Raw122 ([:: core :: primitive :: u8 ; 122usize] ,) , # [codec (index = 124)] Raw123 ([:: core :: primitive :: u8 ; 123usize] ,) , # [codec (index = 125)] Raw124 ([:: core :: primitive :: u8 ; 124usize] ,) , # [codec (index = 126)] Raw125 ([:: core :: primitive :: u8 ; 125usize] ,) , # [codec (index = 127)] Raw126 ([:: core :: primitive :: u8 ; 126usize] ,) , # [codec (index = 128)] Raw127 ([:: core :: primitive :: u8 ; 127usize] ,) , # [codec (index = 129)] Raw128 ([:: core :: primitive :: u8 ; 128usize] ,) , # [codec (index = 130)] BlakeTwo256 ([:: core :: primitive :: u8 ; 32usize] ,) , # [codec (index = 131)] Sha256 ([:: core :: primitive :: u8 ; 32usize] ,) , # [codec (index = 132)] Keccak256 ([:: core :: primitive :: u8 ; 32usize] ,) , # [codec (index = 133)] ShaThree256 ([:: core :: primitive :: u8 ; 32usize] ,) , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct Registration < _0 , _2 > { pub deposit : _0 , pub block : _2 , pub info : runtime_types :: pallet_commitments :: types :: CommitmentInfo , } } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct CommitmentsSignedExtension < _0 > (pub :: core :: marker :: PhantomData < _0 >) ; } pub mod pallet_grandpa { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Contains a variant per dispatchable extrinsic that this pallet has."] pub enum Call { # [codec (index = 0)] # [doc = "Report voter equivocation/misbehavior. This method will verify the"] # [doc = "equivocation proof and validate the given key ownership proof"] # [doc = "against the extracted offender. If both are valid, the offence"] # [doc = "will be reported."] report_equivocation { equivocation_proof : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < runtime_types :: sp_consensus_grandpa :: EquivocationProof < :: subxt :: ext :: subxt_core :: utils :: H256 , :: core :: primitive :: u32 > > , key_owner_proof : runtime_types :: sp_core :: Void , } , # [codec (index = 1)] # [doc = "Report voter equivocation/misbehavior. This method will verify the"] # [doc = "equivocation proof and validate the given key ownership proof"] # [doc = "against the extracted offender. If both are valid, the offence"] # [doc = "will be reported."] # [doc = ""] # [doc = "This extrinsic must be called unsigned and it is expected that only"] # [doc = "block authors will call it (validated in `ValidateUnsigned`), as such"] # [doc = "if the block author is defined it will be defined as the equivocation"] # [doc = "reporter."] report_equivocation_unsigned { equivocation_proof : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < runtime_types :: sp_consensus_grandpa :: EquivocationProof < :: subxt :: ext :: subxt_core :: utils :: H256 , :: core :: primitive :: u32 > > , key_owner_proof : runtime_types :: sp_core :: Void , } , # [codec (index = 2)] # [doc = "Note that the current authority set of the GRANDPA finality gadget has stalled."] # [doc = ""] # [doc = "This will trigger a forced authority set change at the beginning of the next session, to"] # [doc = "be enacted `delay` blocks after that. The `delay` should be high enough to safely assume"] # [doc = "that the block signalling the forced change will not be re-orged e.g. 1000 blocks."] # [doc = "The block production rate (which may be slowed down because of finality lagging) should"] # [doc = "be taken into account when choosing the `delay`. The GRANDPA voters based on the new"] # [doc = "authority will start voting on top of `best_finalized_block_number` for new finalized"] # [doc = "blocks. `best_finalized_block_number` should be the highest of the latest finalized"] # [doc = "block of all validators of the new authority set."] # [doc = ""] # [doc = "Only callable by root."] note_stalled { delay : :: core :: primitive :: u32 , best_finalized_block_number : :: core :: primitive :: u32 , } , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The `Error` enum of this pallet."] pub enum Error { # [codec (index = 0)] # [doc = "Attempt to signal GRANDPA pause when the authority set isn't live"] # [doc = "(either paused or already pending pause)."] PauseFailed , # [codec (index = 1)] # [doc = "Attempt to signal GRANDPA resume when the authority set isn't paused"] # [doc = "(either live or already pending resume)."] ResumeFailed , # [codec (index = 2)] # [doc = "Attempt to signal GRANDPA change with one already pending."] ChangePending , # [codec (index = 3)] # [doc = "Cannot signal forced change so soon after last."] TooSoon , # [codec (index = 4)] # [doc = "A key ownership proof provided as part of an equivocation report is invalid."] InvalidKeyOwnershipProof , # [codec (index = 5)] # [doc = "An equivocation proof provided as part of an equivocation report is invalid."] InvalidEquivocationProof , # [codec (index = 6)] # [doc = "A given equivocation report is valid but already previously reported."] DuplicateOffenceReport , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The `Event` enum of this pallet"] pub enum Event { # [codec (index = 0)] # [doc = "New authority set has been applied."] NewAuthorities { authority_set : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < (runtime_types :: sp_consensus_grandpa :: app :: Public , :: core :: primitive :: u64 ,) > , } , # [codec (index = 1)] # [doc = "Current authority set has been paused."] Paused , # [codec (index = 2)] # [doc = "Current authority set has been resumed."] Resumed , } } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct StoredPendingChange < _0 > { pub scheduled_at : _0 , pub delay : _0 , pub next_authorities : runtime_types :: bounded_collections :: weak_bounded_vec :: WeakBoundedVec < (runtime_types :: sp_consensus_grandpa :: app :: Public , :: core :: primitive :: u64 ,) > , pub forced : :: core :: option :: Option < _0 > , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum StoredState < _0 > { # [codec (index = 0)] Live , # [codec (index = 1)] PendingPause { scheduled_at : _0 , delay : _0 , } , # [codec (index = 2)] Paused , # [codec (index = 3)] PendingResume { scheduled_at : _0 , delay : _0 , } , } } pub mod pallet_membership { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Contains a variant per dispatchable extrinsic that this pallet has."] pub enum Call { # [codec (index = 0)] # [doc = "Add a member `who` to the set."] # [doc = ""] # [doc = "May only be called from `T::AddOrigin`."] add_member { who : :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > , } , # [codec (index = 1)] # [doc = "Remove a member `who` from the set."] # [doc = ""] # [doc = "May only be called from `T::RemoveOrigin`."] remove_member { who : :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > , } , # [codec (index = 2)] # [doc = "Swap out one member `remove` for another `add`."] # [doc = ""] # [doc = "May only be called from `T::SwapOrigin`."] # [doc = ""] # [doc = "Prime membership is *not* passed from `remove` to `add`, if extant."] swap_member { remove : :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > , add : :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > , } , # [codec (index = 3)] # [doc = "Change the membership to a new set, disregarding the existing membership. Be nice and"] # [doc = "pass `members` pre-sorted."] # [doc = ""] # [doc = "May only be called from `T::ResetOrigin`."] reset_members { members : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: subxt :: ext :: subxt_core :: utils :: AccountId32 > , } , # [codec (index = 4)] # [doc = "Swap out the sending member for some other key `new`."] # [doc = ""] # [doc = "May only be called from `Signed` origin of a current member."] # [doc = ""] # [doc = "Prime membership is passed from the origin account to `new`, if extant."] change_key { new : :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > , } , # [codec (index = 5)] # [doc = "Set the prime member. Must be a current member."] # [doc = ""] # [doc = "May only be called from `T::PrimeOrigin`."] set_prime { who : :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > , } , # [codec (index = 6)] # [doc = "Remove the prime member if it exists."] # [doc = ""] # [doc = "May only be called from `T::PrimeOrigin`."] clear_prime , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The `Error` enum of this pallet."] pub enum Error { # [codec (index = 0)] # [doc = "Already a member."] AlreadyMember , # [codec (index = 1)] # [doc = "Not a member."] NotMember , # [codec (index = 2)] # [doc = "Too many members."] TooManyMembers , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The `Event` enum of this pallet"] pub enum Event { # [codec (index = 0)] # [doc = "The given member was added; see the transaction for who."] MemberAdded , # [codec (index = 1)] # [doc = "The given member was removed; see the transaction for who."] MemberRemoved , # [codec (index = 2)] # [doc = "Two members were swapped; see the transaction for who."] MembersSwapped , # [codec (index = 3)] # [doc = "The membership was reset; see the transaction for who the new set is."] MembersReset , # [codec (index = 4)] # [doc = "One of the members' keys changed."] KeyChanged , # [codec (index = 5)] # [doc = "Phantom member, never used."] Dummy , } } } pub mod pallet_multisig { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Contains a variant per dispatchable extrinsic that this pallet has."] pub enum Call { # [codec (index = 0)] # [doc = "Immediately dispatch a multi-signature call using a single approval from the caller."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "- `other_signatories`: The accounts (other than the sender) who are part of the"] # [doc = "multi-signature, but do not participate in the approval process."] # [doc = "- `call`: The call to be executed."] # [doc = ""] # [doc = "Result is equivalent to the dispatched result."] # [doc = ""] # [doc = "## Complexity"] # [doc = "O(Z + C) where Z is the length of the call and C its execution weight."] as_multi_threshold_1 { other_signatories : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: subxt :: ext :: subxt_core :: utils :: AccountId32 > , call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < runtime_types :: node_subtensor_runtime :: RuntimeCall > , } , # [codec (index = 1)] # [doc = "Register approval for a dispatch to be made from a deterministic composite account if"] # [doc = "approved by a total of `threshold - 1` of `other_signatories`."] # [doc = ""] # [doc = "If there are enough, then dispatch the call."] # [doc = ""] # [doc = "Payment: `DepositBase` will be reserved if this is the first approval, plus"] # [doc = "`threshold` times `DepositFactor`. It is returned once this dispatch happens or"] # [doc = "is cancelled."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "- `threshold`: The total number of approvals for this dispatch before it is executed."] # [doc = "- `other_signatories`: The accounts (other than the sender) who can approve this"] # [doc = "dispatch. May not be empty."] # [doc = "- `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is"] # [doc = "not the first approval, then it must be `Some`, with the timepoint (block number and"] # [doc = "transaction index) of the first approval transaction."] # [doc = "- `call`: The call to be executed."] # [doc = ""] # [doc = "NOTE: Unless this is the final approval, you will generally want to use"] # [doc = "`approve_as_multi` instead, since it only requires a hash of the call."] # [doc = ""] # [doc = "Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise"] # [doc = "on success, result is `Ok` and the result from the interior call, if it was executed,"] # [doc = "may be found in the deposited `MultisigExecuted` event."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(S + Z + Call)`."] # [doc = "- Up to one balance-reserve or unreserve operation."] # [doc = "- One passthrough operation, one insert, both `O(S)` where `S` is the number of"] # [doc = "  signatories. `S` is capped by `MaxSignatories`, with weight being proportional."] # [doc = "- One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len."] # [doc = "- One encode & hash, both of complexity `O(S)`."] # [doc = "- Up to one binary search and insert (`O(logS + S)`)."] # [doc = "- I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove."] # [doc = "- One event."] # [doc = "- The weight of the `call`."] # [doc = "- Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit"] # [doc = "  taken for its lifetime of `DepositBase + threshold * DepositFactor`."] as_multi { threshold : :: core :: primitive :: u16 , other_signatories : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: subxt :: ext :: subxt_core :: utils :: AccountId32 > , maybe_timepoint : :: core :: option :: Option < runtime_types :: pallet_multisig :: Timepoint < :: core :: primitive :: u32 > > , call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < runtime_types :: node_subtensor_runtime :: RuntimeCall > , max_weight : runtime_types :: sp_weights :: weight_v2 :: Weight , } , # [codec (index = 2)] # [doc = "Register approval for a dispatch to be made from a deterministic composite account if"] # [doc = "approved by a total of `threshold - 1` of `other_signatories`."] # [doc = ""] # [doc = "Payment: `DepositBase` will be reserved if this is the first approval, plus"] # [doc = "`threshold` times `DepositFactor`. It is returned once this dispatch happens or"] # [doc = "is cancelled."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "- `threshold`: The total number of approvals for this dispatch before it is executed."] # [doc = "- `other_signatories`: The accounts (other than the sender) who can approve this"] # [doc = "dispatch. May not be empty."] # [doc = "- `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is"] # [doc = "not the first approval, then it must be `Some`, with the timepoint (block number and"] # [doc = "transaction index) of the first approval transaction."] # [doc = "- `call_hash`: The hash of the call to be executed."] # [doc = ""] # [doc = "NOTE: If this is the final approval, you will want to use `as_multi` instead."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(S)`."] # [doc = "- Up to one balance-reserve or unreserve operation."] # [doc = "- One passthrough operation, one insert, both `O(S)` where `S` is the number of"] # [doc = "  signatories. `S` is capped by `MaxSignatories`, with weight being proportional."] # [doc = "- One encode & hash, both of complexity `O(S)`."] # [doc = "- Up to one binary search and insert (`O(logS + S)`)."] # [doc = "- I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove."] # [doc = "- One event."] # [doc = "- Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit"] # [doc = "  taken for its lifetime of `DepositBase + threshold * DepositFactor`."] approve_as_multi { threshold : :: core :: primitive :: u16 , other_signatories : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: subxt :: ext :: subxt_core :: utils :: AccountId32 > , maybe_timepoint : :: core :: option :: Option < runtime_types :: pallet_multisig :: Timepoint < :: core :: primitive :: u32 > > , call_hash : [:: core :: primitive :: u8 ; 32usize] , max_weight : runtime_types :: sp_weights :: weight_v2 :: Weight , } , # [codec (index = 3)] # [doc = "Cancel a pre-existing, on-going multisig transaction. Any deposit reserved previously"] # [doc = "for this operation will be unreserved on success."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "- `threshold`: The total number of approvals for this dispatch before it is executed."] # [doc = "- `other_signatories`: The accounts (other than the sender) who can approve this"] # [doc = "dispatch. May not be empty."] # [doc = "- `timepoint`: The timepoint (block number and transaction index) of the first approval"] # [doc = "transaction for this dispatch."] # [doc = "- `call_hash`: The hash of the call to be executed."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(S)`."] # [doc = "- Up to one balance-reserve or unreserve operation."] # [doc = "- One passthrough operation, one insert, both `O(S)` where `S` is the number of"] # [doc = "  signatories. `S` is capped by `MaxSignatories`, with weight being proportional."] # [doc = "- One encode & hash, both of complexity `O(S)`."] # [doc = "- One event."] # [doc = "- I/O: 1 read `O(S)`, one remove."] # [doc = "- Storage: removes one item."] cancel_as_multi { threshold : :: core :: primitive :: u16 , other_signatories : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: subxt :: ext :: subxt_core :: utils :: AccountId32 > , timepoint : runtime_types :: pallet_multisig :: Timepoint < :: core :: primitive :: u32 > , call_hash : [:: core :: primitive :: u8 ; 32usize] , } , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The `Error` enum of this pallet."] pub enum Error { # [codec (index = 0)] # [doc = "Threshold must be 2 or greater."] MinimumThreshold , # [codec (index = 1)] # [doc = "Call is already approved by this signatory."] AlreadyApproved , # [codec (index = 2)] # [doc = "Call doesn't need any (more) approvals."] NoApprovalsNeeded , # [codec (index = 3)] # [doc = "There are too few signatories in the list."] TooFewSignatories , # [codec (index = 4)] # [doc = "There are too many signatories in the list."] TooManySignatories , # [codec (index = 5)] # [doc = "The signatories were provided out of order; they should be ordered."] SignatoriesOutOfOrder , # [codec (index = 6)] # [doc = "The sender was contained in the other signatories; it shouldn't be."] SenderInSignatories , # [codec (index = 7)] # [doc = "Multisig operation not found when attempting to cancel."] NotFound , # [codec (index = 8)] # [doc = "Only the account that originally created the multisig is able to cancel it."] NotOwner , # [codec (index = 9)] # [doc = "No timepoint was given, yet the multisig operation is already underway."] NoTimepoint , # [codec (index = 10)] # [doc = "A different timepoint was given to the multisig operation that is underway."] WrongTimepoint , # [codec (index = 11)] # [doc = "A timepoint was given, yet no multisig operation is underway."] UnexpectedTimepoint , # [codec (index = 12)] # [doc = "The maximum weight information provided was too low."] MaxWeightTooLow , # [codec (index = 13)] # [doc = "The data to be stored is already stored."] AlreadyStored , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The `Event` enum of this pallet"] pub enum Event { # [codec (index = 0)] # [doc = "A new multisig operation has begun."] NewMultisig { approving : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , multisig : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , call_hash : [:: core :: primitive :: u8 ; 32usize] , } , # [codec (index = 1)] # [doc = "A multisig operation has been approved by someone."] MultisigApproval { approving : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , timepoint : runtime_types :: pallet_multisig :: Timepoint < :: core :: primitive :: u32 > , multisig : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , call_hash : [:: core :: primitive :: u8 ; 32usize] , } , # [codec (index = 2)] # [doc = "A multisig operation has been executed."] MultisigExecuted { approving : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , timepoint : runtime_types :: pallet_multisig :: Timepoint < :: core :: primitive :: u32 > , multisig : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , call_hash : [:: core :: primitive :: u8 ; 32usize] , result : :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > , } , # [codec (index = 3)] # [doc = "A multisig operation has been cancelled."] MultisigCancelled { cancelling : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , timepoint : runtime_types :: pallet_multisig :: Timepoint < :: core :: primitive :: u32 > , multisig : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , call_hash : [:: core :: primitive :: u8 ; 32usize] , } , } } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct Multisig < _0 , _1 , _2 > { pub when : runtime_types :: pallet_multisig :: Timepoint < _0 > , pub deposit : _1 , pub depositor : _2 , pub approvals : runtime_types :: bounded_collections :: bounded_vec :: BoundedVec < _2 > , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct Timepoint < _0 > { pub height : _0 , pub index : :: core :: primitive :: u32 , } } pub mod pallet_preimage { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Contains a variant per dispatchable extrinsic that this pallet has."] pub enum Call { # [codec (index = 0)] # [doc = "Register a preimage on-chain."] # [doc = ""] # [doc = "If the preimage was previously requested, no fees or deposits are taken for providing"] # [doc = "the preimage. Otherwise, a deposit is taken proportional to the size of the preimage."] note_preimage { bytes : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 1)] # [doc = "Clear an unrequested preimage from the runtime storage."] # [doc = ""] # [doc = "If `len` is provided, then it will be a much cheaper operation."] # [doc = ""] # [doc = "- `hash`: The hash of the preimage to be removed from the store."] # [doc = "- `len`: The length of the preimage of `hash`."] unnote_preimage { hash : :: subxt :: ext :: subxt_core :: utils :: H256 , } , # [codec (index = 2)] # [doc = "Request a preimage be uploaded to the chain without paying any fees or deposits."] # [doc = ""] # [doc = "If the preimage requests has already been provided on-chain, we unreserve any deposit"] # [doc = "a user may have paid, and take the control of the preimage out of their hands."] request_preimage { hash : :: subxt :: ext :: subxt_core :: utils :: H256 , } , # [codec (index = 3)] # [doc = "Clear a previously made request for a preimage."] # [doc = ""] # [doc = "NOTE: THIS MUST NOT BE CALLED ON `hash` MORE TIMES THAN `request_preimage`."] unrequest_preimage { hash : :: subxt :: ext :: subxt_core :: utils :: H256 , } , # [codec (index = 4)] # [doc = "Ensure that the a bulk of pre-images is upgraded."] # [doc = ""] # [doc = "The caller pays no fee if at least 90% of pre-images were successfully updated."] ensure_updated { hashes : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: subxt :: ext :: subxt_core :: utils :: H256 > , } , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The `Error` enum of this pallet."] pub enum Error { # [codec (index = 0)] # [doc = "Preimage is too large to store on-chain."] TooBig , # [codec (index = 1)] # [doc = "Preimage has already been noted on-chain."] AlreadyNoted , # [codec (index = 2)] # [doc = "The user is not authorized to perform this action."] NotAuthorized , # [codec (index = 3)] # [doc = "The preimage cannot be removed since it has not yet been noted."] NotNoted , # [codec (index = 4)] # [doc = "A preimage may not be removed when there are outstanding requests."] Requested , # [codec (index = 5)] # [doc = "The preimage request cannot be removed since no outstanding requests exist."] NotRequested , # [codec (index = 6)] # [doc = "More than `MAX_HASH_UPGRADE_BULK_COUNT` hashes were requested to be upgraded at once."] TooMany , # [codec (index = 7)] # [doc = "Too few hashes were requested to be upgraded (i.e. zero)."] TooFew , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The `Event` enum of this pallet"] pub enum Event { # [codec (index = 0)] # [doc = "A preimage has been noted."] Noted { hash : :: subxt :: ext :: subxt_core :: utils :: H256 , } , # [codec (index = 1)] # [doc = "A preimage has been requested."] Requested { hash : :: subxt :: ext :: subxt_core :: utils :: H256 , } , # [codec (index = 2)] # [doc = "A preimage has ben cleared."] Cleared { hash : :: subxt :: ext :: subxt_core :: utils :: H256 , } , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum HoldReason { # [codec (index = 0)] Preimage , } } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum OldRequestStatus < _0 , _1 > { # [codec (index = 0)] Unrequested { deposit : (_0 , _1 ,) , len : :: core :: primitive :: u32 , } , # [codec (index = 1)] Requested { deposit : :: core :: option :: Option < (_0 , _1 ,) > , count : :: core :: primitive :: u32 , len : :: core :: option :: Option < :: core :: primitive :: u32 > , } , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum RequestStatus < _0 , _1 > { # [codec (index = 0)] Unrequested { ticket : (_0 , _1 ,) , len : :: core :: primitive :: u32 , } , # [codec (index = 1)] Requested { maybe_ticket : :: core :: option :: Option < (_0 , _1 ,) > , count : :: core :: primitive :: u32 , maybe_len : :: core :: option :: Option < :: core :: primitive :: u32 > , } , } } pub mod pallet_proxy { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Contains a variant per dispatchable extrinsic that this pallet has."] pub enum Call { # [codec (index = 0)] # [doc = "Dispatch the given `call` from an account that the sender is authorised for through"] # [doc = "`add_proxy`."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "Parameters:"] # [doc = "- `real`: The account that the proxy will make a call on behalf of."] # [doc = "- `force_proxy_type`: Specify the exact proxy type to be used and checked for this call."] # [doc = "- `call`: The call to be made by the `real` account."] proxy { real : :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > , force_proxy_type : :: core :: option :: Option < runtime_types :: node_subtensor_runtime :: ProxyType > , call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < runtime_types :: node_subtensor_runtime :: RuntimeCall > , } , # [codec (index = 1)] # [doc = "Register a proxy account for the sender that is able to make calls on its behalf."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "Parameters:"] # [doc = "- `proxy`: The account that the `caller` would like to make a proxy."] # [doc = "- `proxy_type`: The permissions allowed for this proxy account."] # [doc = "- `delay`: The announcement period required of the initial proxy. Will generally be"] # [doc = "zero."] add_proxy { delegate : :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > , proxy_type : runtime_types :: node_subtensor_runtime :: ProxyType , delay : :: core :: primitive :: u32 , } , # [codec (index = 2)] # [doc = "Unregister a proxy account for the sender."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "Parameters:"] # [doc = "- `proxy`: The account that the `caller` would like to remove as a proxy."] # [doc = "- `proxy_type`: The permissions currently enabled for the removed proxy account."] remove_proxy { delegate : :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > , proxy_type : runtime_types :: node_subtensor_runtime :: ProxyType , delay : :: core :: primitive :: u32 , } , # [codec (index = 3)] # [doc = "Unregister all proxy accounts for the sender."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "WARNING: This may be called on accounts created by `pure`, however if done, then"] # [doc = "the unreserved fees will be inaccessible. **All access to this account will be lost.**"] remove_proxies , # [codec (index = 4)] # [doc = "Spawn a fresh new account that is guaranteed to be otherwise inaccessible, and"] # [doc = "initialize it with a proxy of `proxy_type` for `origin` sender."] # [doc = ""] # [doc = "Requires a `Signed` origin."] # [doc = ""] # [doc = "- `proxy_type`: The type of the proxy that the sender will be registered as over the"] # [doc = "new account. This will almost always be the most permissive `ProxyType` possible to"] # [doc = "allow for maximum flexibility."] # [doc = "- `index`: A disambiguation index, in case this is called multiple times in the same"] # [doc = "transaction (e.g. with `utility::batch`). Unless you're using `batch` you probably just"] # [doc = "want to use `0`."] # [doc = "- `delay`: The announcement period required of the initial proxy. Will generally be"] # [doc = "zero."] # [doc = ""] # [doc = "Fails with `Duplicate` if this has already been called in this transaction, from the"] # [doc = "same sender, with the same parameters."] # [doc = ""] # [doc = "Fails if there are insufficient funds to pay for deposit."] create_pure { proxy_type : runtime_types :: node_subtensor_runtime :: ProxyType , delay : :: core :: primitive :: u32 , index : :: core :: primitive :: u16 , } , # [codec (index = 5)] # [doc = "Removes a previously spawned pure proxy."] # [doc = ""] # [doc = "WARNING: **All access to this account will be lost.** Any funds held in it will be"] # [doc = "inaccessible."] # [doc = ""] # [doc = "Requires a `Signed` origin, and the sender account must have been created by a call to"] # [doc = "`pure` with corresponding parameters."] # [doc = ""] # [doc = "- `spawner`: The account that originally called `pure` to create this account."] # [doc = "- `index`: The disambiguation index originally passed to `pure`. Probably `0`."] # [doc = "- `proxy_type`: The proxy type originally passed to `pure`."] # [doc = "- `height`: The height of the chain when the call to `pure` was processed."] # [doc = "- `ext_index`: The extrinsic index in which the call to `pure` was processed."] # [doc = ""] # [doc = "Fails with `NoPermission` in case the caller is not a previously created pure"] # [doc = "account whose `pure` call has corresponding parameters."] kill_pure { spawner : :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > , proxy_type : runtime_types :: node_subtensor_runtime :: ProxyType , index : :: core :: primitive :: u16 , # [codec (compact)] height : :: core :: primitive :: u32 , # [codec (compact)] ext_index : :: core :: primitive :: u32 , } , # [codec (index = 6)] # [doc = "Publish the hash of a proxy-call that will be made in the future."] # [doc = ""] # [doc = "This must be called some number of blocks before the corresponding `proxy` is attempted"] # [doc = "if the delay associated with the proxy relationship is greater than zero."] # [doc = ""] # [doc = "No more than `MaxPending` announcements may be made at any one time."] # [doc = ""] # [doc = "This will take a deposit of `AnnouncementDepositFactor` as well as"] # [doc = "`AnnouncementDepositBase` if there are no other pending announcements."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ and a proxy of `real`."] # [doc = ""] # [doc = "Parameters:"] # [doc = "- `real`: The account that the proxy will make a call on behalf of."] # [doc = "- `call_hash`: The hash of the call to be made by the `real` account."] announce { real : :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > , call_hash : :: subxt :: ext :: subxt_core :: utils :: H256 , } , # [codec (index = 7)] # [doc = "Remove a given announcement."] # [doc = ""] # [doc = "May be called by a proxy account to remove a call they previously announced and return"] # [doc = "the deposit."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "Parameters:"] # [doc = "- `real`: The account that the proxy will make a call on behalf of."] # [doc = "- `call_hash`: The hash of the call to be made by the `real` account."] remove_announcement { real : :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > , call_hash : :: subxt :: ext :: subxt_core :: utils :: H256 , } , # [codec (index = 8)] # [doc = "Remove the given announcement of a delegate."] # [doc = ""] # [doc = "May be called by a target (proxied) account to remove a call that one of their delegates"] # [doc = "(`delegate`) has announced they want to execute. The deposit is returned."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "Parameters:"] # [doc = "- `delegate`: The account that previously announced the call."] # [doc = "- `call_hash`: The hash of the call to be made."] reject_announcement { delegate : :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > , call_hash : :: subxt :: ext :: subxt_core :: utils :: H256 , } , # [codec (index = 9)] # [doc = "Dispatch the given `call` from an account that the sender is authorized for through"] # [doc = "`add_proxy`."] # [doc = ""] # [doc = "Removes any corresponding announcement(s)."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "Parameters:"] # [doc = "- `real`: The account that the proxy will make a call on behalf of."] # [doc = "- `force_proxy_type`: Specify the exact proxy type to be used and checked for this call."] # [doc = "- `call`: The call to be made by the `real` account."] proxy_announced { delegate : :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > , real : :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > , force_proxy_type : :: core :: option :: Option < runtime_types :: node_subtensor_runtime :: ProxyType > , call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < runtime_types :: node_subtensor_runtime :: RuntimeCall > , } , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The `Error` enum of this pallet."] pub enum Error { # [codec (index = 0)] # [doc = "There are too many proxies registered or too many announcements pending."] TooMany , # [codec (index = 1)] # [doc = "Proxy registration not found."] NotFound , # [codec (index = 2)] # [doc = "Sender is not a proxy of the account to be proxied."] NotProxy , # [codec (index = 3)] # [doc = "A call which is incompatible with the proxy type's filter was attempted."] Unproxyable , # [codec (index = 4)] # [doc = "Account is already a proxy."] Duplicate , # [codec (index = 5)] # [doc = "Call may not be made by proxy because it may escalate its privileges."] NoPermission , # [codec (index = 6)] # [doc = "Announcement, if made at all, was made too recently."] Unannounced , # [codec (index = 7)] # [doc = "Cannot add self as proxy."] NoSelfProxy , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The `Event` enum of this pallet"] pub enum Event { # [codec (index = 0)] # [doc = "A proxy was executed correctly, with the given."] ProxyExecuted { result : :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > , } , # [codec (index = 1)] # [doc = "A pure account has been created by new proxy with given"] # [doc = "disambiguation index and proxy type."] PureCreated { pure : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , who : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , proxy_type : runtime_types :: node_subtensor_runtime :: ProxyType , disambiguation_index : :: core :: primitive :: u16 , } , # [codec (index = 2)] # [doc = "An announcement was placed to make a call in the future."] Announced { real : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , proxy : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , call_hash : :: subxt :: ext :: subxt_core :: utils :: H256 , } , # [codec (index = 3)] # [doc = "A proxy was added."] ProxyAdded { delegator : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , delegatee : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , proxy_type : runtime_types :: node_subtensor_runtime :: ProxyType , delay : :: core :: primitive :: u32 , } , # [codec (index = 4)] # [doc = "A proxy was removed."] ProxyRemoved { delegator : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , delegatee : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , proxy_type : runtime_types :: node_subtensor_runtime :: ProxyType , delay : :: core :: primitive :: u32 , } , } } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct Announcement < _0 , _1 , _2 > { pub real : _0 , pub call_hash : _1 , pub height : _2 , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct ProxyDefinition < _0 , _1 , _2 > { pub delegate : _0 , pub proxy_type : _1 , pub delay : _2 , } } pub mod pallet_registry { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Contains a variant per dispatchable extrinsic that this pallet has."] pub enum Call { # [codec (index = 0)] # [doc = "Register an identity for an account. This will overwrite any existing identity."] set_identity { identified : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , info : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < runtime_types :: pallet_registry :: types :: IdentityInfo > , } , # [codec (index = 1)] # [doc = "Clear the identity of an account."] clear_identity { identified : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , } , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The `Error` enum of this pallet."] pub enum Error { # [codec (index = 0)] # [doc = "Account attempted to register an identity but does not meet the requirements."] CannotRegister , # [codec (index = 1)] # [doc = "Account passed too many additional fields to their identity"] TooManyFieldsInIdentityInfo , # [codec (index = 2)] # [doc = "Account doesn't have a registered identity"] NotRegistered , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The `Event` enum of this pallet"] pub enum Event { # [codec (index = 0)] # [doc = "Emitted when a user registers an identity"] IdentitySet { who : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , } , # [codec (index = 1)] # [doc = "Emitted when a user dissolves an identity"] IdentityDissolved { who : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , } , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum HoldReason { # [codec (index = 0)] RegistryIdentity , } } pub mod types { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum Data { # [codec (index = 0)] None , # [codec (index = 1)] Raw0 ([:: core :: primitive :: u8 ; 0usize] ,) , # [codec (index = 2)] Raw1 ([:: core :: primitive :: u8 ; 1usize] ,) , # [codec (index = 3)] Raw2 ([:: core :: primitive :: u8 ; 2usize] ,) , # [codec (index = 4)] Raw3 ([:: core :: primitive :: u8 ; 3usize] ,) , # [codec (index = 5)] Raw4 ([:: core :: primitive :: u8 ; 4usize] ,) , # [codec (index = 6)] Raw5 ([:: core :: primitive :: u8 ; 5usize] ,) , # [codec (index = 7)] Raw6 ([:: core :: primitive :: u8 ; 6usize] ,) , # [codec (index = 8)] Raw7 ([:: core :: primitive :: u8 ; 7usize] ,) , # [codec (index = 9)] Raw8 ([:: core :: primitive :: u8 ; 8usize] ,) , # [codec (index = 10)] Raw9 ([:: core :: primitive :: u8 ; 9usize] ,) , # [codec (index = 11)] Raw10 ([:: core :: primitive :: u8 ; 10usize] ,) , # [codec (index = 12)] Raw11 ([:: core :: primitive :: u8 ; 11usize] ,) , # [codec (index = 13)] Raw12 ([:: core :: primitive :: u8 ; 12usize] ,) , # [codec (index = 14)] Raw13 ([:: core :: primitive :: u8 ; 13usize] ,) , # [codec (index = 15)] Raw14 ([:: core :: primitive :: u8 ; 14usize] ,) , # [codec (index = 16)] Raw15 ([:: core :: primitive :: u8 ; 15usize] ,) , # [codec (index = 17)] Raw16 ([:: core :: primitive :: u8 ; 16usize] ,) , # [codec (index = 18)] Raw17 ([:: core :: primitive :: u8 ; 17usize] ,) , # [codec (index = 19)] Raw18 ([:: core :: primitive :: u8 ; 18usize] ,) , # [codec (index = 20)] Raw19 ([:: core :: primitive :: u8 ; 19usize] ,) , # [codec (index = 21)] Raw20 ([:: core :: primitive :: u8 ; 20usize] ,) , # [codec (index = 22)] Raw21 ([:: core :: primitive :: u8 ; 21usize] ,) , # [codec (index = 23)] Raw22 ([:: core :: primitive :: u8 ; 22usize] ,) , # [codec (index = 24)] Raw23 ([:: core :: primitive :: u8 ; 23usize] ,) , # [codec (index = 25)] Raw24 ([:: core :: primitive :: u8 ; 24usize] ,) , # [codec (index = 26)] Raw25 ([:: core :: primitive :: u8 ; 25usize] ,) , # [codec (index = 27)] Raw26 ([:: core :: primitive :: u8 ; 26usize] ,) , # [codec (index = 28)] Raw27 ([:: core :: primitive :: u8 ; 27usize] ,) , # [codec (index = 29)] Raw28 ([:: core :: primitive :: u8 ; 28usize] ,) , # [codec (index = 30)] Raw29 ([:: core :: primitive :: u8 ; 29usize] ,) , # [codec (index = 31)] Raw30 ([:: core :: primitive :: u8 ; 30usize] ,) , # [codec (index = 32)] Raw31 ([:: core :: primitive :: u8 ; 31usize] ,) , # [codec (index = 33)] Raw32 ([:: core :: primitive :: u8 ; 32usize] ,) , # [codec (index = 34)] Raw33 ([:: core :: primitive :: u8 ; 33usize] ,) , # [codec (index = 35)] Raw34 ([:: core :: primitive :: u8 ; 34usize] ,) , # [codec (index = 36)] Raw35 ([:: core :: primitive :: u8 ; 35usize] ,) , # [codec (index = 37)] Raw36 ([:: core :: primitive :: u8 ; 36usize] ,) , # [codec (index = 38)] Raw37 ([:: core :: primitive :: u8 ; 37usize] ,) , # [codec (index = 39)] Raw38 ([:: core :: primitive :: u8 ; 38usize] ,) , # [codec (index = 40)] Raw39 ([:: core :: primitive :: u8 ; 39usize] ,) , # [codec (index = 41)] Raw40 ([:: core :: primitive :: u8 ; 40usize] ,) , # [codec (index = 42)] Raw41 ([:: core :: primitive :: u8 ; 41usize] ,) , # [codec (index = 43)] Raw42 ([:: core :: primitive :: u8 ; 42usize] ,) , # [codec (index = 44)] Raw43 ([:: core :: primitive :: u8 ; 43usize] ,) , # [codec (index = 45)] Raw44 ([:: core :: primitive :: u8 ; 44usize] ,) , # [codec (index = 46)] Raw45 ([:: core :: primitive :: u8 ; 45usize] ,) , # [codec (index = 47)] Raw46 ([:: core :: primitive :: u8 ; 46usize] ,) , # [codec (index = 48)] Raw47 ([:: core :: primitive :: u8 ; 47usize] ,) , # [codec (index = 49)] Raw48 ([:: core :: primitive :: u8 ; 48usize] ,) , # [codec (index = 50)] Raw49 ([:: core :: primitive :: u8 ; 49usize] ,) , # [codec (index = 51)] Raw50 ([:: core :: primitive :: u8 ; 50usize] ,) , # [codec (index = 52)] Raw51 ([:: core :: primitive :: u8 ; 51usize] ,) , # [codec (index = 53)] Raw52 ([:: core :: primitive :: u8 ; 52usize] ,) , # [codec (index = 54)] Raw53 ([:: core :: primitive :: u8 ; 53usize] ,) , # [codec (index = 55)] Raw54 ([:: core :: primitive :: u8 ; 54usize] ,) , # [codec (index = 56)] Raw55 ([:: core :: primitive :: u8 ; 55usize] ,) , # [codec (index = 57)] Raw56 ([:: core :: primitive :: u8 ; 56usize] ,) , # [codec (index = 58)] Raw57 ([:: core :: primitive :: u8 ; 57usize] ,) , # [codec (index = 59)] Raw58 ([:: core :: primitive :: u8 ; 58usize] ,) , # [codec (index = 60)] Raw59 ([:: core :: primitive :: u8 ; 59usize] ,) , # [codec (index = 61)] Raw60 ([:: core :: primitive :: u8 ; 60usize] ,) , # [codec (index = 62)] Raw61 ([:: core :: primitive :: u8 ; 61usize] ,) , # [codec (index = 63)] Raw62 ([:: core :: primitive :: u8 ; 62usize] ,) , # [codec (index = 64)] Raw63 ([:: core :: primitive :: u8 ; 63usize] ,) , # [codec (index = 65)] Raw64 ([:: core :: primitive :: u8 ; 64usize] ,) , # [codec (index = 66)] BlakeTwo256 ([:: core :: primitive :: u8 ; 32usize] ,) , # [codec (index = 67)] Sha256 ([:: core :: primitive :: u8 ; 32usize] ,) , # [codec (index = 68)] Keccak256 ([:: core :: primitive :: u8 ; 32usize] ,) , # [codec (index = 69)] ShaThree256 ([:: core :: primitive :: u8 ; 32usize] ,) , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct IdentityInfo { pub additional : runtime_types :: bounded_collections :: bounded_vec :: BoundedVec < (runtime_types :: pallet_registry :: types :: Data , runtime_types :: pallet_registry :: types :: Data ,) > , pub display : runtime_types :: pallet_registry :: types :: Data , pub legal : runtime_types :: pallet_registry :: types :: Data , pub web : runtime_types :: pallet_registry :: types :: Data , pub riot : runtime_types :: pallet_registry :: types :: Data , pub email : runtime_types :: pallet_registry :: types :: Data , pub pgp_fingerprint : :: core :: option :: Option < [:: core :: primitive :: u8 ; 20usize] > , pub image : runtime_types :: pallet_registry :: types :: Data , pub twitter : runtime_types :: pallet_registry :: types :: Data , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct Registration < _0 > { pub deposit : _0 , pub info : runtime_types :: pallet_registry :: types :: IdentityInfo , } } } pub mod pallet_safe_mode { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Contains a variant per dispatchable extrinsic that this pallet has."] pub enum Call { # [codec (index = 0)] # [doc = "Enter safe-mode permissionlessly for [`Config::EnterDuration`] blocks."] # [doc = ""] # [doc = "Reserves [`Config::EnterDepositAmount`] from the caller's account."] # [doc = "Emits an [`Event::Entered`] event on success."] # [doc = "Errors with [`Error::Entered`] if the safe-mode is already entered."] # [doc = "Errors with [`Error::NotConfigured`] if the deposit amount is `None`."] enter , # [codec (index = 1)] # [doc = "Enter safe-mode by force for a per-origin configured number of blocks."] # [doc = ""] # [doc = "Emits an [`Event::Entered`] event on success."] # [doc = "Errors with [`Error::Entered`] if the safe-mode is already entered."] # [doc = ""] # [doc = "Can only be called by the [`Config::ForceEnterOrigin`] origin."] force_enter , # [codec (index = 2)] # [doc = "Extend the safe-mode permissionlessly for [`Config::ExtendDuration`] blocks."] # [doc = ""] # [doc = "This accumulates on top of the current remaining duration."] # [doc = "Reserves [`Config::ExtendDepositAmount`] from the caller's account."] # [doc = "Emits an [`Event::Extended`] event on success."] # [doc = "Errors with [`Error::Exited`] if the safe-mode is entered."] # [doc = "Errors with [`Error::NotConfigured`] if the deposit amount is `None`."] # [doc = ""] # [doc = "This may be called by any signed origin with [`Config::ExtendDepositAmount`] free"] # [doc = "currency to reserve. This call can be disabled for all origins by configuring"] # [doc = "[`Config::ExtendDepositAmount`] to `None`."] extend , # [codec (index = 3)] # [doc = "Extend the safe-mode by force for a per-origin configured number of blocks."] # [doc = ""] # [doc = "Emits an [`Event::Extended`] event on success."] # [doc = "Errors with [`Error::Exited`] if the safe-mode is inactive."] # [doc = ""] # [doc = "Can only be called by the [`Config::ForceExtendOrigin`] origin."] force_extend , # [codec (index = 4)] # [doc = "Exit safe-mode by force."] # [doc = ""] # [doc = "Emits an [`Event::Exited`] with [`ExitReason::Force`] event on success."] # [doc = "Errors with [`Error::Exited`] if the safe-mode is inactive."] # [doc = ""] # [doc = "Note: `safe-mode` will be automatically deactivated by [`Pallet::on_initialize`] hook"] # [doc = "after the block height is greater than the [`EnteredUntil`] storage item."] # [doc = "Emits an [`Event::Exited`] with [`ExitReason::Timeout`] event when deactivated in the"] # [doc = "hook."] force_exit , # [codec (index = 5)] # [doc = "Slash a deposit for an account that entered or extended safe-mode at a given"] # [doc = "historical block."] # [doc = ""] # [doc = "This can only be called while safe-mode is entered."] # [doc = ""] # [doc = "Emits a [`Event::DepositSlashed`] event on success."] # [doc = "Errors with [`Error::Entered`] if safe-mode is entered."] # [doc = ""] # [doc = "Can only be called by the [`Config::ForceDepositOrigin`] origin."] force_slash_deposit { account : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , block : :: core :: primitive :: u32 , } , # [codec (index = 6)] # [doc = "Permissionlessly release a deposit for an account that entered safe-mode at a"] # [doc = "given historical block."] # [doc = ""] # [doc = "The call can be completely disabled by setting [`Config::ReleaseDelay`] to `None`."] # [doc = "This cannot be called while safe-mode is entered and not until"] # [doc = "[`Config::ReleaseDelay`] blocks have passed since safe-mode was entered."] # [doc = ""] # [doc = "Emits a [`Event::DepositReleased`] event on success."] # [doc = "Errors with [`Error::Entered`] if the safe-mode is entered."] # [doc = "Errors with [`Error::CannotReleaseYet`] if [`Config::ReleaseDelay`] block have not"] # [doc = "passed since safe-mode was entered. Errors with [`Error::NoDeposit`] if the payee has no"] # [doc = "reserved currency at the block specified."] release_deposit { account : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , block : :: core :: primitive :: u32 , } , # [codec (index = 7)] # [doc = "Force to release a deposit for an account that entered safe-mode at a given"] # [doc = "historical block."] # [doc = ""] # [doc = "This can be called while safe-mode is still entered."] # [doc = ""] # [doc = "Emits a [`Event::DepositReleased`] event on success."] # [doc = "Errors with [`Error::Entered`] if safe-mode is entered."] # [doc = "Errors with [`Error::NoDeposit`] if the payee has no reserved currency at the"] # [doc = "specified block."] # [doc = ""] # [doc = "Can only be called by the [`Config::ForceDepositOrigin`] origin."] force_release_deposit { account : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , block : :: core :: primitive :: u32 , } , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The `Error` enum of this pallet."] pub enum Error { # [codec (index = 0)] # [doc = "The safe-mode is (already or still) entered."] Entered , # [codec (index = 1)] # [doc = "The safe-mode is (already or still) exited."] Exited , # [codec (index = 2)] # [doc = "This functionality of the pallet is disabled by the configuration."] NotConfigured , # [codec (index = 3)] # [doc = "There is no balance reserved."] NoDeposit , # [codec (index = 4)] # [doc = "The account already has a deposit reserved and can therefore not enter or extend again."] AlreadyDeposited , # [codec (index = 5)] # [doc = "This deposit cannot be released yet."] CannotReleaseYet , # [codec (index = 6)] # [doc = "An error from the underlying `Currency`."] CurrencyError , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The `Event` enum of this pallet"] pub enum Event { # [codec (index = 0)] # [doc = "The safe-mode was entered until inclusively this block."] Entered { until : :: core :: primitive :: u32 , } , # [codec (index = 1)] # [doc = "The safe-mode was extended until inclusively this block."] Extended { until : :: core :: primitive :: u32 , } , # [codec (index = 2)] # [doc = "Exited the safe-mode for a specific reason."] Exited { reason : runtime_types :: pallet_safe_mode :: pallet :: ExitReason , } , # [codec (index = 3)] # [doc = "An account reserved funds for either entering or extending the safe-mode."] DepositPlaced { account : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , amount : :: core :: primitive :: u64 , } , # [codec (index = 4)] # [doc = "An account had a reserve released that was reserved."] DepositReleased { account : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , amount : :: core :: primitive :: u64 , } , # [codec (index = 5)] # [doc = "An account had reserve slashed that was reserved."] DepositSlashed { account : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , amount : :: core :: primitive :: u64 , } , # [codec (index = 6)] # [doc = "Could not hold funds for entering or extending the safe-mode."] # [doc = ""] # [doc = "This error comes from the underlying `Currency`."] CannotDeposit , # [codec (index = 7)] # [doc = "Could not release funds for entering or extending the safe-mode."] # [doc = ""] # [doc = "This error comes from the underlying `Currency`."] CannotRelease , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum ExitReason { # [codec (index = 0)] Timeout , # [codec (index = 1)] Force , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum HoldReason { # [codec (index = 0)] EnterOrExtend , } } } pub mod pallet_scheduler { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Contains a variant per dispatchable extrinsic that this pallet has."] pub enum Call { # [codec (index = 0)] # [doc = "Anonymously schedule a task."] schedule { when : :: core :: primitive :: u32 , maybe_periodic : :: core :: option :: Option < (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) > , priority : :: core :: primitive :: u8 , call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < runtime_types :: node_subtensor_runtime :: RuntimeCall > , } , # [codec (index = 1)] # [doc = "Cancel an anonymously scheduled task."] cancel { when : :: core :: primitive :: u32 , index : :: core :: primitive :: u32 , } , # [codec (index = 2)] # [doc = "Schedule a named task."] schedule_named { id : [:: core :: primitive :: u8 ; 32usize] , when : :: core :: primitive :: u32 , maybe_periodic : :: core :: option :: Option < (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) > , priority : :: core :: primitive :: u8 , call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < runtime_types :: node_subtensor_runtime :: RuntimeCall > , } , # [codec (index = 3)] # [doc = "Cancel a named scheduled task."] cancel_named { id : [:: core :: primitive :: u8 ; 32usize] , } , # [codec (index = 4)] # [doc = "Anonymously schedule a task after a delay."] schedule_after { after : :: core :: primitive :: u32 , maybe_periodic : :: core :: option :: Option < (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) > , priority : :: core :: primitive :: u8 , call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < runtime_types :: node_subtensor_runtime :: RuntimeCall > , } , # [codec (index = 5)] # [doc = "Schedule a named task after a delay."] schedule_named_after { id : [:: core :: primitive :: u8 ; 32usize] , after : :: core :: primitive :: u32 , maybe_periodic : :: core :: option :: Option < (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) > , priority : :: core :: primitive :: u8 , call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < runtime_types :: node_subtensor_runtime :: RuntimeCall > , } , # [codec (index = 6)] # [doc = "Set a retry configuration for a task so that, in case its scheduled run fails, it will"] # [doc = "be retried after `period` blocks, for a total amount of `retries` retries or until it"] # [doc = "succeeds."] # [doc = ""] # [doc = "Tasks which need to be scheduled for a retry are still subject to weight metering and"] # [doc = "agenda space, same as a regular task. If a periodic task fails, it will be scheduled"] # [doc = "normally while the task is retrying."] # [doc = ""] # [doc = "Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic"] # [doc = "clones of the original task. Their retry configuration will be derived from the"] # [doc = "original task's configuration, but will have a lower value for `remaining` than the"] # [doc = "original `total_retries`."] set_retry { task : (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) , retries : :: core :: primitive :: u8 , period : :: core :: primitive :: u32 , } , # [codec (index = 7)] # [doc = "Set a retry configuration for a named task so that, in case its scheduled run fails, it"] # [doc = "will be retried after `period` blocks, for a total amount of `retries` retries or until"] # [doc = "it succeeds."] # [doc = ""] # [doc = "Tasks which need to be scheduled for a retry are still subject to weight metering and"] # [doc = "agenda space, same as a regular task. If a periodic task fails, it will be scheduled"] # [doc = "normally while the task is retrying."] # [doc = ""] # [doc = "Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic"] # [doc = "clones of the original task. Their retry configuration will be derived from the"] # [doc = "original task's configuration, but will have a lower value for `remaining` than the"] # [doc = "original `total_retries`."] set_retry_named { id : [:: core :: primitive :: u8 ; 32usize] , retries : :: core :: primitive :: u8 , period : :: core :: primitive :: u32 , } , # [codec (index = 8)] # [doc = "Removes the retry configuration of a task."] cancel_retry { task : (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) , } , # [codec (index = 9)] # [doc = "Cancel the retry configuration of a named task."] cancel_retry_named { id : [:: core :: primitive :: u8 ; 32usize] , } , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The `Error` enum of this pallet."] pub enum Error { # [codec (index = 0)] # [doc = "Failed to schedule a call"] FailedToSchedule , # [codec (index = 1)] # [doc = "Cannot find the scheduled call."] NotFound , # [codec (index = 2)] # [doc = "Given target block number is in the past."] TargetBlockNumberInPast , # [codec (index = 3)] # [doc = "Reschedule failed because it does not change scheduled time."] RescheduleNoChange , # [codec (index = 4)] # [doc = "Attempt to use a non-named function on a named task."] Named , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Events type."] pub enum Event { # [codec (index = 0)] # [doc = "Scheduled some task."] Scheduled { when : :: core :: primitive :: u32 , index : :: core :: primitive :: u32 , } , # [codec (index = 1)] # [doc = "Canceled some task."] Canceled { when : :: core :: primitive :: u32 , index : :: core :: primitive :: u32 , } , # [codec (index = 2)] # [doc = "Dispatched some task."] Dispatched { task : (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) , id : :: core :: option :: Option < [:: core :: primitive :: u8 ; 32usize] > , result : :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > , } , # [codec (index = 3)] # [doc = "Set a retry configuration for some task."] RetrySet { task : (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) , id : :: core :: option :: Option < [:: core :: primitive :: u8 ; 32usize] > , period : :: core :: primitive :: u32 , retries : :: core :: primitive :: u8 , } , # [codec (index = 4)] # [doc = "Cancel a retry configuration for some task."] RetryCancelled { task : (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) , id : :: core :: option :: Option < [:: core :: primitive :: u8 ; 32usize] > , } , # [codec (index = 5)] # [doc = "The call for the provided hash was not found so the task has been aborted."] CallUnavailable { task : (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) , id : :: core :: option :: Option < [:: core :: primitive :: u8 ; 32usize] > , } , # [codec (index = 6)] # [doc = "The given task was unable to be renewed since the agenda is full at that block."] PeriodicFailed { task : (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) , id : :: core :: option :: Option < [:: core :: primitive :: u8 ; 32usize] > , } , # [codec (index = 7)] # [doc = "The given task was unable to be retried since the agenda is full at that block or there"] # [doc = "was not enough weight to reschedule it."] RetryFailed { task : (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) , id : :: core :: option :: Option < [:: core :: primitive :: u8 ; 32usize] > , } , # [codec (index = 8)] # [doc = "The given task can never be executed since it is overweight."] PermanentlyOverweight { task : (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) , id : :: core :: option :: Option < [:: core :: primitive :: u8 ; 32usize] > , } , } } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct RetryConfig < _0 > { pub total_retries : :: core :: primitive :: u8 , pub remaining : :: core :: primitive :: u8 , pub period : _0 , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct Scheduled < _0 , _1 , _2 , _3 , _4 > { pub maybe_id : :: core :: option :: Option < _0 > , pub priority : :: core :: primitive :: u8 , pub call : _1 , pub maybe_periodic : :: core :: option :: Option < (_2 , _2 ,) > , pub origin : _3 , # [codec (skip)] pub __ignore : :: core :: marker :: PhantomData < _4 > } } pub mod pallet_subtensor { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct AxonInfo { pub block : :: core :: primitive :: u64 , pub version : :: core :: primitive :: u32 , pub ip : :: core :: primitive :: u128 , pub port : :: core :: primitive :: u16 , pub ip_type : :: core :: primitive :: u8 , pub protocol : :: core :: primitive :: u8 , pub placeholder1 : :: core :: primitive :: u8 , pub placeholder2 : :: core :: primitive :: u8 , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Dispatchable functions allow users to interact with the pallet and invoke state changes."] # [doc = "These functions materialize as \"extrinsics\", which are often compared to transactions."] # [doc = "Dispatchable functions must be annotated with a weight and must return a DispatchResult."] pub enum Call { # [codec (index = 0)] # [doc = "--- Sets the caller weights for the incentive mechanism. The call can be"] # [doc = "made from the hotkey account so is potentially insecure, however, the damage"] # [doc = "of changing weights is minimal if caught early. This function includes all the"] # [doc = "checks that the passed weights meet the requirements. Stored as u16s they represent"] # [doc = "rational values in the range [0,1] which sum to 1 and can be interpreted as"] # [doc = "probabilities. The specific weights determine how inflation propagates outward"] # [doc = "from this peer."] # [doc = ""] # [doc = "Note: The 16 bit integers weights should represent 1.0 as the max u16."] # [doc = "However, the function normalizes all integers to u16_max anyway. This means that if the sum of all"] # [doc = "elements is larger or smaller than the amount of elements * u16_max, all elements"] # [doc = "will be corrected for this deviation."] # [doc = ""] # [doc = "# Args:"] # [doc = "* `origin`: (<T as frame_system::Config>Origin):"] # [doc = "    - The caller, a hotkey who wishes to set their weights."] # [doc = ""] # [doc = "* `netuid` (u16):"] # [doc = "\t- The network uid we are setting these weights on."] # [doc = ""] # [doc = "* `dests` (Vec<u16>):"] # [doc = "\t- The edge endpoint for the weight, i.e. j for w_ij."] # [doc = ""] # [doc = "* 'weights' (Vec<u16>):"] # [doc = "\t- The u16 integer encoded weights. Interpreted as rational"] # [doc = "\t\tvalues in the range [0,1]. They must sum to in32::MAX."] # [doc = ""] # [doc = "* 'version_key' ( u64 ):"] # [doc = "\t- The network version key to check if the validator is up to date."] # [doc = ""] # [doc = "# Event:"] # [doc = "* WeightsSet;"] # [doc = "\t- On successfully setting the weights on chain."] # [doc = ""] # [doc = "# Raises:"] # [doc = "* 'SubNetworkDoesNotExist':"] # [doc = "\t- Attempting to set weights on a non-existent network."] # [doc = ""] # [doc = "* 'NotRegistered':"] # [doc = "\t- Attempting to set weights from a non registered account."] # [doc = ""] # [doc = "* 'WeightVecNotEqualSize':"] # [doc = "\t- Attempting to set weights with uids not of same length."] # [doc = ""] # [doc = "* 'DuplicateUids':"] # [doc = "\t- Attempting to set weights with duplicate uids."] # [doc = ""] # [doc = "    * 'UidsLengthExceedUidsInSubNet':"] # [doc = "\t- Attempting to set weights above the max allowed uids."] # [doc = ""] # [doc = "* 'UidVecContainInvalidOne':"] # [doc = "\t- Attempting to set weights with invalid uids."] # [doc = ""] # [doc = "* 'WeightVecLengthIsLow':"] # [doc = "\t- Attempting to set weights with fewer weights than min."] # [doc = ""] # [doc = "* 'MaxWeightExceeded':"] # [doc = "\t- Attempting to set weights with max value exceeding limit."] set_weights { netuid : :: core :: primitive :: u16 , dests : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u16 > , weights : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u16 > , version_key : :: core :: primitive :: u64 , } , # [codec (index = 96)] # [doc = "---- Used to commit a hash of your weight values to later be revealed."] # [doc = ""] # [doc = "# Args:"] # [doc = "* `origin`: (`<T as frame_system::Config>::RuntimeOrigin`):"] # [doc = "  - The signature of the committing hotkey."] # [doc = ""] # [doc = "* `netuid` (`u16`):"] # [doc = "  - The u16 network identifier."] # [doc = ""] # [doc = "* `commit_hash` (`H256`):"] # [doc = "  - The hash representing the committed weights."] # [doc = ""] # [doc = "# Raises:"] # [doc = "* `WeightsCommitNotAllowed`:"] # [doc = "  - Attempting to commit when it is not allowed."] # [doc = ""] commit_weights { netuid : :: core :: primitive :: u16 , commit_hash : :: subxt :: ext :: subxt_core :: utils :: H256 , } , # [codec (index = 97)] # [doc = "---- Used to reveal the weights for a previously committed hash."] # [doc = ""] # [doc = "# Args:"] # [doc = "* `origin`: (`<T as frame_system::Config>::RuntimeOrigin`):"] # [doc = "  - The signature of the revealing hotkey."] # [doc = ""] # [doc = "* `netuid` (`u16`):"] # [doc = "  - The u16 network identifier."] # [doc = ""] # [doc = "* `uids` (`Vec<u16>`):"] # [doc = "  - The uids for the weights being revealed."] # [doc = ""] # [doc = "* `values` (`Vec<u16>`):"] # [doc = "  - The values of the weights being revealed."] # [doc = ""] # [doc = "* `salt` (`Vec<u8>`):"] # [doc = "  - The random salt to protect from brute-force guessing attack in case of small weight changes bit-wise."] # [doc = ""] # [doc = "* `version_key` (`u64`):"] # [doc = "  - The network version key."] # [doc = ""] # [doc = "# Raises:"] # [doc = "* `NoWeightsCommitFound`:"] # [doc = "  - Attempting to reveal weights without an existing commit."] # [doc = ""] # [doc = "* `InvalidRevealCommitHashNotMatchTempo`:"] # [doc = "  - Attempting to reveal weights outside the valid tempo."] # [doc = ""] # [doc = "* `InvalidRevealCommitHashNotMatch`:"] # [doc = "  - The revealed hash does not match the committed hash."] # [doc = ""] reveal_weights { netuid : :: core :: primitive :: u16 , uids : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u16 > , values : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u16 > , salt : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u16 > , version_key : :: core :: primitive :: u64 , } , # [codec (index = 8)] # [doc = "# Args:"] # [doc = "* `origin`: (<T as frame_system::Config>Origin):"] # [doc = "\t- The caller, a hotkey who wishes to set their weights."] # [doc = ""] # [doc = "* `netuid` (u16):"] # [doc = "\t- The network uid we are setting these weights on."] # [doc = ""] # [doc = "* `hotkey` (T::AccountId):"] # [doc = "\t- The hotkey associated with the operation and the calling coldkey."] # [doc = ""] # [doc = "* `dests` (Vec<u16>):"] # [doc = "\t- The edge endpoint for the weight, i.e. j for w_ij."] # [doc = ""] # [doc = "* 'weights' (Vec<u16>):"] # [doc = "\t- The u16 integer encoded weights. Interpreted as rational"] # [doc = "\t\tvalues in the range [0,1]. They must sum to in32::MAX."] # [doc = ""] # [doc = "* 'version_key' ( u64 ):"] # [doc = "\t- The network version key to check if the validator is up to date."] # [doc = ""] # [doc = "# Event:"] # [doc = ""] # [doc = "* WeightsSet;"] # [doc = "\t- On successfully setting the weights on chain."] # [doc = ""] # [doc = "# Raises:"] # [doc = ""] # [doc = "* NonAssociatedColdKey;"] # [doc = "\t- Attempting to set weights on a non-associated cold key."] # [doc = ""] # [doc = "* 'SubNetworkDoesNotExist':"] # [doc = "\t- Attempting to set weights on a non-existent network."] # [doc = ""] # [doc = "* 'NotRootSubnet':"] # [doc = "\t- Attempting to set weights on a subnet that is not the root network."] # [doc = ""] # [doc = "* 'WeightVecNotEqualSize':"] # [doc = "\t- Attempting to set weights with uids not of same length."] # [doc = ""] # [doc = "* 'UidVecContainInvalidOne':"] # [doc = "\t- Attempting to set weights with invalid uids."] # [doc = ""] # [doc = "* 'NotRegistered':"] # [doc = "\t- Attempting to set weights from a non registered account."] # [doc = ""] # [doc = "* 'WeightVecLengthIsLow':"] # [doc = "\t- Attempting to set weights with fewer weights than min."] # [doc = ""] # [doc = " * 'IncorrectWeightVersionKey':"] # [doc = "     - Attempting to set weights with the incorrect network version key."] # [doc = ""] # [doc = " * 'SettingWeightsTooFast':"] # [doc = "     - Attempting to set weights too fast."] # [doc = ""] # [doc = "* 'WeightVecLengthIsLow':"] # [doc = "\t- Attempting to set weights with fewer weights than min."] # [doc = ""] # [doc = "* 'MaxWeightExceeded':"] # [doc = "\t- Attempting to set weights with max value exceeding limit."] # [doc = ""] set_root_weights { netuid : :: core :: primitive :: u16 , hotkey : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , dests : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u16 > , weights : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u16 > , version_key : :: core :: primitive :: u64 , } , # [codec (index = 1)] # [doc = "--- Sets the key as a delegate."] # [doc = ""] # [doc = "# Args:"] # [doc = "* 'origin': (<T as frame_system::Config>Origin):"] # [doc = "\t- The signature of the caller's coldkey."] # [doc = ""] # [doc = "* 'hotkey' (T::AccountId):"] # [doc = "\t- The hotkey we are delegating (must be owned by the coldkey.)"] # [doc = ""] # [doc = "* 'take' (u64):"] # [doc = "\t- The stake proportion that this hotkey takes from delegations."] # [doc = ""] # [doc = "# Event:"] # [doc = "* DelegateAdded;"] # [doc = "\t- On successfully setting a hotkey as a delegate."] # [doc = ""] # [doc = "# Raises:"] # [doc = "* 'NotRegistered':"] # [doc = "\t- The hotkey we are delegating is not registered on the network."] # [doc = ""] # [doc = "* 'NonAssociatedColdKey':"] # [doc = "\t- The hotkey we are delegating is not owned by the calling coldket."] # [doc = ""] become_delegate { hotkey : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , } , # [codec (index = 65)] # [doc = "--- Allows delegates to decrease its take value."] # [doc = ""] # [doc = "# Args:"] # [doc = "* 'origin': (<T as frame_system::Config>::Origin):"] # [doc = "\t- The signature of the caller's coldkey."] # [doc = ""] # [doc = "* 'hotkey' (T::AccountId):"] # [doc = "\t- The hotkey we are delegating (must be owned by the coldkey.)"] # [doc = ""] # [doc = "* 'netuid' (u16):"] # [doc = "\t- Subnet ID to decrease take for"] # [doc = ""] # [doc = "* 'take' (u16):"] # [doc = "\t- The new stake proportion that this hotkey takes from delegations."] # [doc = "       The new value can be between 0 and 11_796 and should be strictly"] # [doc = "       lower than the previous value. It T is the new value (rational number),"] # [doc = "       the the parameter is calculated as [65535 * T]. For example, 1% would be"] # [doc = "       [0.01 * 65535] = [655.35] = 655"] # [doc = ""] # [doc = "# Event:"] # [doc = "* TakeDecreased;"] # [doc = "\t- On successfully setting a decreased take for this hotkey."] # [doc = ""] # [doc = "# Raises:"] # [doc = "* 'NotRegistered':"] # [doc = "\t- The hotkey we are delegating is not registered on the network."] # [doc = ""] # [doc = "* 'NonAssociatedColdKey':"] # [doc = "\t- The hotkey we are delegating is not owned by the calling coldkey."] # [doc = ""] # [doc = "* 'DelegateTakeTooLow':"] # [doc = "\t- The delegate is setting a take which is not lower than the previous."] # [doc = ""] decrease_take { hotkey : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , take : :: core :: primitive :: u16 , } , # [codec (index = 66)] # [doc = "--- Allows delegates to increase its take value. This call is rate-limited."] # [doc = ""] # [doc = "# Args:"] # [doc = "* 'origin': (<T as frame_system::Config>::Origin):"] # [doc = "\t- The signature of the caller's coldkey."] # [doc = ""] # [doc = "* 'hotkey' (T::AccountId):"] # [doc = "\t- The hotkey we are delegating (must be owned by the coldkey.)"] # [doc = ""] # [doc = "* 'take' (u16):"] # [doc = "\t- The new stake proportion that this hotkey takes from delegations."] # [doc = "       The new value can be between 0 and 11_796 and should be strictly"] # [doc = "       greater than the previous value. T is the new value (rational number),"] # [doc = "       the the parameter is calculated as [65535 * T]. For example, 1% would be"] # [doc = "       [0.01 * 65535] = [655.35] = 655"] # [doc = ""] # [doc = "# Event:"] # [doc = "* TakeIncreased;"] # [doc = "\t- On successfully setting a increased take for this hotkey."] # [doc = ""] # [doc = "# Raises:"] # [doc = "* 'NotRegistered':"] # [doc = "\t- The hotkey we are delegating is not registered on the network."] # [doc = ""] # [doc = "* 'NonAssociatedColdKey':"] # [doc = "\t- The hotkey we are delegating is not owned by the calling coldkey."] # [doc = ""] # [doc = "* 'DelegateTakeTooHigh':"] # [doc = "\t- The delegate is setting a take which is not greater than the previous."] # [doc = ""] increase_take { hotkey : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , take : :: core :: primitive :: u16 , } , # [codec (index = 2)] # [doc = "--- Adds stake to a hotkey. The call is made from the"] # [doc = "coldkey account linked in the hotkey."] # [doc = "Only the associated coldkey is allowed to make staking and"] # [doc = "unstaking requests. This protects the neuron against"] # [doc = "attacks on its hotkey running in production code."] # [doc = ""] # [doc = "# Args:"] # [doc = " * 'origin': (<T as frame_system::Config>Origin):"] # [doc = "\t- The signature of the caller's coldkey."] # [doc = ""] # [doc = " * 'hotkey' (T::AccountId):"] # [doc = "\t- The associated hotkey account."] # [doc = ""] # [doc = " * 'amount_staked' (u64):"] # [doc = "\t- The amount of stake to be added to the hotkey staking account."] # [doc = ""] # [doc = "# Event:"] # [doc = " * StakeAdded;"] # [doc = "\t- On the successfully adding stake to a global account."] # [doc = ""] # [doc = "# Raises:"] # [doc = " * 'NotEnoughBalanceToStake':"] # [doc = "\t- Not enough balance on the coldkey to add onto the global account."] # [doc = ""] # [doc = " * 'NonAssociatedColdKey':"] # [doc = "\t- The calling coldkey is not associated with this hotkey."] # [doc = ""] # [doc = " * 'BalanceWithdrawalError':"] # [doc = " \t- Errors stemming from transaction pallet."] # [doc = ""] add_stake { hotkey : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , amount_staked : :: core :: primitive :: u64 , } , # [codec (index = 3)] # [doc = "Remove stake from the staking account. The call must be made"] # [doc = "from the coldkey account attached to the neuron metadata. Only this key"] # [doc = "has permission to make staking and unstaking requests."] # [doc = ""] # [doc = "# Args:"] # [doc = "* 'origin': (<T as frame_system::Config>Origin):"] # [doc = "\t- The signature of the caller's coldkey."] # [doc = ""] # [doc = "* 'hotkey' (T::AccountId):"] # [doc = "\t- The associated hotkey account."] # [doc = ""] # [doc = "* 'amount_unstaked' (u64):"] # [doc = "\t- The amount of stake to be added to the hotkey staking account."] # [doc = ""] # [doc = "# Event:"] # [doc = "* StakeRemoved;"] # [doc = "\t- On the successfully removing stake from the hotkey account."] # [doc = ""] # [doc = "# Raises:"] # [doc = "* 'NotRegistered':"] # [doc = "\t- Thrown if the account we are attempting to unstake from is non existent."] # [doc = ""] # [doc = "* 'NonAssociatedColdKey':"] # [doc = "\t- Thrown if the coldkey does not own the hotkey we are unstaking from."] # [doc = ""] # [doc = "* 'NotEnoughStakeToWithdraw':"] # [doc = "\t- Thrown if there is not enough stake on the hotkey to withdwraw this amount."] # [doc = ""] remove_stake { hotkey : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , amount_unstaked : :: core :: primitive :: u64 , } , # [codec (index = 4)] # [doc = "Serves or updates axon /promethteus information for the neuron associated with the caller. If the caller is"] # [doc = "already registered the metadata is updated. If the caller is not registered this call throws NotRegistered."] # [doc = ""] # [doc = "# Args:"] # [doc = "* 'origin': (<T as frame_system::Config>Origin):"] # [doc = "\t- The signature of the caller."] # [doc = ""] # [doc = "* 'netuid' (u16):"] # [doc = "\t- The u16 network identifier."] # [doc = ""] # [doc = "* 'version' (u64):"] # [doc = "\t- The bittensor version identifier."] # [doc = ""] # [doc = "* 'ip' (u64):"] # [doc = "\t- The endpoint ip information as a u128 encoded integer."] # [doc = ""] # [doc = "* 'port' (u16):"] # [doc = "\t- The endpoint port information as a u16 encoded integer."] # [doc = ""] # [doc = "* 'ip_type' (u8):"] # [doc = "\t- The endpoint ip version as a u8, 4 or 6."] # [doc = ""] # [doc = "* 'protocol' (u8):"] # [doc = "\t- UDP:1 or TCP:0"] # [doc = ""] # [doc = "* 'placeholder1' (u8):"] # [doc = "\t- Placeholder for further extra params."] # [doc = ""] # [doc = "* 'placeholder2' (u8):"] # [doc = "\t- Placeholder for further extra params."] # [doc = ""] # [doc = "# Event:"] # [doc = "* AxonServed;"] # [doc = "\t- On successfully serving the axon info."] # [doc = ""] # [doc = "# Raises:"] # [doc = "* 'SubNetworkDoesNotExist':"] # [doc = "\t- Attempting to set weights on a non-existent network."] # [doc = ""] # [doc = "* 'NotRegistered':"] # [doc = "\t- Attempting to set weights from a non registered account."] # [doc = ""] # [doc = "* 'InvalidIpType':"] # [doc = "\t- The ip type is not 4 or 6."] # [doc = ""] # [doc = "* 'InvalidIpAddress':"] # [doc = "\t- The numerically encoded ip address does not resolve to a proper ip."] # [doc = ""] # [doc = "* 'ServingRateLimitExceeded':"] # [doc = "\t- Attempting to set prometheus information withing the rate limit min."] # [doc = ""] serve_axon { netuid : :: core :: primitive :: u16 , version : :: core :: primitive :: u32 , ip : :: core :: primitive :: u128 , port : :: core :: primitive :: u16 , ip_type : :: core :: primitive :: u8 , protocol : :: core :: primitive :: u8 , placeholder1 : :: core :: primitive :: u8 , placeholder2 : :: core :: primitive :: u8 , } , # [codec (index = 5)] # [doc = "---- Set prometheus information for the neuron."] # [doc = "# Args:"] # [doc = "* 'origin': (<T as frame_system::Config>Origin):"] # [doc = "\t- The signature of the calling hotkey."] # [doc = ""] # [doc = "* 'netuid' (u16):"] # [doc = "\t- The u16 network identifier."] # [doc = ""] # [doc = "* 'version' (u16):"] # [doc = "\t-  The bittensor version identifier."] # [doc = ""] # [doc = "* 'ip' (u128):"] # [doc = "\t- The prometheus ip information as a u128 encoded integer."] # [doc = ""] # [doc = "* 'port' (u16):"] # [doc = "\t- The prometheus port information as a u16 encoded integer."] # [doc = ""] # [doc = "* 'ip_type' (u8):"] # [doc = "\t- The ip type v4 or v6."] # [doc = ""] serve_prometheus { netuid : :: core :: primitive :: u16 , version : :: core :: primitive :: u32 , ip : :: core :: primitive :: u128 , port : :: core :: primitive :: u16 , ip_type : :: core :: primitive :: u8 , } , # [codec (index = 6)] # [doc = "---- Registers a new neuron to the subnetwork."] # [doc = ""] # [doc = "# Args:"] # [doc = "* 'origin': (<T as frame_system::Config>Origin):"] # [doc = "\t- The signature of the calling hotkey."] # [doc = ""] # [doc = "* 'netuid' (u16):"] # [doc = "\t- The u16 network identifier."] # [doc = ""] # [doc = "* 'block_number' ( u64 ):"] # [doc = "\t- Block hash used to prove work done."] # [doc = ""] # [doc = "* 'nonce' ( u64 ):"] # [doc = "\t- Positive integer nonce used in POW."] # [doc = ""] # [doc = "* 'work' ( Vec<u8> ):"] # [doc = "\t- Vector encoded bytes representing work done."] # [doc = ""] # [doc = "* 'hotkey' ( T::AccountId ):"] # [doc = "\t- Hotkey to be registered to the network."] # [doc = ""] # [doc = "* 'coldkey' ( T::AccountId ):"] # [doc = "\t- Associated coldkey account."] # [doc = ""] # [doc = "# Event:"] # [doc = "* NeuronRegistered;"] # [doc = "\t- On successfully registering a uid to a neuron slot on a subnetwork."] # [doc = ""] # [doc = "# Raises:"] # [doc = "* 'SubNetworkDoesNotExist':"] # [doc = "\t- Attempting to register to a non existent network."] # [doc = ""] # [doc = "* 'TooManyRegistrationsThisBlock':"] # [doc = "\t- This registration exceeds the total allowed on this network this block."] # [doc = ""] # [doc = "* 'HotKeyAlreadyRegisteredInSubNet':"] # [doc = "\t- The hotkey is already registered on this network."] # [doc = ""] # [doc = "* 'InvalidWorkBlock':"] # [doc = "\t- The work has been performed on a stale, future, or non existent block."] # [doc = ""] # [doc = "* 'InvalidDifficulty':"] # [doc = "\t- The work does not match the difficulty."] # [doc = ""] # [doc = "* 'InvalidSeal':"] # [doc = "\t- The seal is incorrect."] # [doc = ""] register { netuid : :: core :: primitive :: u16 , block_number : :: core :: primitive :: u64 , nonce : :: core :: primitive :: u64 , work : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > , hotkey : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , coldkey : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , } , # [codec (index = 62)] # [doc = "Register the hotkey to root network"] root_register { hotkey : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , } , # [codec (index = 63)] # [doc = "Attempt to adjust the senate membership to include a hotkey"] adjust_senate { hotkey : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , } , # [codec (index = 7)] # [doc = "User register a new subnetwork via burning token"] burned_register { netuid : :: core :: primitive :: u16 , hotkey : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , } , # [codec (index = 70)] # [doc = "The extrinsic for user to change its hotkey"] swap_hotkey { hotkey : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , new_hotkey : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , } , # [codec (index = 71)] # [doc = "The extrinsic for user to change the coldkey associated with their account."] # [doc = ""] # [doc = "# Arguments"] # [doc = ""] # [doc = "* `origin` - The origin of the call, must be signed by the old coldkey."] # [doc = "* `old_coldkey` - The current coldkey associated with the account."] # [doc = "* `new_coldkey` - The new coldkey to be associated with the account."] # [doc = ""] # [doc = "# Returns"] # [doc = ""] # [doc = "Returns a `DispatchResultWithPostInfo` indicating success or failure of the operation."] # [doc = ""] # [doc = "# Weight"] # [doc = ""] # [doc = "Weight is calculated based on the number of database reads and writes."] swap_coldkey { old_coldkey : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , new_coldkey : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , } , # [codec (index = 75)] # [doc = "Sets the childkey take for a given hotkey."] # [doc = ""] # [doc = "This function allows a coldkey to set the childkey take for a given hotkey."] # [doc = "The childkey take determines the proportion of stake that the hotkey keeps for itself"] # [doc = "when distributing stake to its children."] # [doc = ""] # [doc = "# Arguments:"] # [doc = "* `origin` (<T as frame_system::Config>::RuntimeOrigin):"] # [doc = "    - The signature of the calling coldkey. Setting childkey take can only be done by the coldkey."] # [doc = ""] # [doc = "* `hotkey` (T::AccountId):"] # [doc = "    - The hotkey for which the childkey take will be set."] # [doc = ""] # [doc = "* `take` (u16):"] # [doc = "    - The new childkey take value. This is a percentage represented as a value between 0 and 10000,"] # [doc = "      where 10000 represents 100%."] # [doc = ""] # [doc = "# Events:"] # [doc = "* `ChildkeyTakeSet`:"] # [doc = "    - On successfully setting the childkey take for a hotkey."] # [doc = ""] # [doc = "# Errors:"] # [doc = "* `NonAssociatedColdKey`:"] # [doc = "    - The coldkey does not own the hotkey."] # [doc = "* `InvalidChildkeyTake`:"] # [doc = "    - The provided take value is invalid (greater than the maximum allowed take)."] # [doc = "* `TxChildkeyTakeRateLimitExceeded`:"] # [doc = "    - The rate limit for changing childkey take has been exceeded."] # [doc = ""] set_childkey_take { hotkey : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , netuid : :: core :: primitive :: u16 , take : :: core :: primitive :: u16 , } , # [codec (index = 69)] # [doc = "Sets the transaction rate limit for changing childkey take."] # [doc = ""] # [doc = "This function can only be called by the root origin."] # [doc = ""] # [doc = "# Arguments:"] # [doc = "* `origin` - The origin of the call, must be root."] # [doc = "* `tx_rate_limit` - The new rate limit in blocks."] # [doc = ""] # [doc = "# Errors:"] # [doc = "* `BadOrigin` - If the origin is not root."] # [doc = ""] sudo_set_tx_childkey_take_rate_limit { tx_rate_limit : :: core :: primitive :: u64 , } , # [codec (index = 76)] # [doc = "Sets the minimum allowed childkey take."] # [doc = ""] # [doc = "This function can only be called by the root origin."] # [doc = ""] # [doc = "# Arguments:"] # [doc = "* `origin` - The origin of the call, must be root."] # [doc = "* `take` - The new minimum childkey take value."] # [doc = ""] # [doc = "# Errors:"] # [doc = "* `BadOrigin` - If the origin is not root."] # [doc = ""] sudo_set_min_childkey_take { take : :: core :: primitive :: u16 , } , # [codec (index = 77)] # [doc = "Sets the maximum allowed childkey take."] # [doc = ""] # [doc = "This function can only be called by the root origin."] # [doc = ""] # [doc = "# Arguments:"] # [doc = "* `origin` - The origin of the call, must be root."] # [doc = "* `take` - The new maximum childkey take value."] # [doc = ""] # [doc = "# Errors:"] # [doc = "* `BadOrigin` - If the origin is not root."] # [doc = ""] sudo_set_max_childkey_take { take : :: core :: primitive :: u16 , } , # [codec (index = 51)] # [doc = "Authenticates a council proposal and dispatches a function call with `Root` origin."] # [doc = ""] # [doc = "The dispatch origin for this call must be a council majority."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- O(1)."] sudo { call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < runtime_types :: node_subtensor_runtime :: RuntimeCall > , } , # [codec (index = 52)] # [doc = "Authenticates a council proposal and dispatches a function call with `Root` origin."] # [doc = "This function does not check the weight of the call, and instead allows the"] # [doc = "user to specify the weight of the call."] # [doc = ""] # [doc = "The dispatch origin for this call must be a council majority."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- O(1)."] sudo_unchecked_weight { call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < runtime_types :: node_subtensor_runtime :: RuntimeCall > , weight : runtime_types :: sp_weights :: weight_v2 :: Weight , } , # [codec (index = 55)] # [doc = "User vote on a proposal"] vote { hotkey : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , proposal : :: subxt :: ext :: subxt_core :: utils :: H256 , # [codec (compact)] index : :: core :: primitive :: u32 , approve : :: core :: primitive :: bool , } , # [codec (index = 59)] # [doc = "User register a new subnetwork"] register_network , # [codec (index = 60)] # [doc = "Facility extrinsic for user to get taken from faucet"] # [doc = "It is only available when pow-faucet feature enabled"] # [doc = "Just deployed in testnet and devnet for testing purpose"] faucet { block_number : :: core :: primitive :: u64 , nonce : :: core :: primitive :: u64 , work : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 61)] # [doc = "Remove a user's subnetwork"] # [doc = "The caller must be the owner of the network"] dissolve_network { coldkey : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , netuid : :: core :: primitive :: u16 , } , # [codec (index = 67)] # [doc = "Set a single child for a given hotkey on a specified network."] # [doc = ""] # [doc = "This function allows a coldkey to set a single child for a given hotkey on a specified network."] # [doc = "The proportion of the hotkey's stake to be allocated to the child is also specified."] # [doc = ""] # [doc = "# Arguments:"] # [doc = "* `origin` (<T as frame_system::Config>::RuntimeOrigin):"] # [doc = "    - The signature of the calling coldkey. Setting a hotkey child can only be done by the coldkey."] # [doc = ""] # [doc = "* `hotkey` (T::AccountId):"] # [doc = "    - The hotkey which will be assigned the child."] # [doc = ""] # [doc = "* `child` (T::AccountId):"] # [doc = "    - The child which will be assigned to the hotkey."] # [doc = ""] # [doc = "* `netuid` (u16):"] # [doc = "    - The u16 network identifier where the childkey will exist."] # [doc = ""] # [doc = "* `proportion` (u64):"] # [doc = "    - Proportion of the hotkey's stake to be given to the child, the value must be u64 normalized."] # [doc = ""] # [doc = "# Events:"] # [doc = "* `ChildAddedSingular`:"] # [doc = "    - On successfully registering a child to a hotkey."] # [doc = ""] # [doc = "# Errors:"] # [doc = "* `SubNetworkDoesNotExist`:"] # [doc = "    - Attempting to register to a non-existent network."] # [doc = "* `RegistrationNotPermittedOnRootSubnet`:"] # [doc = "    - Attempting to register a child on the root network."] # [doc = "* `NonAssociatedColdKey`:"] # [doc = "    - The coldkey does not own the hotkey or the child is the same as the hotkey."] # [doc = "* `HotKeyAccountNotExists`:"] # [doc = "    - The hotkey account does not exist."] # [doc = ""] # [doc = "# Detailed Explanation of Checks:"] # [doc = "1. **Signature Verification**: Ensures that the caller has signed the transaction, verifying the coldkey."] # [doc = "2. **Root Network Check**: Ensures that the delegation is not on the root network, as child hotkeys are not valid on the root."] # [doc = "3. **Network Existence Check**: Ensures that the specified network exists."] # [doc = "4. **Ownership Verification**: Ensures that the coldkey owns the hotkey."] # [doc = "5. **Hotkey Account Existence Check**: Ensures that the hotkey account already exists."] # [doc = "6. **Child-Hotkey Distinction**: Ensures that the child is not the same as the hotkey."] # [doc = "7. **Old Children Cleanup**: Removes the hotkey from the parent list of its old children."] # [doc = "8. **New Children Assignment**: Assigns the new child to the hotkey and updates the parent list for the new child."] set_children { hotkey : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , netuid : :: core :: primitive :: u16 , children : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < (:: core :: primitive :: u64 , :: subxt :: ext :: subxt_core :: utils :: AccountId32 ,) > , } , # [codec (index = 73)] # [doc = "Schedules a coldkey swap operation to be executed at a future block."] # [doc = ""] # [doc = "This function allows a user to schedule the swapping of their coldkey to a new one"] # [doc = "at a specified future block. The swap is not executed immediately but is scheduled"] # [doc = "to occur at the specified block number."] # [doc = ""] # [doc = "# Arguments"] # [doc = ""] # [doc = "* `origin` - The origin of the call, which should be signed by the current coldkey owner."] # [doc = "* `new_coldkey` - The account ID of the new coldkey that will replace the current one."] # [doc = "* `when` - The block number at which the coldkey swap should be executed."] # [doc = ""] # [doc = "# Returns"] # [doc = ""] # [doc = "Returns a `DispatchResultWithPostInfo` indicating whether the scheduling was successful."] # [doc = ""] # [doc = "# Errors"] # [doc = ""] # [doc = "This function may return an error if:"] # [doc = "* The origin is not signed."] # [doc = "* The scheduling fails due to conflicts or system constraints."] # [doc = ""] # [doc = "# Notes"] # [doc = ""] # [doc = "- The actual swap is not performed by this function. It merely schedules the swap operation."] # [doc = "- The weight of this call is set to a fixed value and may need adjustment based on benchmarking."] # [doc = ""] # [doc = "# TODO"] # [doc = ""] # [doc = "- Implement proper weight calculation based on the complexity of the operation."] # [doc = "- Consider adding checks to prevent scheduling too far into the future."] # [doc = "TODO: Benchmark this call"] schedule_swap_coldkey { new_coldkey : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , } , # [codec (index = 74)] # [doc = "Schedule the dissolution of a network at a specified block number."] # [doc = ""] # [doc = "# Arguments"] # [doc = ""] # [doc = "* `origin` - The origin of the call, must be signed by the sender."] # [doc = "* `netuid` - The u16 network identifier to be dissolved."] # [doc = ""] # [doc = "# Returns"] # [doc = ""] # [doc = "Returns a `DispatchResultWithPostInfo` indicating success or failure of the operation."] # [doc = ""] # [doc = "# Weight"] # [doc = ""] # [doc = "Weight is calculated based on the number of database reads and writes."] schedule_dissolve_network { netuid : :: core :: primitive :: u16 , } , # [codec (index = 68)] # [doc = "---- Set prometheus information for the neuron."] # [doc = "# Args:"] # [doc = "* 'origin': (<T as frame_system::Config>Origin):"] # [doc = "\t- The signature of the calling hotkey."] # [doc = ""] # [doc = "* 'netuid' (u16):"] # [doc = "\t- The u16 network identifier."] # [doc = ""] # [doc = "* 'version' (u16):"] # [doc = "\t-  The bittensor version identifier."] # [doc = ""] # [doc = "* 'ip' (u128):"] # [doc = "\t- The prometheus ip information as a u128 encoded integer."] # [doc = ""] # [doc = "* 'port' (u16):"] # [doc = "\t- The prometheus port information as a u16 encoded integer."] # [doc = ""] # [doc = "* 'ip_type' (u8):"] # [doc = "\t- The ip type v4 or v6."] # [doc = ""] set_identity { name : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > , url : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > , image : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > , discord : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > , description : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > , additional : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 78)] # [doc = "---- Set the identity information for a subnet."] # [doc = "# Args:"] # [doc = "* `origin` - (<T as frame_system::Config>::Origin):"] # [doc = "    - The signature of the calling coldkey, which must be the owner of the subnet."] # [doc = ""] # [doc = "* `netuid` (u16):"] # [doc = "    - The unique network identifier of the subnet."] # [doc = ""] # [doc = "* `subnet_name` (Vec<u8>):"] # [doc = "    - The name of the subnet."] # [doc = ""] # [doc = "* `github_repo` (Vec<u8>):"] # [doc = "    - The GitHub repository associated with the subnet identity."] # [doc = ""] # [doc = "* `subnet_contact` (Vec<u8>):"] # [doc = "    - The contact information for the subnet."] set_subnet_identity { netuid : :: core :: primitive :: u16 , subnet_name : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > , github_repo : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > , subnet_contact : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 79)] # [doc = "User register a new subnetwork"] register_network_with_identity { identity : :: core :: option :: Option < runtime_types :: pallet_subtensor :: pallet :: SubnetIdentity > , } , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct ChainIdentity { pub name : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > , pub url : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > , pub image : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > , pub discord : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > , pub description : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > , pub additional : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The `Error` enum of this pallet."] pub enum Error { # [codec (index = 0)] # [doc = "The subnet does not exist."] SubNetworkDoesNotExist , # [codec (index = 1)] # [doc = "The root network does not exist."] RootNetworkDoesNotExist , # [codec (index = 2)] # [doc = "The user is trying to serve an axon which is not of type 4 (IPv4) or 6 (IPv6)."] InvalidIpType , # [codec (index = 3)] # [doc = "An invalid IP address is passed to the serve function."] InvalidIpAddress , # [codec (index = 4)] # [doc = "An invalid port is passed to the serve function."] InvalidPort , # [codec (index = 5)] # [doc = "The hotkey is not registered in subnet"] HotKeyNotRegisteredInSubNet , # [codec (index = 6)] # [doc = "The hotkey does not exists"] HotKeyAccountNotExists , # [codec (index = 7)] # [doc = "The hotkey is not registered in any subnet."] HotKeyNotRegisteredInNetwork , # [codec (index = 8)] # [doc = "Request to stake, unstake or subscribe is made by a coldkey that is not associated with the hotkey account."] NonAssociatedColdKey , # [codec (index = 9)] # [doc = "The hotkey is not a delegate and the signer is not the owner of the hotkey."] HotKeyNotDelegateAndSignerNotOwnHotKey , # [codec (index = 10)] # [doc = "Stake amount to withdraw is zero."] StakeToWithdrawIsZero , # [codec (index = 11)] # [doc = "The caller is requesting removing more stake than there exists in the staking account. See: \"[remove_stake()]\"."] NotEnoughStakeToWithdraw , # [codec (index = 12)] # [doc = "The caller is requesting to set weights but the caller has less than minimum stake required to set weights (less than WeightsMinStake)."] NotEnoughStakeToSetWeights , # [codec (index = 13)] # [doc = "The caller is requesting adding more stake than there exists in the coldkey account. See: \"[add_stake()]\""] NotEnoughBalanceToStake , # [codec (index = 14)] # [doc = "The caller is trying to add stake, but for some reason the requested amount could not be withdrawn from the coldkey account."] BalanceWithdrawalError , # [codec (index = 15)] # [doc = "Unsuccessfully withdraw, balance could be zero (can not make account exist) after withdrawal."] ZeroBalanceAfterWithdrawn , # [codec (index = 16)] # [doc = "The caller is attempting to set non-self weights without being a permitted validator."] NeuronNoValidatorPermit , # [codec (index = 17)] # [doc = "The caller is attempting to set the weight keys and values but these vectors have different size."] WeightVecNotEqualSize , # [codec (index = 18)] # [doc = "The caller is attempting to set weights with duplicate UIDs in the weight matrix."] DuplicateUids , # [codec (index = 19)] # [doc = "The caller is attempting to set weight to at least one UID that does not exist in the metagraph."] UidVecContainInvalidOne , # [codec (index = 20)] # [doc = "The dispatch is attempting to set weights on chain with fewer elements than are allowed."] WeightVecLengthIsLow , # [codec (index = 21)] # [doc = "Number of registrations in this block exceeds the allowed number (i.e., exceeds the subnet hyperparameter \"max_regs_per_block\")."] TooManyRegistrationsThisBlock , # [codec (index = 22)] # [doc = "The caller is requesting registering a neuron which already exists in the active set."] HotKeyAlreadyRegisteredInSubNet , # [codec (index = 23)] # [doc = "The new hotkey is the same as old one"] NewHotKeyIsSameWithOld , # [codec (index = 24)] # [doc = "The supplied PoW hash block is in the future or negative."] InvalidWorkBlock , # [codec (index = 25)] # [doc = "The supplied PoW hash block does not meet the network difficulty."] InvalidDifficulty , # [codec (index = 26)] # [doc = "The supplied PoW hash seal does not match the supplied work."] InvalidSeal , # [codec (index = 27)] # [doc = "The dispatch is attempting to set weights on chain with weight value exceeding the MaxWeightLimit (max_weight_limit subnet hyperparameter)."] MaxWeightExceeded , # [codec (index = 28)] # [doc = "The hotkey is attempting to become a delegate when the hotkey is already a delegate."] HotKeyAlreadyDelegate , # [codec (index = 29)] # [doc = "A transactor exceeded the rate limit for setting weights."] SettingWeightsTooFast , # [codec (index = 30)] # [doc = "A validator is attempting to set weights from a validator with incorrect weight version."] IncorrectWeightVersionKey , # [codec (index = 31)] # [doc = "An axon or prometheus serving exceeded the rate limit for a registered neuron."] ServingRateLimitExceeded , # [codec (index = 32)] # [doc = "The caller is attempting to set weights with more UIDs than allowed."] UidsLengthExceedUidsInSubNet , # [codec (index = 33)] # [doc = "A transactor exceeded the rate limit for add network transaction."] NetworkTxRateLimitExceeded , # [codec (index = 34)] # [doc = "A transactor exceeded the rate limit for delegate transaction."] DelegateTxRateLimitExceeded , # [codec (index = 35)] # [doc = "A transactor exceeded the rate limit for setting or swapping hotkey."] HotKeySetTxRateLimitExceeded , # [codec (index = 36)] # [doc = "A transactor exceeded the rate limit for staking."] StakeRateLimitExceeded , # [codec (index = 37)] # [doc = "A transactor exceeded the rate limit for unstaking."] UnstakeRateLimitExceeded , # [codec (index = 38)] # [doc = "Registration is disabled."] SubNetRegistrationDisabled , # [codec (index = 39)] # [doc = "The number of registration attempts exceeded the allowed number in the interval."] TooManyRegistrationsThisInterval , # [codec (index = 40)] # [doc = "The hotkey is required to be the origin."] TransactorAccountShouldBeHotKey , # [codec (index = 41)] # [doc = "A hotkey is attempting to do something only senate members can do."] NotSenateMember , # [codec (index = 42)] # [doc = "Faucet is disabled."] FaucetDisabled , # [codec (index = 43)] # [doc = "Not a subnet owner."] NotSubnetOwner , # [codec (index = 44)] # [doc = "Operation is not permitted on the root subnet."] RegistrationNotPermittedOnRootSubnet , # [codec (index = 45)] # [doc = "A hotkey with too little stake is attempting to join the root subnet."] StakeTooLowForRoot , # [codec (index = 46)] # [doc = "All subnets are in the immunity period."] AllNetworksInImmunity , # [codec (index = 47)] # [doc = "Not enough balance to pay swapping hotkey."] NotEnoughBalanceToPaySwapHotKey , # [codec (index = 48)] # [doc = "Netuid does not match for setting root network weights."] NotRootSubnet , # [codec (index = 49)] # [doc = "Can not set weights for the root network."] CanNotSetRootNetworkWeights , # [codec (index = 50)] # [doc = "No neuron ID is available."] NoNeuronIdAvailable , # [codec (index = 51)] # [doc = "Stake amount below the minimum threshold for nominator validations."] NomStakeBelowMinimumThreshold , # [codec (index = 52)] # [doc = "Delegate take is too low."] DelegateTakeTooLow , # [codec (index = 53)] # [doc = "Delegate take is too high."] DelegateTakeTooHigh , # [codec (index = 54)] # [doc = "Not allowed to commit weights."] WeightsCommitNotAllowed , # [codec (index = 55)] # [doc = "No commit found for the provided hotkey+netuid combination when attempting to reveal the weights."] NoWeightsCommitFound , # [codec (index = 56)] # [doc = "Not the correct block/range to reveal weights."] InvalidRevealCommitTempo , # [codec (index = 57)] # [doc = "Committed hash does not equal the hashed reveal data."] InvalidRevealCommitHashNotMatch , # [codec (index = 58)] # [doc = "Attempting to call set_weights when commit/reveal is enabled"] CommitRevealEnabled , # [codec (index = 59)] # [doc = "Attemtping to commit/reveal weights when disabled."] CommitRevealDisabled , # [codec (index = 60)] # [doc = "Not able to join the senate."] CouldNotJoinSenate , # [codec (index = 61)] # [doc = "Attempting to set alpha high/low while disabled"] LiquidAlphaDisabled , # [codec (index = 62)] # [doc = "Alpha high is too low: alpha_high > 0.8"] AlphaHighTooLow , # [codec (index = 63)] # [doc = "Alpha low is out of range: alpha_low > 0 && alpha_low < 0.8"] AlphaLowOutOfRange , # [codec (index = 64)] # [doc = "The coldkey has already been swapped"] ColdKeyAlreadyAssociated , # [codec (index = 65)] # [doc = "The coldkey swap transaction rate limit exceeded"] ColdKeySwapTxRateLimitExceeded , # [codec (index = 66)] # [doc = "The new coldkey is the same as the old coldkey"] NewColdKeyIsSameWithOld , # [codec (index = 67)] # [doc = "The coldkey does not exist"] NotExistColdkey , # [codec (index = 68)] # [doc = "The coldkey balance is not enough to pay for the swap"] NotEnoughBalanceToPaySwapColdKey , # [codec (index = 69)] # [doc = "No balance to transfer"] NoBalanceToTransfer , # [codec (index = 70)] # [doc = "Same coldkey"] SameColdkey , # [codec (index = 71)] # [doc = "The coldkey is in arbitration"] ColdkeyIsInArbitration , # [codec (index = 72)] # [doc = "The new coldkey is already registered for the drain"] DuplicateColdkey , # [codec (index = 73)] # [doc = "Error thrown on a coldkey swap."] ColdkeySwapError , # [codec (index = 74)] # [doc = "Insufficient Balance to Schedule coldkey swap"] InsufficientBalanceToPerformColdkeySwap , # [codec (index = 75)] # [doc = "The maximum number of coldkey destinations has been reached"] MaxColdkeyDestinationsReached , # [codec (index = 76)] # [doc = "Attempting to set an invalid child for a hotkey on a network."] InvalidChild , # [codec (index = 77)] # [doc = "Duplicate child when setting children."] DuplicateChild , # [codec (index = 78)] # [doc = "Proportion overflow when setting children."] ProportionOverflow , # [codec (index = 79)] # [doc = "Too many children MAX 5."] TooManyChildren , # [codec (index = 80)] # [doc = "Default transaction rate limit exceeded."] TxRateLimitExceeded , # [codec (index = 81)] # [doc = "Swap coldkey only callable by root."] SwapColdkeyOnlyCallableByRoot , # [codec (index = 82)] # [doc = "Swap already scheduled."] SwapAlreadyScheduled , # [codec (index = 83)] # [doc = "failed to swap coldkey"] FailedToSchedule , # [codec (index = 84)] # [doc = "New coldkey is hotkey"] NewColdKeyIsHotkey , # [codec (index = 85)] # [doc = "New coldkey is in arbitration"] NewColdkeyIsInArbitration , # [codec (index = 86)] # [doc = "Childkey take is invalid."] InvalidChildkeyTake , # [codec (index = 87)] # [doc = "Childkey take rate limit exceeded."] TxChildkeyTakeRateLimitExceeded , # [codec (index = 88)] # [doc = "Invalid identity."] InvalidIdentity , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The `Event` enum of this pallet"] pub enum Event { # [codec (index = 0)] # [doc = "a new network is added."] NetworkAdded (:: core :: primitive :: u16 , :: core :: primitive :: u16 ,) , # [codec (index = 1)] # [doc = "a network is removed."] NetworkRemoved (:: core :: primitive :: u16 ,) , # [codec (index = 2)] # [doc = "stake has been transferred from the a coldkey account onto the hotkey staking account."] StakeAdded (:: subxt :: ext :: subxt_core :: utils :: AccountId32 , :: core :: primitive :: u64 ,) , # [codec (index = 3)] # [doc = "stake has been removed from the hotkey staking account onto the coldkey account."] StakeRemoved (:: subxt :: ext :: subxt_core :: utils :: AccountId32 , :: core :: primitive :: u64 ,) , # [codec (index = 4)] # [doc = "a caller successfully sets their weights on a subnetwork."] WeightsSet (:: core :: primitive :: u16 , :: core :: primitive :: u16 ,) , # [codec (index = 5)] # [doc = "a new neuron account has been registered to the chain."] NeuronRegistered (:: core :: primitive :: u16 , :: core :: primitive :: u16 , :: subxt :: ext :: subxt_core :: utils :: AccountId32 ,) , # [codec (index = 6)] # [doc = "multiple uids have been concurrently registered."] BulkNeuronsRegistered (:: core :: primitive :: u16 , :: core :: primitive :: u16 ,) , # [codec (index = 7)] # [doc = "FIXME: Not used yet"] BulkBalancesSet (:: core :: primitive :: u16 , :: core :: primitive :: u16 ,) , # [codec (index = 8)] # [doc = "max allowed uids has been set for a subnetwork."] MaxAllowedUidsSet (:: core :: primitive :: u16 , :: core :: primitive :: u16 ,) , # [codec (index = 9)] # [doc = "the max weight limit has been set for a subnetwork."] MaxWeightLimitSet (:: core :: primitive :: u16 , :: core :: primitive :: u16 ,) , # [codec (index = 10)] # [doc = "the difficulty has been set for a subnet."] DifficultySet (:: core :: primitive :: u16 , :: core :: primitive :: u64 ,) , # [codec (index = 11)] # [doc = "the adjustment interval is set for a subnet."] AdjustmentIntervalSet (:: core :: primitive :: u16 , :: core :: primitive :: u16 ,) , # [codec (index = 12)] # [doc = "registration per interval is set for a subnet."] RegistrationPerIntervalSet (:: core :: primitive :: u16 , :: core :: primitive :: u16 ,) , # [codec (index = 13)] # [doc = "we set max registrations per block."] MaxRegistrationsPerBlockSet (:: core :: primitive :: u16 , :: core :: primitive :: u16 ,) , # [codec (index = 14)] # [doc = "an activity cutoff is set for a subnet."] ActivityCutoffSet (:: core :: primitive :: u16 , :: core :: primitive :: u16 ,) , # [codec (index = 15)] # [doc = "Rho value is set."] RhoSet (:: core :: primitive :: u16 , :: core :: primitive :: u16 ,) , # [codec (index = 16)] # [doc = "Kappa is set for a subnet."] KappaSet (:: core :: primitive :: u16 , :: core :: primitive :: u16 ,) , # [codec (index = 17)] # [doc = "minimum allowed weight is set for a subnet."] MinAllowedWeightSet (:: core :: primitive :: u16 , :: core :: primitive :: u16 ,) , # [codec (index = 18)] # [doc = "the validator pruning length has been set."] ValidatorPruneLenSet (:: core :: primitive :: u16 , :: core :: primitive :: u64 ,) , # [codec (index = 19)] # [doc = "the scaling law power has been set for a subnet."] ScalingLawPowerSet (:: core :: primitive :: u16 , :: core :: primitive :: u16 ,) , # [codec (index = 20)] # [doc = "weights set rate limit has been set for a subnet."] WeightsSetRateLimitSet (:: core :: primitive :: u16 , :: core :: primitive :: u64 ,) , # [codec (index = 21)] # [doc = "immunity period is set for a subnet."] ImmunityPeriodSet (:: core :: primitive :: u16 , :: core :: primitive :: u16 ,) , # [codec (index = 22)] # [doc = "bonds moving average is set for a subnet."] BondsMovingAverageSet (:: core :: primitive :: u16 , :: core :: primitive :: u64 ,) , # [codec (index = 23)] # [doc = "setting the max number of allowed validators on a subnet."] MaxAllowedValidatorsSet (:: core :: primitive :: u16 , :: core :: primitive :: u16 ,) , # [codec (index = 24)] # [doc = "the axon server information is added to the network."] AxonServed (:: core :: primitive :: u16 , :: subxt :: ext :: subxt_core :: utils :: AccountId32 ,) , # [codec (index = 25)] # [doc = "the prometheus server information is added to the network."] PrometheusServed (:: core :: primitive :: u16 , :: subxt :: ext :: subxt_core :: utils :: AccountId32 ,) , # [codec (index = 26)] # [doc = "emission ratios for all networks is set."] EmissionValuesSet , # [codec (index = 27)] # [doc = "a hotkey has become a delegate."] DelegateAdded (:: subxt :: ext :: subxt_core :: utils :: AccountId32 , :: subxt :: ext :: subxt_core :: utils :: AccountId32 , :: core :: primitive :: u16 ,) , # [codec (index = 28)] # [doc = "the default take is set."] DefaultTakeSet (:: core :: primitive :: u16 ,) , # [codec (index = 29)] # [doc = "weights version key is set for a network."] WeightsVersionKeySet (:: core :: primitive :: u16 , :: core :: primitive :: u64 ,) , # [codec (index = 30)] # [doc = "setting min difficulty on a network."] MinDifficultySet (:: core :: primitive :: u16 , :: core :: primitive :: u64 ,) , # [codec (index = 31)] # [doc = "setting max difficulty on a network."] MaxDifficultySet (:: core :: primitive :: u16 , :: core :: primitive :: u64 ,) , # [codec (index = 32)] # [doc = "setting the prometheus serving rate limit."] ServingRateLimitSet (:: core :: primitive :: u16 , :: core :: primitive :: u64 ,) , # [codec (index = 33)] # [doc = "setting burn on a network."] BurnSet (:: core :: primitive :: u16 , :: core :: primitive :: u64 ,) , # [codec (index = 34)] # [doc = "setting max burn on a network."] MaxBurnSet (:: core :: primitive :: u16 , :: core :: primitive :: u64 ,) , # [codec (index = 35)] # [doc = "setting min burn on a network."] MinBurnSet (:: core :: primitive :: u16 , :: core :: primitive :: u64 ,) , # [codec (index = 36)] # [doc = "setting the transaction rate limit."] TxRateLimitSet (:: core :: primitive :: u64 ,) , # [codec (index = 37)] # [doc = "setting the delegate take transaction rate limit."] TxDelegateTakeRateLimitSet (:: core :: primitive :: u64 ,) , # [codec (index = 38)] # [doc = "setting the childkey take transaction rate limit."] TxChildKeyTakeRateLimitSet (:: core :: primitive :: u64 ,) , # [codec (index = 39)] # [doc = "minimum childkey take set"] MinChildKeyTakeSet (:: core :: primitive :: u16 ,) , # [codec (index = 40)] # [doc = "maximum childkey take set"] MaxChildKeyTakeSet (:: core :: primitive :: u16 ,) , # [codec (index = 41)] # [doc = "childkey take set"] ChildKeyTakeSet (:: subxt :: ext :: subxt_core :: utils :: AccountId32 , :: core :: primitive :: u16 ,) , # [codec (index = 42)] # [doc = "a sudo call is done."] Sudid (:: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > ,) , # [codec (index = 43)] # [doc = "registration is allowed/disallowed for a subnet."] RegistrationAllowed (:: core :: primitive :: u16 , :: core :: primitive :: bool ,) , # [codec (index = 44)] # [doc = "POW registration is allowed/disallowed for a subnet."] PowRegistrationAllowed (:: core :: primitive :: u16 , :: core :: primitive :: bool ,) , # [codec (index = 45)] # [doc = "setting tempo on a network"] TempoSet (:: core :: primitive :: u16 , :: core :: primitive :: u16 ,) , # [codec (index = 46)] # [doc = "setting the RAO recycled for registration."] RAORecycledForRegistrationSet (:: core :: primitive :: u16 , :: core :: primitive :: u64 ,) , # [codec (index = 47)] # [doc = "min stake is set for validators to set weights."] WeightsMinStake (:: core :: primitive :: u64 ,) , # [codec (index = 48)] # [doc = "setting the minimum required stake amount for senate registration."] SenateRequiredStakePercentSet (:: core :: primitive :: u64 ,) , # [codec (index = 49)] # [doc = "setting the adjustment alpha on a subnet."] AdjustmentAlphaSet (:: core :: primitive :: u16 , :: core :: primitive :: u64 ,) , # [codec (index = 50)] # [doc = "the faucet it called on the test net."] Faucet (:: subxt :: ext :: subxt_core :: utils :: AccountId32 , :: core :: primitive :: u64 ,) , # [codec (index = 51)] # [doc = "the subnet owner cut is set."] SubnetOwnerCutSet (:: core :: primitive :: u16 ,) , # [codec (index = 52)] # [doc = "the network creation rate limit is set."] NetworkRateLimitSet (:: core :: primitive :: u64 ,) , # [codec (index = 53)] # [doc = "the network immunity period is set."] NetworkImmunityPeriodSet (:: core :: primitive :: u64 ,) , # [codec (index = 54)] # [doc = "the network minimum locking cost is set."] NetworkMinLockCostSet (:: core :: primitive :: u64 ,) , # [codec (index = 55)] # [doc = "the maximum number of subnets is set"] SubnetLimitSet (:: core :: primitive :: u16 ,) , # [codec (index = 56)] # [doc = "the lock cost reduction is set"] NetworkLockCostReductionIntervalSet (:: core :: primitive :: u64 ,) , # [codec (index = 57)] # [doc = "the take for a delegate is decreased."] TakeDecreased (:: subxt :: ext :: subxt_core :: utils :: AccountId32 , :: subxt :: ext :: subxt_core :: utils :: AccountId32 , :: core :: primitive :: u16 ,) , # [codec (index = 58)] # [doc = "the take for a delegate is increased."] TakeIncreased (:: subxt :: ext :: subxt_core :: utils :: AccountId32 , :: subxt :: ext :: subxt_core :: utils :: AccountId32 , :: core :: primitive :: u16 ,) , # [codec (index = 59)] # [doc = "the hotkey is swapped"] HotkeySwapped { coldkey : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , old_hotkey : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , new_hotkey : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , } , # [codec (index = 60)] # [doc = "maximum delegate take is set by sudo/admin transaction"] MaxDelegateTakeSet (:: core :: primitive :: u16 ,) , # [codec (index = 61)] # [doc = "minimum delegate take is set by sudo/admin transaction"] MinDelegateTakeSet (:: core :: primitive :: u16 ,) , # [codec (index = 62)] # [doc = "the target stakes per interval is set by sudo/admin transaction"] TargetStakesPerIntervalSet (:: core :: primitive :: u64 ,) , # [codec (index = 63)] # [doc = "a member of the senate is adjusted"] SenateAdjusted { old_member : :: core :: option :: Option < :: subxt :: ext :: subxt_core :: utils :: AccountId32 > , new_member : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , } , # [codec (index = 64)] # [doc = "A coldkey has been swapped"] ColdkeySwapped { old_coldkey : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , new_coldkey : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , } , # [codec (index = 65)] # [doc = "All balance of a hotkey has been unstaked and transferred to a new coldkey"] AllBalanceUnstakedAndTransferredToNewColdkey { current_coldkey : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , new_coldkey : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , total_balance : :: core :: primitive :: u64 , } , # [codec (index = 66)] # [doc = "A coldkey swap has been scheduled"] ColdkeySwapScheduled { old_coldkey : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , new_coldkey : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , execution_block : :: core :: primitive :: u32 , } , # [codec (index = 67)] # [doc = "The arbitration period has been extended"] ArbitrationPeriodExtended { coldkey : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , } , # [codec (index = 68)] # [doc = "The children of a hotkey have been set"] SetChildren (:: subxt :: ext :: subxt_core :: utils :: AccountId32 , :: core :: primitive :: u16 , :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < (:: core :: primitive :: u64 , :: subxt :: ext :: subxt_core :: utils :: AccountId32 ,) > ,) , # [codec (index = 69)] # [doc = "The hotkey emission tempo has been set"] HotkeyEmissionTempoSet (:: core :: primitive :: u64 ,) , # [codec (index = 70)] # [doc = "The network maximum stake has been set"] NetworkMaxStakeSet (:: core :: primitive :: u16 , :: core :: primitive :: u64 ,) , # [codec (index = 71)] # [doc = "The identity of a coldkey has been set"] ChainIdentitySet (:: subxt :: ext :: subxt_core :: utils :: AccountId32 ,) , # [codec (index = 72)] # [doc = "The identity of a subnet has been set"] SubnetIdentitySet (:: core :: primitive :: u16 ,) , # [codec (index = 73)] # [doc = "The identity of a subnet has been removed"] SubnetIdentityRemoved (:: core :: primitive :: u16 ,) , # [codec (index = 74)] # [doc = "A dissolve network extrinsic scheduled."] DissolveNetworkScheduled { account : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , netuid : :: core :: primitive :: u16 , execution_block : :: core :: primitive :: u32 , } , # [codec (index = 75)] # [doc = "The duration of schedule coldkey swap has been set"] ColdkeySwapScheduleDurationSet (:: core :: primitive :: u32 ,) , # [codec (index = 76)] # [doc = "The duration of dissolve network has been set"] DissolveNetworkScheduleDurationSet (:: core :: primitive :: u32 ,) , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct PrometheusInfo { pub block : :: core :: primitive :: u64 , pub version : :: core :: primitive :: u32 , pub ip : :: core :: primitive :: u128 , pub port : :: core :: primitive :: u16 , pub ip_type : :: core :: primitive :: u8 , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct SubnetIdentity { pub subnet_name : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > , pub github_repo : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > , pub subnet_contact : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > , } } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct SubtensorSignedExtension < _0 > (pub :: core :: marker :: PhantomData < _0 >) ; } pub mod pallet_sudo { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Contains a variant per dispatchable extrinsic that this pallet has."] pub enum Call { # [codec (index = 0)] # [doc = "Authenticates the sudo key and dispatches a function call with `Root` origin."] sudo { call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < runtime_types :: node_subtensor_runtime :: RuntimeCall > , } , # [codec (index = 1)] # [doc = "Authenticates the sudo key and dispatches a function call with `Root` origin."] # [doc = "This function does not check the weight of the call, and instead allows the"] # [doc = "Sudo user to specify the weight of the call."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] sudo_unchecked_weight { call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < runtime_types :: node_subtensor_runtime :: RuntimeCall > , weight : runtime_types :: sp_weights :: weight_v2 :: Weight , } , # [codec (index = 2)] # [doc = "Authenticates the current sudo key and sets the given AccountId (`new`) as the new sudo"] # [doc = "key."] set_key { new : :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > , } , # [codec (index = 3)] # [doc = "Authenticates the sudo key and dispatches a function call with `Signed` origin from"] # [doc = "a given account."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] sudo_as { who : :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > , call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < runtime_types :: node_subtensor_runtime :: RuntimeCall > , } , # [codec (index = 4)] # [doc = "Permanently removes the sudo key."] # [doc = ""] # [doc = "**This cannot be un-done.**"] remove_key , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Error for the Sudo pallet."] pub enum Error { # [codec (index = 0)] # [doc = "Sender must be the Sudo account."] RequireSudo , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The `Event` enum of this pallet"] pub enum Event { # [codec (index = 0)] # [doc = "A sudo call just took place."] Sudid { sudo_result : :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > , } , # [codec (index = 1)] # [doc = "The sudo key has been updated."] KeyChanged { old : :: core :: option :: Option < :: subxt :: ext :: subxt_core :: utils :: AccountId32 > , new : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , } , # [codec (index = 2)] # [doc = "The key was permanently removed."] KeyRemoved , # [codec (index = 3)] # [doc = "A [sudo_as](Pallet::sudo_as) call just took place."] SudoAsDone { sudo_result : :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > , } , } } } pub mod pallet_timestamp { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Contains a variant per dispatchable extrinsic that this pallet has."] pub enum Call { # [codec (index = 0)] # [doc = "Set the current time."] # [doc = ""] # [doc = "This call should be invoked exactly once per block. It will panic at the finalization"] # [doc = "phase, if this call hasn't been invoked by that time."] # [doc = ""] # [doc = "The timestamp should be greater than the previous one by the amount specified by"] # [doc = "[`Config::MinimumPeriod`]."] # [doc = ""] # [doc = "The dispatch origin for this call must be _None_."] # [doc = ""] # [doc = "This dispatch class is _Mandatory_ to ensure it gets executed in the block. Be aware"] # [doc = "that changing the complexity of this call could result exhausting the resources in a"] # [doc = "block to execute any other calls."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(1)` (Note that implementations of `OnTimestampSet` must also be `O(1)`)"] # [doc = "- 1 storage read and 1 storage mutation (codec `O(1)` because of `DidUpdate::take` in"] # [doc = "  `on_finalize`)"] # [doc = "- 1 event handler `on_timestamp_set`. Must be `O(1)`."] set { # [codec (compact)] now : :: core :: primitive :: u64 , } , } } } pub mod pallet_transaction_payment { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The `Event` enum of this pallet"] pub enum Event { # [codec (index = 0)] # [doc = "A transaction fee `actual_fee`, of which `tip` was added to the minimum inclusion fee,"] # [doc = "has been paid by `who`."] TransactionFeePaid { who : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , actual_fee : :: core :: primitive :: u64 , tip : :: core :: primitive :: u64 , } , } } pub mod types { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct FeeDetails < _0 > { pub inclusion_fee : :: core :: option :: Option < runtime_types :: pallet_transaction_payment :: types :: InclusionFee < _0 > > , pub tip : _0 , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct InclusionFee < _0 > { pub base_fee : _0 , pub len_fee : _0 , pub adjusted_weight_fee : _0 , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct RuntimeDispatchInfo < _0 , _1 > { pub weight : _1 , pub class : runtime_types :: frame_support :: dispatch :: DispatchClass , pub partial_fee : _0 , } } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct ChargeTransactionPayment (# [codec (compact)] pub :: core :: primitive :: u64 ,) ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum Releases { # [codec (index = 0)] V1Ancient , # [codec (index = 1)] V2 , } } pub mod pallet_utility { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Contains a variant per dispatchable extrinsic that this pallet has."] pub enum Call { # [codec (index = 0)] # [doc = "Send a batch of dispatch calls."] # [doc = ""] # [doc = "May be called from any origin except `None`."] # [doc = ""] # [doc = "- `calls`: The calls to be dispatched from the same origin. The number of call must not"] # [doc = "  exceed the constant: `batched_calls_limit` (available in constant metadata)."] # [doc = ""] # [doc = "If origin is root then the calls are dispatched without checking origin filter. (This"] # [doc = "includes bypassing `frame_system::Config::BaseCallFilter`)."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- O(C) where C is the number of calls to be batched."] # [doc = ""] # [doc = "This will return `Ok` in all circumstances. To determine the success of the batch, an"] # [doc = "event is deposited. If a call failed and the batch was interrupted, then the"] # [doc = "`BatchInterrupted` event is deposited, along with the number of successful calls made"] # [doc = "and the error of the failed call. If all were successful, then the `BatchCompleted`"] # [doc = "event is deposited."] batch { calls : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < runtime_types :: node_subtensor_runtime :: RuntimeCall > , } , # [codec (index = 1)] # [doc = "Send a call through an indexed pseudonym of the sender."] # [doc = ""] # [doc = "Filter from origin are passed along. The call will be dispatched with an origin which"] # [doc = "use the same filter as the origin of this call."] # [doc = ""] # [doc = "NOTE: If you need to ensure that any account-based filtering is not honored (i.e."] # [doc = "because you expect `proxy` to have been used prior in the call stack and you do not want"] # [doc = "the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`"] # [doc = "in the Multisig pallet instead."] # [doc = ""] # [doc = "NOTE: Prior to version *12, this was called `as_limited_sub`."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] as_derivative { index : :: core :: primitive :: u16 , call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < runtime_types :: node_subtensor_runtime :: RuntimeCall > , } , # [codec (index = 2)] # [doc = "Send a batch of dispatch calls and atomically execute them."] # [doc = "The whole transaction will rollback and fail if any of the calls failed."] # [doc = ""] # [doc = "May be called from any origin except `None`."] # [doc = ""] # [doc = "- `calls`: The calls to be dispatched from the same origin. The number of call must not"] # [doc = "  exceed the constant: `batched_calls_limit` (available in constant metadata)."] # [doc = ""] # [doc = "If origin is root then the calls are dispatched without checking origin filter. (This"] # [doc = "includes bypassing `frame_system::Config::BaseCallFilter`)."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- O(C) where C is the number of calls to be batched."] batch_all { calls : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < runtime_types :: node_subtensor_runtime :: RuntimeCall > , } , # [codec (index = 3)] # [doc = "Dispatches a function call with a provided origin."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Root_."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- O(1)."] dispatch_as { as_origin : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < runtime_types :: node_subtensor_runtime :: OriginCaller > , call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < runtime_types :: node_subtensor_runtime :: RuntimeCall > , } , # [codec (index = 4)] # [doc = "Send a batch of dispatch calls."] # [doc = "Unlike `batch`, it allows errors and won't interrupt."] # [doc = ""] # [doc = "May be called from any origin except `None`."] # [doc = ""] # [doc = "- `calls`: The calls to be dispatched from the same origin. The number of call must not"] # [doc = "  exceed the constant: `batched_calls_limit` (available in constant metadata)."] # [doc = ""] # [doc = "If origin is root then the calls are dispatch without checking origin filter. (This"] # [doc = "includes bypassing `frame_system::Config::BaseCallFilter`)."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- O(C) where C is the number of calls to be batched."] force_batch { calls : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < runtime_types :: node_subtensor_runtime :: RuntimeCall > , } , # [codec (index = 5)] # [doc = "Dispatch a function call with a specified weight."] # [doc = ""] # [doc = "This function does not check the weight of the call, and instead allows the"] # [doc = "Root origin to specify the weight of the call."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Root_."] with_weight { call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < runtime_types :: node_subtensor_runtime :: RuntimeCall > , weight : runtime_types :: sp_weights :: weight_v2 :: Weight , } , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The `Error` enum of this pallet."] pub enum Error { # [codec (index = 0)] # [doc = "Too many calls batched."] TooManyCalls , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The `Event` enum of this pallet"] pub enum Event { # [codec (index = 0)] # [doc = "Batch of dispatches did not complete fully. Index of first failing dispatch given, as"] # [doc = "well as the error."] BatchInterrupted { index : :: core :: primitive :: u32 , error : runtime_types :: sp_runtime :: DispatchError , } , # [codec (index = 1)] # [doc = "Batch of dispatches completed fully with no error."] BatchCompleted , # [codec (index = 2)] # [doc = "Batch of dispatches completed but has errors."] BatchCompletedWithErrors , # [codec (index = 3)] # [doc = "A single item within a Batch of dispatches has completed with no error."] ItemCompleted , # [codec (index = 4)] # [doc = "A single item within a Batch of dispatches has completed with error."] ItemFailed { error : runtime_types :: sp_runtime :: DispatchError , } , # [codec (index = 5)] # [doc = "A call was dispatched."] DispatchedAs { result : :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > , } , } } } pub mod sp_arithmetic { use super :: runtime_types ; pub mod fixed_point { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: CompactAs , :: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct FixedU128 (pub :: core :: primitive :: u128 ,) ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum ArithmeticError { # [codec (index = 0)] Underflow , # [codec (index = 1)] Overflow , # [codec (index = 2)] DivisionByZero , } } pub mod sp_consensus_aura { use super :: runtime_types ; pub mod sr25519 { use super :: runtime_types ; pub mod app_sr25519 { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct Public (pub [:: core :: primitive :: u8 ; 32usize] ,) ; } } } pub mod sp_consensus_grandpa { use super :: runtime_types ; pub mod app { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct Public (pub [:: core :: primitive :: u8 ; 32usize] ,) ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct Signature (pub [:: core :: primitive :: u8 ; 64usize] ,) ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum Equivocation < _0 , _1 > { # [codec (index = 0)] Prevote (runtime_types :: finality_grandpa :: Equivocation < runtime_types :: sp_consensus_grandpa :: app :: Public , runtime_types :: finality_grandpa :: Prevote < _0 , _1 > , runtime_types :: sp_consensus_grandpa :: app :: Signature > ,) , # [codec (index = 1)] Precommit (runtime_types :: finality_grandpa :: Equivocation < runtime_types :: sp_consensus_grandpa :: app :: Public , runtime_types :: finality_grandpa :: Precommit < _0 , _1 > , runtime_types :: sp_consensus_grandpa :: app :: Signature > ,) , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct EquivocationProof < _0 , _1 > { pub set_id : :: core :: primitive :: u64 , pub equivocation : runtime_types :: sp_consensus_grandpa :: Equivocation < _0 , _1 > , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct OpaqueKeyOwnershipProof (pub :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ,) ; } pub mod sp_consensus_slots { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: CompactAs , :: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct Slot (pub :: core :: primitive :: u64 ,) ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: CompactAs , :: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct SlotDuration (pub :: core :: primitive :: u64 ,) ; } pub mod sp_core { use super :: runtime_types ; pub mod crypto { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct KeyTypeId (pub [:: core :: primitive :: u8 ; 4usize] ,) ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct OpaqueMetadata (pub :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ,) ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum Void { } } pub mod sp_inherents { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct CheckInherentsResult { pub okay : :: core :: primitive :: bool , pub fatal_error : :: core :: primitive :: bool , pub errors : runtime_types :: sp_inherents :: InherentData , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct InherentData { pub data : :: subxt :: ext :: subxt_core :: utils :: KeyedVec < [:: core :: primitive :: u8 ; 8usize] , :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > > , } } pub mod sp_runtime { use super :: runtime_types ; pub mod generic { use super :: runtime_types ; pub mod block { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct Block < _0 , _1 > { pub header : _0 , pub extrinsics : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < _1 > , } } pub mod digest { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct Digest { pub logs : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < runtime_types :: sp_runtime :: generic :: digest :: DigestItem > , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum DigestItem { # [codec (index = 6)] PreRuntime ([:: core :: primitive :: u8 ; 4usize] , :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ,) , # [codec (index = 4)] Consensus ([:: core :: primitive :: u8 ; 4usize] , :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ,) , # [codec (index = 5)] Seal ([:: core :: primitive :: u8 ; 4usize] , :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ,) , # [codec (index = 0)] Other (:: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ,) , # [codec (index = 8)] RuntimeEnvironmentUpdated , } } pub mod era { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum Era { # [codec (index = 0)] Immortal , # [codec (index = 1)] Mortal1 (:: core :: primitive :: u8 ,) , # [codec (index = 2)] Mortal2 (:: core :: primitive :: u8 ,) , # [codec (index = 3)] Mortal3 (:: core :: primitive :: u8 ,) , # [codec (index = 4)] Mortal4 (:: core :: primitive :: u8 ,) , # [codec (index = 5)] Mortal5 (:: core :: primitive :: u8 ,) , # [codec (index = 6)] Mortal6 (:: core :: primitive :: u8 ,) , # [codec (index = 7)] Mortal7 (:: core :: primitive :: u8 ,) , # [codec (index = 8)] Mortal8 (:: core :: primitive :: u8 ,) , # [codec (index = 9)] Mortal9 (:: core :: primitive :: u8 ,) , # [codec (index = 10)] Mortal10 (:: core :: primitive :: u8 ,) , # [codec (index = 11)] Mortal11 (:: core :: primitive :: u8 ,) , # [codec (index = 12)] Mortal12 (:: core :: primitive :: u8 ,) , # [codec (index = 13)] Mortal13 (:: core :: primitive :: u8 ,) , # [codec (index = 14)] Mortal14 (:: core :: primitive :: u8 ,) , # [codec (index = 15)] Mortal15 (:: core :: primitive :: u8 ,) , # [codec (index = 16)] Mortal16 (:: core :: primitive :: u8 ,) , # [codec (index = 17)] Mortal17 (:: core :: primitive :: u8 ,) , # [codec (index = 18)] Mortal18 (:: core :: primitive :: u8 ,) , # [codec (index = 19)] Mortal19 (:: core :: primitive :: u8 ,) , # [codec (index = 20)] Mortal20 (:: core :: primitive :: u8 ,) , # [codec (index = 21)] Mortal21 (:: core :: primitive :: u8 ,) , # [codec (index = 22)] Mortal22 (:: core :: primitive :: u8 ,) , # [codec (index = 23)] Mortal23 (:: core :: primitive :: u8 ,) , # [codec (index = 24)] Mortal24 (:: core :: primitive :: u8 ,) , # [codec (index = 25)] Mortal25 (:: core :: primitive :: u8 ,) , # [codec (index = 26)] Mortal26 (:: core :: primitive :: u8 ,) , # [codec (index = 27)] Mortal27 (:: core :: primitive :: u8 ,) , # [codec (index = 28)] Mortal28 (:: core :: primitive :: u8 ,) , # [codec (index = 29)] Mortal29 (:: core :: primitive :: u8 ,) , # [codec (index = 30)] Mortal30 (:: core :: primitive :: u8 ,) , # [codec (index = 31)] Mortal31 (:: core :: primitive :: u8 ,) , # [codec (index = 32)] Mortal32 (:: core :: primitive :: u8 ,) , # [codec (index = 33)] Mortal33 (:: core :: primitive :: u8 ,) , # [codec (index = 34)] Mortal34 (:: core :: primitive :: u8 ,) , # [codec (index = 35)] Mortal35 (:: core :: primitive :: u8 ,) , # [codec (index = 36)] Mortal36 (:: core :: primitive :: u8 ,) , # [codec (index = 37)] Mortal37 (:: core :: primitive :: u8 ,) , # [codec (index = 38)] Mortal38 (:: core :: primitive :: u8 ,) , # [codec (index = 39)] Mortal39 (:: core :: primitive :: u8 ,) , # [codec (index = 40)] Mortal40 (:: core :: primitive :: u8 ,) , # [codec (index = 41)] Mortal41 (:: core :: primitive :: u8 ,) , # [codec (index = 42)] Mortal42 (:: core :: primitive :: u8 ,) , # [codec (index = 43)] Mortal43 (:: core :: primitive :: u8 ,) , # [codec (index = 44)] Mortal44 (:: core :: primitive :: u8 ,) , # [codec (index = 45)] Mortal45 (:: core :: primitive :: u8 ,) , # [codec (index = 46)] Mortal46 (:: core :: primitive :: u8 ,) , # [codec (index = 47)] Mortal47 (:: core :: primitive :: u8 ,) , # [codec (index = 48)] Mortal48 (:: core :: primitive :: u8 ,) , # [codec (index = 49)] Mortal49 (:: core :: primitive :: u8 ,) , # [codec (index = 50)] Mortal50 (:: core :: primitive :: u8 ,) , # [codec (index = 51)] Mortal51 (:: core :: primitive :: u8 ,) , # [codec (index = 52)] Mortal52 (:: core :: primitive :: u8 ,) , # [codec (index = 53)] Mortal53 (:: core :: primitive :: u8 ,) , # [codec (index = 54)] Mortal54 (:: core :: primitive :: u8 ,) , # [codec (index = 55)] Mortal55 (:: core :: primitive :: u8 ,) , # [codec (index = 56)] Mortal56 (:: core :: primitive :: u8 ,) , # [codec (index = 57)] Mortal57 (:: core :: primitive :: u8 ,) , # [codec (index = 58)] Mortal58 (:: core :: primitive :: u8 ,) , # [codec (index = 59)] Mortal59 (:: core :: primitive :: u8 ,) , # [codec (index = 60)] Mortal60 (:: core :: primitive :: u8 ,) , # [codec (index = 61)] Mortal61 (:: core :: primitive :: u8 ,) , # [codec (index = 62)] Mortal62 (:: core :: primitive :: u8 ,) , # [codec (index = 63)] Mortal63 (:: core :: primitive :: u8 ,) , # [codec (index = 64)] Mortal64 (:: core :: primitive :: u8 ,) , # [codec (index = 65)] Mortal65 (:: core :: primitive :: u8 ,) , # [codec (index = 66)] Mortal66 (:: core :: primitive :: u8 ,) , # [codec (index = 67)] Mortal67 (:: core :: primitive :: u8 ,) , # [codec (index = 68)] Mortal68 (:: core :: primitive :: u8 ,) , # [codec (index = 69)] Mortal69 (:: core :: primitive :: u8 ,) , # [codec (index = 70)] Mortal70 (:: core :: primitive :: u8 ,) , # [codec (index = 71)] Mortal71 (:: core :: primitive :: u8 ,) , # [codec (index = 72)] Mortal72 (:: core :: primitive :: u8 ,) , # [codec (index = 73)] Mortal73 (:: core :: primitive :: u8 ,) , # [codec (index = 74)] Mortal74 (:: core :: primitive :: u8 ,) , # [codec (index = 75)] Mortal75 (:: core :: primitive :: u8 ,) , # [codec (index = 76)] Mortal76 (:: core :: primitive :: u8 ,) , # [codec (index = 77)] Mortal77 (:: core :: primitive :: u8 ,) , # [codec (index = 78)] Mortal78 (:: core :: primitive :: u8 ,) , # [codec (index = 79)] Mortal79 (:: core :: primitive :: u8 ,) , # [codec (index = 80)] Mortal80 (:: core :: primitive :: u8 ,) , # [codec (index = 81)] Mortal81 (:: core :: primitive :: u8 ,) , # [codec (index = 82)] Mortal82 (:: core :: primitive :: u8 ,) , # [codec (index = 83)] Mortal83 (:: core :: primitive :: u8 ,) , # [codec (index = 84)] Mortal84 (:: core :: primitive :: u8 ,) , # [codec (index = 85)] Mortal85 (:: core :: primitive :: u8 ,) , # [codec (index = 86)] Mortal86 (:: core :: primitive :: u8 ,) , # [codec (index = 87)] Mortal87 (:: core :: primitive :: u8 ,) , # [codec (index = 88)] Mortal88 (:: core :: primitive :: u8 ,) , # [codec (index = 89)] Mortal89 (:: core :: primitive :: u8 ,) , # [codec (index = 90)] Mortal90 (:: core :: primitive :: u8 ,) , # [codec (index = 91)] Mortal91 (:: core :: primitive :: u8 ,) , # [codec (index = 92)] Mortal92 (:: core :: primitive :: u8 ,) , # [codec (index = 93)] Mortal93 (:: core :: primitive :: u8 ,) , # [codec (index = 94)] Mortal94 (:: core :: primitive :: u8 ,) , # [codec (index = 95)] Mortal95 (:: core :: primitive :: u8 ,) , # [codec (index = 96)] Mortal96 (:: core :: primitive :: u8 ,) , # [codec (index = 97)] Mortal97 (:: core :: primitive :: u8 ,) , # [codec (index = 98)] Mortal98 (:: core :: primitive :: u8 ,) , # [codec (index = 99)] Mortal99 (:: core :: primitive :: u8 ,) , # [codec (index = 100)] Mortal100 (:: core :: primitive :: u8 ,) , # [codec (index = 101)] Mortal101 (:: core :: primitive :: u8 ,) , # [codec (index = 102)] Mortal102 (:: core :: primitive :: u8 ,) , # [codec (index = 103)] Mortal103 (:: core :: primitive :: u8 ,) , # [codec (index = 104)] Mortal104 (:: core :: primitive :: u8 ,) , # [codec (index = 105)] Mortal105 (:: core :: primitive :: u8 ,) , # [codec (index = 106)] Mortal106 (:: core :: primitive :: u8 ,) , # [codec (index = 107)] Mortal107 (:: core :: primitive :: u8 ,) , # [codec (index = 108)] Mortal108 (:: core :: primitive :: u8 ,) , # [codec (index = 109)] Mortal109 (:: core :: primitive :: u8 ,) , # [codec (index = 110)] Mortal110 (:: core :: primitive :: u8 ,) , # [codec (index = 111)] Mortal111 (:: core :: primitive :: u8 ,) , # [codec (index = 112)] Mortal112 (:: core :: primitive :: u8 ,) , # [codec (index = 113)] Mortal113 (:: core :: primitive :: u8 ,) , # [codec (index = 114)] Mortal114 (:: core :: primitive :: u8 ,) , # [codec (index = 115)] Mortal115 (:: core :: primitive :: u8 ,) , # [codec (index = 116)] Mortal116 (:: core :: primitive :: u8 ,) , # [codec (index = 117)] Mortal117 (:: core :: primitive :: u8 ,) , # [codec (index = 118)] Mortal118 (:: core :: primitive :: u8 ,) , # [codec (index = 119)] Mortal119 (:: core :: primitive :: u8 ,) , # [codec (index = 120)] Mortal120 (:: core :: primitive :: u8 ,) , # [codec (index = 121)] Mortal121 (:: core :: primitive :: u8 ,) , # [codec (index = 122)] Mortal122 (:: core :: primitive :: u8 ,) , # [codec (index = 123)] Mortal123 (:: core :: primitive :: u8 ,) , # [codec (index = 124)] Mortal124 (:: core :: primitive :: u8 ,) , # [codec (index = 125)] Mortal125 (:: core :: primitive :: u8 ,) , # [codec (index = 126)] Mortal126 (:: core :: primitive :: u8 ,) , # [codec (index = 127)] Mortal127 (:: core :: primitive :: u8 ,) , # [codec (index = 128)] Mortal128 (:: core :: primitive :: u8 ,) , # [codec (index = 129)] Mortal129 (:: core :: primitive :: u8 ,) , # [codec (index = 130)] Mortal130 (:: core :: primitive :: u8 ,) , # [codec (index = 131)] Mortal131 (:: core :: primitive :: u8 ,) , # [codec (index = 132)] Mortal132 (:: core :: primitive :: u8 ,) , # [codec (index = 133)] Mortal133 (:: core :: primitive :: u8 ,) , # [codec (index = 134)] Mortal134 (:: core :: primitive :: u8 ,) , # [codec (index = 135)] Mortal135 (:: core :: primitive :: u8 ,) , # [codec (index = 136)] Mortal136 (:: core :: primitive :: u8 ,) , # [codec (index = 137)] Mortal137 (:: core :: primitive :: u8 ,) , # [codec (index = 138)] Mortal138 (:: core :: primitive :: u8 ,) , # [codec (index = 139)] Mortal139 (:: core :: primitive :: u8 ,) , # [codec (index = 140)] Mortal140 (:: core :: primitive :: u8 ,) , # [codec (index = 141)] Mortal141 (:: core :: primitive :: u8 ,) , # [codec (index = 142)] Mortal142 (:: core :: primitive :: u8 ,) , # [codec (index = 143)] Mortal143 (:: core :: primitive :: u8 ,) , # [codec (index = 144)] Mortal144 (:: core :: primitive :: u8 ,) , # [codec (index = 145)] Mortal145 (:: core :: primitive :: u8 ,) , # [codec (index = 146)] Mortal146 (:: core :: primitive :: u8 ,) , # [codec (index = 147)] Mortal147 (:: core :: primitive :: u8 ,) , # [codec (index = 148)] Mortal148 (:: core :: primitive :: u8 ,) , # [codec (index = 149)] Mortal149 (:: core :: primitive :: u8 ,) , # [codec (index = 150)] Mortal150 (:: core :: primitive :: u8 ,) , # [codec (index = 151)] Mortal151 (:: core :: primitive :: u8 ,) , # [codec (index = 152)] Mortal152 (:: core :: primitive :: u8 ,) , # [codec (index = 153)] Mortal153 (:: core :: primitive :: u8 ,) , # [codec (index = 154)] Mortal154 (:: core :: primitive :: u8 ,) , # [codec (index = 155)] Mortal155 (:: core :: primitive :: u8 ,) , # [codec (index = 156)] Mortal156 (:: core :: primitive :: u8 ,) , # [codec (index = 157)] Mortal157 (:: core :: primitive :: u8 ,) , # [codec (index = 158)] Mortal158 (:: core :: primitive :: u8 ,) , # [codec (index = 159)] Mortal159 (:: core :: primitive :: u8 ,) , # [codec (index = 160)] Mortal160 (:: core :: primitive :: u8 ,) , # [codec (index = 161)] Mortal161 (:: core :: primitive :: u8 ,) , # [codec (index = 162)] Mortal162 (:: core :: primitive :: u8 ,) , # [codec (index = 163)] Mortal163 (:: core :: primitive :: u8 ,) , # [codec (index = 164)] Mortal164 (:: core :: primitive :: u8 ,) , # [codec (index = 165)] Mortal165 (:: core :: primitive :: u8 ,) , # [codec (index = 166)] Mortal166 (:: core :: primitive :: u8 ,) , # [codec (index = 167)] Mortal167 (:: core :: primitive :: u8 ,) , # [codec (index = 168)] Mortal168 (:: core :: primitive :: u8 ,) , # [codec (index = 169)] Mortal169 (:: core :: primitive :: u8 ,) , # [codec (index = 170)] Mortal170 (:: core :: primitive :: u8 ,) , # [codec (index = 171)] Mortal171 (:: core :: primitive :: u8 ,) , # [codec (index = 172)] Mortal172 (:: core :: primitive :: u8 ,) , # [codec (index = 173)] Mortal173 (:: core :: primitive :: u8 ,) , # [codec (index = 174)] Mortal174 (:: core :: primitive :: u8 ,) , # [codec (index = 175)] Mortal175 (:: core :: primitive :: u8 ,) , # [codec (index = 176)] Mortal176 (:: core :: primitive :: u8 ,) , # [codec (index = 177)] Mortal177 (:: core :: primitive :: u8 ,) , # [codec (index = 178)] Mortal178 (:: core :: primitive :: u8 ,) , # [codec (index = 179)] Mortal179 (:: core :: primitive :: u8 ,) , # [codec (index = 180)] Mortal180 (:: core :: primitive :: u8 ,) , # [codec (index = 181)] Mortal181 (:: core :: primitive :: u8 ,) , # [codec (index = 182)] Mortal182 (:: core :: primitive :: u8 ,) , # [codec (index = 183)] Mortal183 (:: core :: primitive :: u8 ,) , # [codec (index = 184)] Mortal184 (:: core :: primitive :: u8 ,) , # [codec (index = 185)] Mortal185 (:: core :: primitive :: u8 ,) , # [codec (index = 186)] Mortal186 (:: core :: primitive :: u8 ,) , # [codec (index = 187)] Mortal187 (:: core :: primitive :: u8 ,) , # [codec (index = 188)] Mortal188 (:: core :: primitive :: u8 ,) , # [codec (index = 189)] Mortal189 (:: core :: primitive :: u8 ,) , # [codec (index = 190)] Mortal190 (:: core :: primitive :: u8 ,) , # [codec (index = 191)] Mortal191 (:: core :: primitive :: u8 ,) , # [codec (index = 192)] Mortal192 (:: core :: primitive :: u8 ,) , # [codec (index = 193)] Mortal193 (:: core :: primitive :: u8 ,) , # [codec (index = 194)] Mortal194 (:: core :: primitive :: u8 ,) , # [codec (index = 195)] Mortal195 (:: core :: primitive :: u8 ,) , # [codec (index = 196)] Mortal196 (:: core :: primitive :: u8 ,) , # [codec (index = 197)] Mortal197 (:: core :: primitive :: u8 ,) , # [codec (index = 198)] Mortal198 (:: core :: primitive :: u8 ,) , # [codec (index = 199)] Mortal199 (:: core :: primitive :: u8 ,) , # [codec (index = 200)] Mortal200 (:: core :: primitive :: u8 ,) , # [codec (index = 201)] Mortal201 (:: core :: primitive :: u8 ,) , # [codec (index = 202)] Mortal202 (:: core :: primitive :: u8 ,) , # [codec (index = 203)] Mortal203 (:: core :: primitive :: u8 ,) , # [codec (index = 204)] Mortal204 (:: core :: primitive :: u8 ,) , # [codec (index = 205)] Mortal205 (:: core :: primitive :: u8 ,) , # [codec (index = 206)] Mortal206 (:: core :: primitive :: u8 ,) , # [codec (index = 207)] Mortal207 (:: core :: primitive :: u8 ,) , # [codec (index = 208)] Mortal208 (:: core :: primitive :: u8 ,) , # [codec (index = 209)] Mortal209 (:: core :: primitive :: u8 ,) , # [codec (index = 210)] Mortal210 (:: core :: primitive :: u8 ,) , # [codec (index = 211)] Mortal211 (:: core :: primitive :: u8 ,) , # [codec (index = 212)] Mortal212 (:: core :: primitive :: u8 ,) , # [codec (index = 213)] Mortal213 (:: core :: primitive :: u8 ,) , # [codec (index = 214)] Mortal214 (:: core :: primitive :: u8 ,) , # [codec (index = 215)] Mortal215 (:: core :: primitive :: u8 ,) , # [codec (index = 216)] Mortal216 (:: core :: primitive :: u8 ,) , # [codec (index = 217)] Mortal217 (:: core :: primitive :: u8 ,) , # [codec (index = 218)] Mortal218 (:: core :: primitive :: u8 ,) , # [codec (index = 219)] Mortal219 (:: core :: primitive :: u8 ,) , # [codec (index = 220)] Mortal220 (:: core :: primitive :: u8 ,) , # [codec (index = 221)] Mortal221 (:: core :: primitive :: u8 ,) , # [codec (index = 222)] Mortal222 (:: core :: primitive :: u8 ,) , # [codec (index = 223)] Mortal223 (:: core :: primitive :: u8 ,) , # [codec (index = 224)] Mortal224 (:: core :: primitive :: u8 ,) , # [codec (index = 225)] Mortal225 (:: core :: primitive :: u8 ,) , # [codec (index = 226)] Mortal226 (:: core :: primitive :: u8 ,) , # [codec (index = 227)] Mortal227 (:: core :: primitive :: u8 ,) , # [codec (index = 228)] Mortal228 (:: core :: primitive :: u8 ,) , # [codec (index = 229)] Mortal229 (:: core :: primitive :: u8 ,) , # [codec (index = 230)] Mortal230 (:: core :: primitive :: u8 ,) , # [codec (index = 231)] Mortal231 (:: core :: primitive :: u8 ,) , # [codec (index = 232)] Mortal232 (:: core :: primitive :: u8 ,) , # [codec (index = 233)] Mortal233 (:: core :: primitive :: u8 ,) , # [codec (index = 234)] Mortal234 (:: core :: primitive :: u8 ,) , # [codec (index = 235)] Mortal235 (:: core :: primitive :: u8 ,) , # [codec (index = 236)] Mortal236 (:: core :: primitive :: u8 ,) , # [codec (index = 237)] Mortal237 (:: core :: primitive :: u8 ,) , # [codec (index = 238)] Mortal238 (:: core :: primitive :: u8 ,) , # [codec (index = 239)] Mortal239 (:: core :: primitive :: u8 ,) , # [codec (index = 240)] Mortal240 (:: core :: primitive :: u8 ,) , # [codec (index = 241)] Mortal241 (:: core :: primitive :: u8 ,) , # [codec (index = 242)] Mortal242 (:: core :: primitive :: u8 ,) , # [codec (index = 243)] Mortal243 (:: core :: primitive :: u8 ,) , # [codec (index = 244)] Mortal244 (:: core :: primitive :: u8 ,) , # [codec (index = 245)] Mortal245 (:: core :: primitive :: u8 ,) , # [codec (index = 246)] Mortal246 (:: core :: primitive :: u8 ,) , # [codec (index = 247)] Mortal247 (:: core :: primitive :: u8 ,) , # [codec (index = 248)] Mortal248 (:: core :: primitive :: u8 ,) , # [codec (index = 249)] Mortal249 (:: core :: primitive :: u8 ,) , # [codec (index = 250)] Mortal250 (:: core :: primitive :: u8 ,) , # [codec (index = 251)] Mortal251 (:: core :: primitive :: u8 ,) , # [codec (index = 252)] Mortal252 (:: core :: primitive :: u8 ,) , # [codec (index = 253)] Mortal253 (:: core :: primitive :: u8 ,) , # [codec (index = 254)] Mortal254 (:: core :: primitive :: u8 ,) , # [codec (index = 255)] Mortal255 (:: core :: primitive :: u8 ,) , } } pub mod header { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct Header < _0 > { pub parent_hash : :: subxt :: ext :: subxt_core :: utils :: H256 , # [codec (compact)] pub number : _0 , pub state_root : :: subxt :: ext :: subxt_core :: utils :: H256 , pub extrinsics_root : :: subxt :: ext :: subxt_core :: utils :: H256 , pub digest : runtime_types :: sp_runtime :: generic :: digest :: Digest , } } } pub mod traits { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct BlakeTwo256 ; } pub mod transaction_validity { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum InvalidTransaction { # [codec (index = 0)] Call , # [codec (index = 1)] Payment , # [codec (index = 2)] Future , # [codec (index = 3)] Stale , # [codec (index = 4)] BadProof , # [codec (index = 5)] AncientBirthBlock , # [codec (index = 6)] ExhaustsResources , # [codec (index = 7)] Custom (:: core :: primitive :: u8 ,) , # [codec (index = 8)] BadMandatory , # [codec (index = 9)] MandatoryValidation , # [codec (index = 10)] BadSigner , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum TransactionSource { # [codec (index = 0)] InBlock , # [codec (index = 1)] Local , # [codec (index = 2)] External , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum TransactionValidityError { # [codec (index = 0)] Invalid (runtime_types :: sp_runtime :: transaction_validity :: InvalidTransaction ,) , # [codec (index = 1)] Unknown (runtime_types :: sp_runtime :: transaction_validity :: UnknownTransaction ,) , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum UnknownTransaction { # [codec (index = 0)] CannotLookup , # [codec (index = 1)] NoUnsignedValidator , # [codec (index = 2)] Custom (:: core :: primitive :: u8 ,) , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct ValidTransaction { pub priority : :: core :: primitive :: u64 , pub requires : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > > , pub provides : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > > , pub longevity : :: core :: primitive :: u64 , pub propagate : :: core :: primitive :: bool , } } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum DispatchError { # [codec (index = 0)] Other , # [codec (index = 1)] CannotLookup , # [codec (index = 2)] BadOrigin , # [codec (index = 3)] Module (runtime_types :: sp_runtime :: ModuleError ,) , # [codec (index = 4)] ConsumerRemaining , # [codec (index = 5)] NoProviders , # [codec (index = 6)] TooManyConsumers , # [codec (index = 7)] Token (runtime_types :: sp_runtime :: TokenError ,) , # [codec (index = 8)] Arithmetic (runtime_types :: sp_arithmetic :: ArithmeticError ,) , # [codec (index = 9)] Transactional (runtime_types :: sp_runtime :: TransactionalError ,) , # [codec (index = 10)] Exhausted , # [codec (index = 11)] Corruption , # [codec (index = 12)] Unavailable , # [codec (index = 13)] RootNotAllowed , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum ExtrinsicInclusionMode { # [codec (index = 0)] AllExtrinsics , # [codec (index = 1)] OnlyInherents , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct ModuleError { pub index : :: core :: primitive :: u8 , pub error : [:: core :: primitive :: u8 ; 4usize] , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum MultiSignature { # [codec (index = 0)] Ed25519 ([:: core :: primitive :: u8 ; 64usize] ,) , # [codec (index = 1)] Sr25519 ([:: core :: primitive :: u8 ; 64usize] ,) , # [codec (index = 2)] Ecdsa ([:: core :: primitive :: u8 ; 65usize] ,) , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum TokenError { # [codec (index = 0)] FundsUnavailable , # [codec (index = 1)] OnlyProvider , # [codec (index = 2)] BelowMinimum , # [codec (index = 3)] CannotCreate , # [codec (index = 4)] UnknownAsset , # [codec (index = 5)] Frozen , # [codec (index = 6)] Unsupported , # [codec (index = 7)] CannotCreateHold , # [codec (index = 8)] NotExpendable , # [codec (index = 9)] Blocked , } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum TransactionalError { # [codec (index = 0)] LimitReached , # [codec (index = 1)] NoLayer , } } pub mod sp_version { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct RuntimeVersion { pub spec_name : :: subxt :: ext :: subxt_core :: alloc :: string :: String , pub impl_name : :: subxt :: ext :: subxt_core :: alloc :: string :: String , pub authoring_version : :: core :: primitive :: u32 , pub spec_version : :: core :: primitive :: u32 , pub impl_version : :: core :: primitive :: u32 , pub apis : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < ([:: core :: primitive :: u8 ; 8usize] , :: core :: primitive :: u32 ,) > , pub transaction_version : :: core :: primitive :: u32 , pub state_version : :: core :: primitive :: u8 , } } pub mod sp_weights { use super :: runtime_types ; pub mod weight_v2 { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct Weight { # [codec (compact)] pub ref_time : :: core :: primitive :: u64 , # [codec (compact)] pub proof_size : :: core :: primitive :: u64 , } } # [derive (:: subxt :: ext :: subxt_core :: ext :: codec :: Decode , :: subxt :: ext :: subxt_core :: ext :: codec :: Encode , :: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [codec (crate = :: subxt :: ext :: subxt_core :: ext :: codec)] # [codec (dumb_trait_bound)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct RuntimeDbWeight { pub read : :: core :: primitive :: u64 , pub write : :: core :: primitive :: u64 , } } } }